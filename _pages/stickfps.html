<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Multiplayer WebGL FPS</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      background: #000;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    #header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 80px;
      background: rgba(0, 0, 0, 0.85);
      border-bottom: 2px solid rgba(255, 255, 255, 0.1);
      z-index: 20;
      display: flex;
      align-items: center;
      padding: 0 20px;
      gap: 20px;
    }
    #header .logo-link {
      display: flex;
      align-items: center;
      text-decoration: none;
      transition: transform 0.2s ease;
    }
    #header .logo-link:hover {
      transform: scale(1.05);
    }
    #header .logo-link img {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.3);
    }
    #header h1 {
      margin: 0;
      color: #fff;
      font-size: 24px;
      font-weight: 600;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
    }
    #info {
      position: absolute;
      top: 90px;
      left: 10px;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      font-size: 13px;
      border-radius: 4px;
      z-index: 10;
      max-width: 260px;
      line-height: 1.4;
    }
    #grenadeCount {
      position: absolute;
      top: 140px;
      left: 10px;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      font-size: 18px;
      border-radius: 4px;
      z-index: 10;
      font-weight: bold;
    }
    #grenadeCount .icon {
      color: #ff6600;
      font-size: 24px;
      margin-right: 8px;
    }
    #stats {
      position: absolute;
      top: 90px;
      right: 10px;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      font-size: 12px;
      border-radius: 4px;
      z-index: 10;
    }
    #health {
      position: absolute;
      bottom: 0;
      right: 0;
      padding: 16px 20px;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      font-size: 36px;
      border-radius: 8px 0 0 0;
      z-index: 10;
      display: flex;
      gap: 8px;
    }
    .heart {
      color: #ff4444;
      text-shadow: 0 0 8px rgba(255, 68, 68, 0.8);
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
    }
    .heart.lost {
      color: #444;
      text-shadow: none;
      filter: none;
    }
    #killFeed {
      position: absolute;
      bottom: 20px;
      left: 20px;
      z-index: 10;
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-width: 300px;
    }
    .kill-entry {
      background: rgba(0, 0, 0, 0.8);
      padding: 8px 12px;
      border-radius: 4px;
      color: #fff;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
      animation: slideIn 0.3s ease-out, fadeOut 0.5s ease-out 4.5s forwards;
    }
    .kill-entry .killer {
      color: #ff4444;
      font-weight: bold;
    }
    .kill-entry .victim {
      color: #aaa;
    }
    .kill-entry .separator {
      color: #666;
      font-size: 12px;
    }
    @keyframes slideIn {
      from {
        transform: translateX(-100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    @keyframes fadeOut {
      to {
        opacity: 0;
        transform: translateX(-20px);
      }
    }
    #respawnOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 15;
      flex-direction: column;
      gap: 20px;
    }
    #respawnOverlay.active {
      display: flex;
    }
    #respawnTimer {
      font-size: 72px;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
    }
    #respawnText {
      font-size: 24px;
      color: #ccc;
    }
    canvas.dead {
      filter: grayscale(1) brightness(0.6);
    }
    #crosshair {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 20px;
      height: 20px;
      margin-left: -10px;
      margin-top: -10px;
      pointer-events: none;
      z-index: 9;
    }
    #crosshair:before,
    #crosshair:after {
      content: "";
      position: absolute;
      background: rgba(255,255,255,0.8);
    }
    #crosshair:before {
      left: 50%;
      top: 0;
      width: 2px;
      height: 100%;
      margin-left: -1px;
    }
    #crosshair:after {
      top: 50%;
      left: 0;
      width: 100%;
      height: 2px;
      margin-top: -1px;
    }
    #gun {
      position: absolute;
      bottom: 50px;
      right: 80px;
      transform: translateX(-50%);
      width: 140px;
      height: 100px;
      pointer-events: none;
      z-index: 8;
    }
    #gun::before {
      content: "";
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 45px;
      height: 55px;
      background: linear-gradient(to bottom, #2a2a2a, #1a1a1a);
      border-radius: 4px;
      border: 2px solid #444;
      box-shadow: 
        inset 0 2px 4px rgba(255,255,255,0.1),
        0 4px 12px rgba(0,0,0,0.8);
    }
    #gun::after {
      content: "";
      position: absolute;
      bottom: 55px;
      left: 50%;
      transform: translateX(-50%);
      width: 12px;
      height: 50px;
      background: linear-gradient(to top, #3a3a3a, #555);
      border-radius: 2px;
      border: 1px solid #666;
      box-shadow: 
        inset 0 1px 2px rgba(255,255,255,0.2),
        0 2px 8px rgba(0,0,0,0.6);
    }
    .gun-sight {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 8px;
      height: 8px;
      background: #ff4444;
      border-radius: 50%;
      box-shadow: 0 0 8px #ff4444;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    .shoot-flash {
      animation: flash 0.1s ease-out;
    }
    @keyframes flash {
      0% { filter: brightness(1.5); }
      100% { filter: brightness(1); }
    }
    #damageIndicators {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 7;
    }
    .damage-indicator {
      position: absolute;
      background: radial-gradient(circle, rgba(255,0,0,0.6), transparent);
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }
    .damage-indicator.left {
      left: 0;
      top: 0;
      width: 30%;
      height: 100%;
      background: linear-gradient(to right, rgba(255,0,0,0.5), transparent);
    }
    .damage-indicator.right {
      right: 0;
      top: 0;
      width: 30%;
      height: 100%;
      background: linear-gradient(to left, rgba(255,0,0,0.5), transparent);
    }
    .damage-indicator.top {
      top: 0;
      left: 0;
      width: 100%;
      height: 30%;
      background: linear-gradient(to bottom, rgba(255,0,0,0.5), transparent);
    }
    .damage-indicator.bottom {
      bottom: 0;
      left: 0;
      width: 100%;
      height: 30%;
      background: linear-gradient(to top, rgba(255,0,0,0.5), transparent);
    }
    .damage-indicator.active {
      opacity: 1;
    }
    #hitMarker {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 30px;
      height: 30px;
      margin-left: -15px;
      margin-top: -15px;
      pointer-events: none;
      z-index: 11;
      opacity: 0;
      transition: opacity 0.1s;
    }
    #hitMarker.active {
      opacity: 1;
    }
    #hitMarker::before,
    #hitMarker::after {
      content: "";
      position: absolute;
      background: white;
    }
    #hitMarker::before {
      left: 0;
      top: 50%;
      width: 100%;
      height: 2px;
      margin-top: -1px;
    }
    #hitMarker::after {
      top: 0;
      left: 50%;
      width: 2px;
      height: 100%;
      margin-left: -1px;
    }
    #vignette {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 6;
      background: radial-gradient(circle at center, transparent 40%, rgba(139,0,0,0) 60%, rgba(139,0,0,0.4) 100%);
      opacity: 0;
      transition: opacity 0.3s;
    }
    #vignette.active {
      opacity: 1;
    }
    #captureProgress {
      position: absolute;
      top: 130px;
      right: 10px;
      width: 280px;
      pointer-events: none;
      z-index: 10;
      display: none;
    }
    #captureProgress.active {
      display: block;
      animation: slideInRight 0.3s ease-out;
    }
    @keyframes slideInRight {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    .capture-bar-container {
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    }
    .capture-bar-label {
      color: #fff;
      font-size: 14px;
      font-weight: bold;
      text-align: center;
      margin-bottom: 8px;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
    }
    .capture-bar-bg {
      width: 100%;
      height: 24px;
      background: rgba(50, 50, 50, 0.8);
      border-radius: 4px;
      overflow: hidden;
      position: relative;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    .capture-bar-fill {
      height: 100%;
      transition: width 0.1s linear;
      position: relative;
      border-radius: 3px;
    }
    .capture-bar-fill.capturing {
      background: linear-gradient(90deg, #4CAF50, #8BC34A);
      box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
    }
    .capture-bar-fill.decapturing {
      background: linear-gradient(90deg, #f44336, #ff5722);
      box-shadow: 0 0 10px rgba(244, 67, 54, 0.5);
    }
    .capture-bar-fill.contested {
      background: linear-gradient(90deg, #ff9800, #ffc107);
      animation: pulse 0.5s infinite alternate;
    }
    @keyframes pulse {
      from { opacity: 0.7; }
      to { opacity: 1; }
    }
  </style>
</head>
<body>
  <div id="header">
    <a href="https://cicero343.github.io" class="logo-link">
      <img src="https://avatars.githubusercontent.com/u/175522457?v=4" alt="Logo">
    </a>
    <h1>Stick FPS - 3D Multiplayer Game</h1>
  </div>
  <div id="info">
    <strong>Multiplayer WebGL FPS</strong><br>
    Click to lock mouse.<br>
    <b>W A S D</b> to move, mouse to look.<br>
    <b>Space</b> to jump.<br>
    <b>Left click</b> to shoot.<br>
    <b>Right click</b> to throw grenade.<br>
    Press <b>Esc</b> to release mouse.
  </div>
  <div id="grenadeCount">
    <span class="icon">ðŸ’£</span><span id="grenadeAmount">0</span>
  </div>
  <div id="stats">
    Players online: <span id="playerCount">0</span>
  </div>
  <div id="health"></div>
  <div id="killFeed"></div>
  <div id="respawnOverlay">
    <div id="respawnTimer">6</div>
    <div id="respawnText">Respawning...</div>
  </div>
  <div id="vignette"></div>
  <div id="damageIndicators">
    <div class="damage-indicator left"></div>
    <div class="damage-indicator right"></div>
    <div class="damage-indicator top"></div>
    <div class="damage-indicator bottom"></div>
  </div>
  <div id="hitMarker"></div>
  <div id="crosshair"></div>
  <div id="captureProgress">
    <div class="capture-bar-container">
      <div class="capture-bar-label" id="captureLabel">Capturing...</div>
      <div class="capture-bar-bg">
        <div class="capture-bar-fill" id="captureFill"></div>
      </div>
    </div>
  </div>
  <div id="gun">
    <div class="gun-sight"></div>
  </div>
  <canvas id="glcanvas"></canvas>

  <script type="module">
    // ====== Firebase Setup ======
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
    import { getDatabase, ref, set, onValue, push, remove, onDisconnect } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

    const firebaseConfig = {
      apiKey: "AIzaSyA8dX6FOpsa93u15yb7X1iTW3z3B1Hz1y0",
      authDomain: "d-multiplayer-game-1f2aa.firebaseapp.com",
      databaseURL: "https://d-multiplayer-game-1f2aa-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "d-multiplayer-game-1f2aa",
      storageBucket: "d-multiplayer-game-1f2aa.firebasestorage.app",
      messagingSenderId: "820714487230",
      appId: "1:820714487230:web:8218a404e5a37083dfcdef",
      measurementId: "G-9RVJ2C4ERN"
    };

    const app = initializeApp(firebaseConfig);
    const database = getDatabase(app);

    // ====== Audio Setup ======
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

    // Generate gunshot sound
    function playGunshotSound() {
      const now = audioContext.currentTime;
      
      // Create noise for the gunshot
      const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1, audioContext.sampleRate);
      const noiseData = noiseBuffer.getChannelData(0);
      for (let i = 0; i < noiseData.length; i++) {
        noiseData[i] = Math.random() * 2 - 1;
      }
      
      const noise = audioContext.createBufferSource();
      noise.buffer = noiseBuffer;
      
      // Filter for gunshot character
      const filter = audioContext.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.value = 400;
      filter.Q.value = 1;
      
      // Envelope for gunshot
      const gainNode = audioContext.createGain();
      gainNode.gain.setValueAtTime(0.3, now);
      gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
      
      // Connect and play
      noise.connect(filter);
      filter.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      noise.start(now);
      noise.stop(now + 0.1);
    }

    // Generate hit/thud sound
    function playHitSound() {
      const now = audioContext.currentTime;
      
      // Low frequency thud
      const oscillator = audioContext.createOscillator();
      oscillator.type = 'sine';
      oscillator.frequency.setValueAtTime(150, now);
      oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.15);
      
      // Short impact envelope
      const gainNode = audioContext.createGain();
      gainNode.gain.setValueAtTime(0.2, now);
      gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
      
      // Connect and play
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.start(now);
      oscillator.stop(now + 0.15);
    }

    // ====== Basic WebGL setup ======
    const canvas = document.getElementById("glcanvas");
    const gl = canvas.getContext("webgl");
    if (!gl) {
      alert("WebGL not supported");
    }

    canvas.addEventListener("contextmenu", (e) => e.preventDefault());

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      gl.viewport(0, 0, canvas.width, canvas.height);
    }
    window.addEventListener("resize", resize);
    resize();

    // ====== Shaders ======
    const vsSource = `
      attribute vec3 aPosition;
      attribute vec3 aColor;
      uniform mat4 uMatrix;
      varying vec3 vColor;
      void main(void) {
        gl_Position = uMatrix * vec4(aPosition, 1.0);
        vColor = aColor;
        gl_PointSize = 6.0;
      }
    `;

    const fsSource = `
      precision mediump float;
      varying vec3 vColor;
      void main(void) {
        gl_FragColor = vec4(vColor, 1.0);
      }
    `;

    function compileShader(source, type) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    const vs = compileShader(vsSource, gl.VERTEX_SHADER);
    const fs = compileShader(fsSource, gl.FRAGMENT_SHADER);

    const program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error(gl.getProgramInfoLog(program));
    }
    gl.useProgram(program);

    const aPositionLoc = gl.getAttribLocation(program, "aPosition");
    const aColorLoc = gl.getAttribLocation(program, "aColor");
    const uMatrixLoc = gl.getUniformLocation(program, "uMatrix");

    // ====== Helpers ======
    function pushVertex(arr, x, y, z, r, g, b) {
      arr.push(x, y, z, r, g, b);
    }

    function addBoxVertices(arr, cx, cy, cz, sx, sy, sz, color) {
      const [r, g, b] = color;
      const hx = sx / 2, hy = sy / 2, hz = sz / 2;
      const x1 = cx - hx, x2 = cx + hx;
      const y1 = cy - hy, y2 = cy + hy;
      const z1 = cz - hz, z2 = cz + hz;

      // Front
      pushVertex(arr, x1, y1, z1, r, g, b);
      pushVertex(arr, x2, y1, z1, r, g, b);
      pushVertex(arr, x2, y2, z1, r, g, b);
      pushVertex(arr, x1, y1, z1, r, g, b);
      pushVertex(arr, x2, y2, z1, r, g, b);
      pushVertex(arr, x1, y2, z1, r, g, b);

      // Back
      pushVertex(arr, x2, y1, z2, r, g, b);
      pushVertex(arr, x1, y1, z2, r, g, b);
      pushVertex(arr, x1, y2, z2, r, g, b);
      pushVertex(arr, x2, y1, z2, r, g, b);
      pushVertex(arr, x1, y2, z2, r, g, b);
      pushVertex(arr, x2, y2, z2, r, g, b);

      // Left
      pushVertex(arr, x1, y1, z2, r, g, b);
      pushVertex(arr, x1, y1, z1, r, g, b);
      pushVertex(arr, x1, y2, z1, r, g, b);
      pushVertex(arr, x1, y1, z2, r, g, b);
      pushVertex(arr, x1, y2, z1, r, g, b);
      pushVertex(arr, x1, y2, z2, r, g, b);

      // Right
      pushVertex(arr, x2, y1, z1, r, g, b);
      pushVertex(arr, x2, y1, z2, r, g, b);
      pushVertex(arr, x2, y2, z2, r, g, b);
      pushVertex(arr, x2, y1, z1, r, g, b);
      pushVertex(arr, x2, y2, z2, r, g, b);
      pushVertex(arr, x2, y2, z1, r, g, b);

      // Top
      pushVertex(arr, x1, y2, z1, r, g, b);
      pushVertex(arr, x2, y2, z1, r, g, b);
      pushVertex(arr, x2, y2, z2, r, g, b);
      pushVertex(arr, x1, y2, z1, r, g, b);
      pushVertex(arr, x2, y2, z2, r, g, b);
      pushVertex(arr, x1, y2, z2, r, g, b);

      // Bottom
      pushVertex(arr, x1, y1, z2, r, g, b);
      pushVertex(arr, x2, y1, z2, r, g, b);
      pushVertex(arr, x2, y1, z1, r, g, b);
      pushVertex(arr, x1, y1, z2, r, g, b);
      pushVertex(arr, x2, y1, z1, r, g, b);
      pushVertex(arr, x1, y1, z1, r, g, b);
    }

    // Add cylinder (for stickman limbs)
    function addCylinderVertices(arr, x1, y1, z1, x2, y2, z2, radius, color, segments = 6) {
      const [r, g, b] = color;
      const dx = x2 - x1, dy = y2 - y1, dz = z2 - z1;
      const len = Math.sqrt(dx*dx + dy*dy + dz*dz);
      
      if (len < 0.001) return;

      for (let i = 0; i < segments; i++) {
        const angle1 = (i / segments) * Math.PI * 2;
        const angle2 = ((i + 1) / segments) * Math.PI * 2;
        
        const cos1 = Math.cos(angle1) * radius;
        const sin1 = Math.sin(angle1) * radius;
        const cos2 = Math.cos(angle2) * radius;
        const sin2 = Math.sin(angle2) * radius;

        // Bottom triangle
        pushVertex(arr, x1, y1, z1, r, g, b);
        pushVertex(arr, x1 + cos1, y1, z1 + sin1, r, g, b);
        pushVertex(arr, x1 + cos2, y1, z1 + sin2, r, g, b);

        // Top triangle
        pushVertex(arr, x2, y2, z2, r, g, b);
        pushVertex(arr, x2 + cos2, y2, z2 + sin2, r, g, b);
        pushVertex(arr, x2 + cos1, y2, z2 + sin1, r, g, b);

        // Side quad (2 triangles)
        pushVertex(arr, x1 + cos1, y1, z1 + sin1, r, g, b);
        pushVertex(arr, x2 + cos1, y2, z2 + sin1, r, g, b);
        pushVertex(arr, x2 + cos2, y2, z2 + sin2, r, g, b);

        pushVertex(arr, x1 + cos1, y1, z1 + sin1, r, g, b);
        pushVertex(arr, x2 + cos2, y2, z2 + sin2, r, g, b);
        pushVertex(arr, x1 + cos2, y1, z1 + sin2, r, g, b);
      }
    }

    // Add sphere (for stickman head and grenades)
    function addSphereVertices(arr, cx, cy, cz, radius, color, segments = 8) {
      const [r, g, b] = color;
      
      for (let lat = 0; lat < segments; lat++) {
        const theta1 = (lat / segments) * Math.PI;
        const theta2 = ((lat + 1) / segments) * Math.PI;
        
        for (let lon = 0; lon < segments; lon++) {
          const phi1 = (lon / segments) * Math.PI * 2;
          const phi2 = ((lon + 1) / segments) * Math.PI * 2;

          const x1 = cx + radius * Math.sin(theta1) * Math.cos(phi1);
          const y1 = cy + radius * Math.cos(theta1);
          const z1 = cz + radius * Math.sin(theta1) * Math.sin(phi1);

          const x2 = cx + radius * Math.sin(theta1) * Math.cos(phi2);
          const y2 = cy + radius * Math.cos(theta1);
          const z2 = cz + radius * Math.sin(theta1) * Math.sin(phi2);

          const x3 = cx + radius * Math.sin(theta2) * Math.cos(phi2);
          const y3 = cy + radius * Math.cos(theta2);
          const z3 = cz + radius * Math.sin(theta2) * Math.sin(phi2);

          const x4 = cx + radius * Math.sin(theta2) * Math.cos(phi1);
          const y4 = cy + radius * Math.cos(theta2);
          const z4 = cz + radius * Math.sin(theta2) * Math.sin(phi1);

          pushVertex(arr, x1, y1, z1, r, g, b);
          pushVertex(arr, x2, y2, z2, r, g, b);
          pushVertex(arr, x3, y3, z3, r, g, b);

          pushVertex(arr, x1, y1, z1, r, g, b);
          pushVertex(arr, x3, y3, z3, r, g, b);
          pushVertex(arr, x4, y4, z4, r, g, b);
        }
      }
    }

    // Create stickman model with proper body rotation
    function addStickmanVertices(arr, x, y, z, yaw, color) {
      const headRadius = 0.3;
      const bodyHeight = 1.2;
      const limbRadius = 0.08;
      
      const cosYaw = Math.cos(yaw);
      const sinYaw = Math.sin(yaw);
      
      // Head
      addSphereVertices(arr, x, y + bodyHeight + headRadius, z, headRadius, color);
      
      // Body
      addCylinderVertices(arr, x, y, z, x, y + bodyHeight, z, limbRadius * 1.5, color);
      
      // Arms
      const armY = y + bodyHeight * 0.7;
      const armLength = 0.5;
      const armAngle = Math.PI / 6;
      
      const leftArmOffsetX = -cosYaw * 0.2;
      const leftArmOffsetZ = sinYaw * 0.2;
      const leftArmEndX = leftArmOffsetX - cosYaw * 0.15;
      const leftArmEndZ = leftArmOffsetZ + sinYaw * 0.15;
      
      addCylinderVertices(arr, 
        x + leftArmOffsetX, armY, z + leftArmOffsetZ,
        x + leftArmEndX, armY - armLength * Math.sin(armAngle), z + leftArmEndZ,
        limbRadius, color);
      
      const rightArmOffsetX = cosYaw * 0.2;
      const rightArmOffsetZ = -sinYaw * 0.2;
      const rightArmEndX = sinYaw * 0.3;
      const rightArmEndZ = cosYaw * 0.3;
      
      addCylinderVertices(arr, 
        x + rightArmOffsetX, armY, z + rightArmOffsetZ,
        x + rightArmEndX, armY - 0.2, z + rightArmEndZ,
        limbRadius, color);
      
      // Gun
      const gunX = x + rightArmEndX;
      const gunY = armY - 0.15;
      const gunZ = z + rightArmEndZ;
      const gunColorDark = [0.2, 0.2, 0.2];
      const gunColorLight = [0.4, 0.4, 0.4];
      
      const gripOffsetX = -sinYaw * 0.02;
      const gripOffsetZ = -cosYaw * 0.02;
      addBoxVertices(arr, gunX + gripOffsetX, gunY - 0.05, gunZ + gripOffsetZ, 
        0.06, 0.12, 0.06, gunColorDark);
      
      const barrelOffsetX = sinYaw * 0.1;
      const barrelOffsetZ = cosYaw * 0.1;
      addCylinderVertices(arr,
        gunX, gunY, gunZ,
        gunX + barrelOffsetX, gunY, gunZ + barrelOffsetZ,
        0.03, gunColorLight, 8);
      
      // Legs
      const legY = y;
      const legLen = 0.7;
      const legSpread = 0.15;
      
      const leftLegX = -cosYaw * legSpread;
      const leftLegZ = sinYaw * legSpread;
      
      addCylinderVertices(arr, 
        x + leftLegX, legY, z + leftLegZ,
        x + leftLegX, legY - legLen, z + leftLegZ,
        limbRadius, color);
      
      const rightLegX = cosYaw * legSpread;
      const rightLegZ = -sinYaw * legSpread;
      
      addCylinderVertices(arr, 
        x + rightLegX, legY, z + rightLegZ,
        x + rightLegX, legY - legLen, z + rightLegZ,
        limbRadius, color);
    }

    function bindAttributes() {
      const stride = 6 * 4;
      gl.vertexAttribPointer(aPositionLoc, 3, gl.FLOAT, false, stride, 0);
      gl.enableVertexAttribArray(aPositionLoc);
      gl.vertexAttribPointer(aColorLoc, 3, gl.FLOAT, false, stride, 3 * 4);
      gl.enableVertexAttribArray(aColorLoc);
    }

    gl.enable(gl.DEPTH_TEST);

    // ====== World geometry ======
    const worldVertices = [];
    const size = 500.0;
    const groundColor = [0.2, 0.7, 0.2];

    pushVertex(worldVertices, -size, 0, -size, ...groundColor);
    pushVertex(worldVertices,  size, 0, -size, ...groundColor);
    pushVertex(worldVertices,  size, 0,  size, ...groundColor);
    pushVertex(worldVertices, -size, 0, -size, ...groundColor);
    pushVertex(worldVertices,  size, 0,  size, ...groundColor);
    pushVertex(worldVertices, -size, 0,  size, ...groundColor);

    function addPillar(px, pz, height) {
      const w = 1.0;
      const color = [0.7, 0.7, 0.9];
      const x1 = px - w, x2 = px + w;
      const z1 = pz - w, z2 = pz + w;
      const y1 = 0,  y2 = height;

      pushVertex(worldVertices, x1, y1, z1, ...color);
      pushVertex(worldVertices, x2, y1, z1, ...color);
      pushVertex(worldVertices, x2, y2, z1, ...color);
      pushVertex(worldVertices, x1, y1, z1, ...color);
      pushVertex(worldVertices, x2, y2, z1, ...color);
      pushVertex(worldVertices, x1, y2, z1, ...color);

      pushVertex(worldVertices, x2, y1, z2, ...color);
      pushVertex(worldVertices, x1, y1, z2, ...color);
      pushVertex(worldVertices, x1, y2, z2, ...color);
      pushVertex(worldVertices, x2, y1, z2, ...color);
      pushVertex(worldVertices, x1, y2, z2, ...color);
      pushVertex(worldVertices, x2, y2, z2, ...color);

      pushVertex(worldVertices, x1, y1, z2, ...color);
      pushVertex(worldVertices, x1, y1, z1, ...color);
      pushVertex(worldVertices, x1, y2, z1, ...color);
      pushVertex(worldVertices, x1, y1, z2, ...color);
      pushVertex(worldVertices, x1, y2, z1, ...color);
      pushVertex(worldVertices, x1, y2, z2, ...color);

      pushVertex(worldVertices, x2, y1, z1, ...color);
      pushVertex(worldVertices, x2, y1, z2, ...color);
      pushVertex(worldVertices, x2, y2, z2, ...color);
      pushVertex(worldVertices, x2, y1, z1, ...color);
      pushVertex(worldVertices, x2, y2, z2, ...color);
      pushVertex(worldVertices, x2, y2, z1, ...color);

      pushVertex(worldVertices, x1, y2, z1, ...color);
      pushVertex(worldVertices, x2, y2, z1, ...color);
      pushVertex(worldVertices, x2, y2, z2, ...color);
      pushVertex(worldVertices, x1, y2, z1, ...color);
      pushVertex(worldVertices, x2, y2, z2, ...color);
      pushVertex(worldVertices, x1, y2, z2, ...color);
    }

    // King of the Pillar - Capture Points
    const capturePillars = [
      { x: 0, z: -15, h: 5, id: 0 },
      { x: 10, z: -30, h: 5, id: 1 },
      { x: -12, z: -25, h: 5, id: 2 },
      { x: 20, z: -50, h: 5, id: 3 },
      { x: -20, z: -50, h: 5, id: 4 }
    ];

    capturePillars.forEach(p => addPillar(p.x, p.z, p.h));

    const bottlePillarPos = { x: 0, z: -10, h: 2 };
    addPillar(bottlePillarPos.x, bottlePillarPos.z, bottlePillarPos.h);

    const worldVertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, worldVertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(worldVertices), gl.STATIC_DRAW);

    // ====== King of the Pillar System ======
    const CAPTURE_RADIUS = 4.0;
    const CAPTURE_TIME = 5.0; // seconds to capture
    const POINTS_TO_WIN = 40;
    const POINTS_PER_SECOND = 1;

    const captureCircles = [];
    const captureCircleBuffer = gl.createBuffer();
    const playerScores = new Map(); // playerId -> score

    // Initialize capture circles
    function initCaptureCircles() {
      captureCircles.length = 0;
      
      capturePillars.forEach(pillar => {
        captureCircles.push({
          id: pillar.id,
          x: pillar.x,
          z: pillar.z,
          progress: 0, // -1 to 1 (negative = being decaptured, positive = capturing)
          owner: null, // playerId of current owner
          capturingPlayer: null, // playerId currently capturing
          playersInside: new Set(),
          lastUpdate: Date.now()
        });
      });

      console.log('Initialized capture circles:', captureCircles);
      syncCaptureCircles();
    }

    function syncCaptureCircles() {
      const circleData = {};
      captureCircles.forEach(circle => {
        circleData[circle.id] = {
          progress: circle.progress || 0,
          owner: circle.owner || null,
          capturingPlayer: circle.capturingPlayer || null,
          playersInside: Array.from(circle.playersInside),
          lastUpdate: Date.now()
        };
      });
      set(ref(database, 'captureCircles'), circleData);
    }

    function checkPlayerInCircles() {
      if (!isAlive) return;

      let changed = false;
      captureCircles.forEach(circle => {
        const dx = camPos[0] - circle.x;
        const dz = camPos[2] - circle.z;
        const distSq = dx * dx + dz * dz;
        
        const wasInside = circle.playersInside.has(myPlayerId);
        const isInside = distSq < CAPTURE_RADIUS * CAPTURE_RADIUS;

        if (isInside !== wasInside) {
          if (isInside) {
            circle.playersInside.add(myPlayerId);
            console.log(`Entered circle ${circle.id}`);
          } else {
            circle.playersInside.delete(myPlayerId);
            console.log(`Left circle ${circle.id}`);
          }
          changed = true;
        }
      });
      
      if (changed) {
        syncCaptureCircles();
      }
    }

    function updateCaptureProgress(dt) {
      const now = Date.now();
      let needsSync = false;

      captureCircles.forEach(circle => {
        const playersInCircle = Array.from(circle.playersInside).filter(pid => {
          // Check if player is still valid and alive
          if (pid === myPlayerId) return isAlive;
          const p = remotePlayers[pid];
          return p && p.alive && p.lastUpdate && (now - p.lastUpdate) < 5000;
        });

        // Update the set with valid players only
        circle.playersInside = new Set(playersInCircle);

        // Contesting: if multiple players from different teams, freeze
        if (playersInCircle.length > 1) {
          circle.capturingPlayer = null;
          return; // No progress change
        }

        // Single player capturing
        if (playersInCircle.length === 1) {
          const capturer = playersInCircle[0];

          // Case 1: Circle is owned by someone else - must decapture first
          if (circle.owner && circle.owner !== capturer) {
            circle.capturingPlayer = capturer;
            circle.progress -= dt / CAPTURE_TIME;
            
            // Decapture complete - remove owner
            if (circle.progress <= 0) {
              circle.progress = 0;
              circle.owner = null;
              playGunshotSound(); // Audio feedback
              needsSync = true;
            }
          }
          // Case 2: Circle is unowned or owned by this player - capture/maintain
          else {
            circle.capturingPlayer = capturer;
            
            // Only gain progress if not already owner
            if (circle.owner !== capturer) {
              circle.progress += dt / CAPTURE_TIME;
              
              // Capture complete
              if (circle.progress >= 1) {
                circle.progress = 1;
                circle.owner = capturer;
                playHitSound(); // Audio feedback
                needsSync = true;
              }
            }
          }

          // Periodic sync while capturing (every 200ms)
          if (now - circle.lastUpdate > 200) {
            circle.lastUpdate = now;
            needsSync = true;
          }
        }
        // No players - maintain current state
        else {
          circle.capturingPlayer = null;
        }
      });

      // Only sync if something significant changed
      if (needsSync) {
        syncCaptureCircles();
      }
    }

    function updatePlayerScores(dt) {
      // Award points for owned circles
      captureCircles.forEach(circle => {
        if (circle.owner && circle.playersInside.size === 0) {
          // Only score when uncontested
          if (circle.owner === myPlayerId) {
            const currentScore = playerScores.get(myPlayerId) || 0;
            const newScore = currentScore + (POINTS_PER_SECOND * dt);
            playerScores.set(myPlayerId, newScore);

            // Check for win
            if (newScore >= POINTS_TO_WIN) {
              handleKOTPWin(myPlayerId);
            }
          }
        }
      });

      // Sync scores periodically
      if (Math.random() < 0.1) { // ~10% chance each frame
        syncPlayerScore();
      }
    }

    function syncPlayerScore() {
      const myScore = playerScores.get(myPlayerId) || 0;
      set(ref(database, `playerScores/${myPlayerId}`), {
        score: myScore,
        name: myName,
        timestamp: Date.now()
      });
    }

    function handleKOTPWin(winnerId) {
      const winnerName = playerNames.get(winnerId) || 'Unknown';
      
      // Announce in kill feed
      addKillToFeed('ðŸ† ' + winnerName, 'won King of the Pillar!');
      
      // Broadcast win event
      const winRef = push(ref(database, 'kotpWins'));
      set(winRef, {
        winnerId: winnerId,
        timestamp: Date.now()
      });

      // Reset circles
      resetKOTPGame();
    }

    function resetKOTPGame() {
      captureCircles.forEach(circle => {
        circle.progress = 0;
        circle.owner = null;
        circle.capturingPlayer = null;
        circle.playersInside.clear();
      });
      
      playerScores.clear();
      
      syncCaptureCircles();
      
      // Clean up scores
      remove(ref(database, 'playerScores'));
    }

    function updateCaptureProgressUI() {
      const progressDiv = document.getElementById('captureProgress');
      const labelDiv = document.getElementById('captureLabel');
      const fillDiv = document.getElementById('captureFill');
      
      // Check if player is in any circle
      let playerCircle = null;
      for (const circle of captureCircles) {
        if (circle.playersInside.has(myPlayerId)) {
          playerCircle = circle;
          break;
        }
      }
      
      if (!playerCircle || !isAlive) {
        progressDiv.classList.remove('active');
        return;
      }
      
      progressDiv.classList.add('active');
      
      const playersInCircle = Array.from(playerCircle.playersInside).filter(pid => {
        if (pid === myPlayerId) return isAlive;
        const p = remotePlayers[pid];
        return p && p.alive && p.lastUpdate && (Date.now() - p.lastUpdate) < 5000;
      });
      
      // Contested
      if (playersInCircle.length > 1) {
        labelDiv.textContent = 'CONTESTED!';
        fillDiv.className = 'capture-bar-fill contested';
        fillDiv.style.width = '100%';
      }
      // Decapturing
      else if (playerCircle.owner && playerCircle.owner !== myPlayerId) {
        labelDiv.textContent = 'Decapturing...';
        fillDiv.className = 'capture-bar-fill decapturing';
        fillDiv.style.width = (playerCircle.progress * 100) + '%';
      }
      // Capturing
      else if (!playerCircle.owner || playerCircle.owner === myPlayerId) {
        if (playerCircle.owner === myPlayerId) {
          labelDiv.textContent = 'Owned - Earning Points';
          fillDiv.className = 'capture-bar-fill capturing';
          fillDiv.style.width = '100%';
        } else {
          labelDiv.textContent = 'Capturing...';
          fillDiv.className = 'capture-bar-fill capturing';
          fillDiv.style.width = (playerCircle.progress * 100) + '%';
        }
      }
    }

    // Draw capture circles
    function drawCaptureCircles() {
      const circleVerts = [];
      
      captureCircles.forEach(circle => {
        const segments = 32;
        const y = 0.05; // Just above ground
        
        // Skip rendering if invalid data
        if (!circle || circle.x === undefined || circle.z === undefined) {
          return;
        }
        
        // Determine circle color based on state
        let color;
        if (circle.owner) {
          // Owned - use owner's color
          const ownerColor = circle.owner === myPlayerId ? myColor : 
                           (remotePlayers[circle.owner]?.color || [0.5, 0.5, 0.5]);
          color = ownerColor;
        } else if (circle.capturingPlayer) {
          // Being captured - yellow
          color = [1.0, 1.0, 0.0];
        } else {
          // Neutral - white
          color = [0.8, 0.8, 0.8];
        }

        // Validate color values
        if (!color || color.length !== 3 || color.some(c => isNaN(c) || c < 0 || c > 1)) {
          color = [0.8, 0.8, 0.8];
        }

        // Draw outer ring
        for (let i = 0; i < segments; i++) {
          const angle1 = (i / segments) * Math.PI * 2;
          const angle2 = ((i + 1) / segments) * Math.PI * 2;
          
          const x1 = circle.x + Math.cos(angle1) * CAPTURE_RADIUS;
          const z1 = circle.z + Math.sin(angle1) * CAPTURE_RADIUS;
          const x2 = circle.x + Math.cos(angle2) * CAPTURE_RADIUS;
          const z2 = circle.z + Math.sin(angle2) * CAPTURE_RADIUS;
          
          const x1Inner = circle.x + Math.cos(angle1) * (CAPTURE_RADIUS - 0.3);
          const z1Inner = circle.z + Math.sin(angle1) * (CAPTURE_RADIUS - 0.3);
          const x2Inner = circle.x + Math.cos(angle2) * (CAPTURE_RADIUS - 0.3);
          const z2Inner = circle.z + Math.sin(angle2) * (CAPTURE_RADIUS - 0.3);
          
          // Validate all coordinates before pushing
          if (isFinite(x1) && isFinite(z1) && isFinite(x2) && isFinite(z2) &&
              isFinite(x1Inner) && isFinite(z1Inner) && isFinite(x2Inner) && isFinite(z2Inner)) {
            
            // Outer edge triangle 1
            pushVertex(circleVerts, x1, y, z1, ...color);
            pushVertex(circleVerts, x2, y, z2, ...color);
            pushVertex(circleVerts, x1Inner, y, z1Inner, ...color);
            
            // Outer edge triangle 2
            pushVertex(circleVerts, x2, y, z2, ...color);
            pushVertex(circleVerts, x2Inner, y, z2Inner, ...color);
            pushVertex(circleVerts, x1Inner, y, z1Inner, ...color);
          }
        }

        // Draw progress indicator (inner filled circle)
        if (circle.progress !== undefined && Math.abs(circle.progress) > 0.01) {
          const progressRadius = CAPTURE_RADIUS * 0.6 * Math.abs(circle.progress);
          const progressColor = circle.progress > 0 ? color : [1.0, 0.3, 0.3]; // Red for decapture
          
          // Validate progressRadius
          if (isFinite(progressRadius) && progressRadius > 0) {
            for (let i = 0; i < segments; i++) {
              const angle1 = (i / segments) * Math.PI * 2;
              const angle2 = ((i + 1) / segments) * Math.PI * 2;
              
              const x1 = circle.x + Math.cos(angle1) * progressRadius;
              const z1 = circle.z + Math.sin(angle1) * progressRadius;
              const x2 = circle.x + Math.cos(angle2) * progressRadius;
              const z2 = circle.z + Math.sin(angle2) * progressRadius;
              
              // Validate coordinates
              if (isFinite(x1) && isFinite(z1) && isFinite(x2) && isFinite(z2) &&
                  isFinite(circle.x) && isFinite(circle.z)) {
                
                pushVertex(circleVerts, circle.x, y + 0.01, circle.z, ...progressColor);
                pushVertex(circleVerts, x1, y + 0.01, z1, ...progressColor);
                pushVertex(circleVerts, x2, y + 0.01, z2, ...progressColor);
              }
            }
          }
        }
      });

      if (circleVerts.length > 0) {
        gl.bindBuffer(gl.ARRAY_BUFFER, captureCircleBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(circleVerts), gl.DYNAMIC_DRAW);
        bindAttributes();
        gl.drawArrays(gl.TRIANGLES, 0, circleVerts.length / 6);
      }
    }

    // ====== Bottles ======
    const bottles = [];
    const glassColor = [0.6, 0.85, 1.0];

    (function createBottles() {
      const baseY = bottlePillarPos.h + 0.5;
      const sx = 0.4, sy = 1.0, sz = 0.4;

      bottles.push({
        pos: [bottlePillarPos.x - 0.6, baseY, bottlePillarPos.z],
        size: [sx, sy, sz],
        alive: true
      });
      bottles.push({
        pos: [bottlePillarPos.x, baseY, bottlePillarPos.z],
        size: [sx, sy, sz],
        alive: true
      });
      bottles.push({
        pos: [bottlePillarPos.x + 0.6, baseY, bottlePillarPos.z],
        size: [sx, sy, sz],
        alive: true
      });
    })();

    const bottleBuffer = gl.createBuffer();

    // ====== Grenade System ======
    const grenadePickups = [];
    const thrownGrenades = [];
    const grenadePickupBuffer = gl.createBuffer();
    const thrownGrenadeBuffer = gl.createBuffer();
    
    let myGrenadeCount = 0;
    const GRENADE_RESPAWN_TIME = 30000;
    const GRENADE_THROW_SPEED = 15.0;
    const GRENADE_FUSE_TIME = 2.0;
    const GRENADE_DAMAGE = 2;
    const GRENADE_RADIUS = 5.0;
    const PICKUP_RADIUS = 1.0;
    
    // Explosion effects
    const explosions = [];
    const explosionBuffer = gl.createBuffer();

    // Create grenade pickups around the map
    function initGrenadePickups() {
      grenadePickups.length = 0;
      
      const positions = [
        { x: -8, z: -15 },
        { x: 8, z: -15 },
        { x: -5, z: -25 },
        { x: 12, z: -28 }
      ];

      positions.forEach(pos => {
        grenadePickups.push({
          x: pos.x,
          y: 1.5,
          z: pos.z,
          available: true,
          respawnTime: 0
        });
      });

      console.log('Initialized grenade pickups:', grenadePickups);
      syncGrenadePickups();
    }

    function syncGrenadePickups() {
      const pickupsData = {};
      grenadePickups.forEach((pickup, idx) => {
        pickupsData[idx] = {
          available: pickup.available,
          respawnTime: pickup.respawnTime
        };
      });
      console.log('Syncing grenade pickups to Firebase:', pickupsData);
      set(ref(database, 'grenadePickups'), pickupsData);
    }

    function updateGrenadeDisplay() {
      document.getElementById('grenadeAmount').textContent = myGrenadeCount;
    }

    function checkGrenadePickup() {
      grenadePickups.forEach((pickup, idx) => {
        if (!pickup.available) return;

        const dx = camPos[0] - pickup.x;
        const dz = camPos[2] - pickup.z;
        const distSq = dx * dx + dz * dz;

        if (distSq < PICKUP_RADIUS * PICKUP_RADIUS && Math.abs(camPos[1] - pickup.y) < 1.5) {
          myGrenadeCount++;
          updateGrenadeDisplay();
          pickup.available = false;
          pickup.respawnTime = Date.now() + GRENADE_RESPAWN_TIME;
          
          set(ref(database, `grenadePickups/${idx}`), {
            available: false,
            respawnTime: pickup.respawnTime
          });

          playHitSound();
        }
      });
    }

    function throwGrenade() {
      if (myGrenadeCount <= 0 || !isAlive) return;

      const cosPitch = Math.cos(pitch);
      const sinPitch = Math.sin(pitch);
      const cosYaw = Math.cos(yaw);
      const sinYaw = Math.sin(yaw);

      const dir = [
        sinYaw * cosPitch,
        sinPitch,
        cosYaw * cosPitch
      ];

      const startPos = [
        camPos[0] + dir[0] * 1.0,
        camPos[1] + dir[1] * 1.0,
        camPos[2] + dir[2] * 1.0
      ];

      const grenade = {
        pos: [...startPos],
        vel: [
          dir[0] * GRENADE_THROW_SPEED,
          dir[1] * GRENADE_THROW_SPEED + 3.0,
          dir[2] * GRENADE_THROW_SPEED
        ],
        fuse: GRENADE_FUSE_TIME,
        ownerId: myPlayerId
      };

      thrownGrenades.push(grenade);
      myGrenadeCount--;
      updateGrenadeDisplay();

      const grenadeRef = push(ref(database, 'thrownGrenades'));
      set(grenadeRef, {
        playerId: myPlayerId,
        x: startPos[0],
        y: startPos[1],
        z: startPos[2],
        velX: grenade.vel[0],
        velY: grenade.vel[1],
        velZ: grenade.vel[2],
        timestamp: Date.now()
      });
    }

    function explodeGrenade(grenade) {
      // Create explosion visual effect
      explosions.push({
        pos: [grenade.pos[0], grenade.pos[1], grenade.pos[2]],
        radius: 0.5,
        maxRadius: GRENADE_RADIUS * 0.6,
        life: 0.5,
        maxLife: 0.5
      });
      
      // Check damage to all players including self
      const myDx = camPos[0] - grenade.pos[0];
      const myDy = camPos[1] - grenade.pos[1];
      const myDz = camPos[2] - grenade.pos[2];
      const myDistSq = myDx * myDx + myDy * myDy + myDz * myDz;

      if (myDistSq < GRENADE_RADIUS * GRENADE_RADIUS && isAlive) {
        const damageRef = push(ref(database, 'damage'));
        set(damageRef, {
          attackerId: grenade.ownerId,
          victimId: myPlayerId,
          damage: GRENADE_DAMAGE,
          direction: 'bottom',
          timestamp: Date.now()
        });
      }

      playGunshotSound();
    }
    
    function updateExplosions(dt) {
      for (let i = explosions.length - 1; i >= 0; i--) {
        const exp = explosions[i];
        exp.life -= dt;
        
        // Expand radius quickly
        const progress = 1 - (exp.life / exp.maxLife);
        exp.radius = exp.maxRadius * Math.min(progress * 3, 1);
        
        if (exp.life <= 0) {
          explosions.splice(i, 1);
        }
      }
    }

    function updateGrenadePickups(dt) {
      const now = Date.now();
      grenadePickups.forEach((pickup, idx) => {
        if (!pickup.available && pickup.respawnTime > 0 && now >= pickup.respawnTime) {
          pickup.available = true;
          pickup.respawnTime = 0;
          
          set(ref(database, `grenadePickups/${idx}`), {
            available: true,
            respawnTime: 0
          });
        }
      });
    }

    function updateThrownGrenades(dt) {
      for (let i = thrownGrenades.length - 1; i >= 0; i--) {
        const g = thrownGrenades[i];
        
        g.vel[1] -= gravity * dt;
        g.pos[0] += g.vel[0] * dt;
        g.pos[1] += g.vel[1] * dt;
        g.pos[2] += g.vel[2] * dt;

        if (g.pos[1] < 0.5) {
          g.pos[1] = 0.5;
          g.vel[1] = Math.abs(g.vel[1]) * 0.4;
          g.vel[0] *= 0.7;
          g.vel[2] *= 0.7;
        }

        g.fuse -= dt;
        if (g.fuse <= 0) {
          explodeGrenade(g);
          thrownGrenades.splice(i, 1);
        }
      }
    }

    // ====== Bullets & shards ======
    const bullets = [];
    const shards = [];
    const bulletBuffer = gl.createBuffer();
    const shardBuffer = gl.createBuffer();

    const BULLET_LIFETIME = 1.0;
    const BULLET_SPEED = 60.0;
    const SHARD_LIFETIME = 0.6;
    const SHARD_SPEED = 10.0;

    function spawnBullet(camPos, yaw, pitch) {
      const cosPitch = Math.cos(pitch);
      const sinPitch = Math.sin(pitch);
      const cosYaw = Math.cos(yaw);
      const sinYaw = Math.sin(yaw);

      const dir = [
        sinYaw * cosPitch,
        sinPitch,
        cosYaw * cosPitch
      ];

      const start = [
        camPos[0] + dir[0] * 0.5,
        camPos[1] + dir[1] * 0.5,
        camPos[2] + dir[2] * 0.5
      ];

      bullets.push({
        pos: start,
        dir: dir,
        life: BULLET_LIFETIME,
        ownerId: myPlayerId
      });

      playGunshotSound();

      const shotRef = push(ref(database, 'shots'));
      set(shotRef, {
        playerId: myPlayerId,
        x: start[0],
        y: start[1],
        z: start[2],
        dirX: dir[0],
        dirY: dir[1],
        dirZ: dir[2],
        timestamp: Date.now()
      });

      const gun = document.getElementById('gun');
      gun.classList.add('shoot-flash');
      setTimeout(() => gun.classList.remove('shoot-flash'), 100);
    }

    function spawnShards(bottle) {
      const [bx, by, bz] = bottle.pos;
      for (let i = 0; i < 12; i++) {
        const dx = (Math.random() - 0.5);
        const dy = Math.random();
        const dz = (Math.random() - 0.5);
        const len = Math.hypot(dx, dy, dz) || 1;
        shards.push({
          pos: [bx, by, bz],
          vel: [dx / len * SHARD_SPEED, dy / len * SHARD_SPEED, dz / len * SHARD_SPEED],
          life: SHARD_LIFETIME
        });
      }
    }

    // ====== Mat4 helpers ======
    function mat4Perspective(out, fovy, aspect, near, far) {
      const f = 1.0 / Math.tan(fovy / 2);
      const nf = 1 / (near - far);
      out[0] = f / aspect;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[5] = f;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[10] = (far + near) * nf;
      out[11] = -1;
      out[12] = 0;
      out[13] = 0;
      out[14] = (2 * far * near) * nf;
      out[15] = 0;
      return out;
    }

    function mat4LookAt(out, eye, center, up) {
      let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
      const eyex = eye[0], eyey = eye[1], eyez = eye[2];
      const upx = up[0], upy = up[1], upz = up[2];
      const centerx = center[0], centery = center[1], centerz = center[2];

      z0 = eyex - centerx;
      z1 = eyey - centery;
      z2 = eyez - centerz;

      len = Math.hypot(z0, z1, z2);
      if (len === 0) {
        z2 = 1;
      } else {
        z0 /= len; z1 /= len; z2 /= len;
      }

      x0 = upy * z2 - upz * z1;
      x1 = upz * z0 - upx * z2;
      x2 = upx * z1 - upy * z0;

      len = Math.hypot(x0, x1, x2);
      if (len === 0) {
        x0 = 1;
      } else {
        x0 /= len; x1 /= len; x2 /= len;
      }

      y0 = z1 * x2 - z2 * x1;
      y1 = z2 * x0 - z0 * x2;
      y2 = z0 * x1 - z1 * x0;

      len = Math.hypot(y0, y1, y2);
      if (len !== 0) {
        y0 /= len; y1 /= len; y2 /= len;
      }

      out[0] = x0;
      out[1] = y0;
      out[2] = z0;
      out[3] = 0;
      out[4] = x1;
      out[5] = y1;
      out[6] = z1;
      out[7] = 0;
      out[8] = x2;
      out[9] = y2;
      out[10] = z2;
      out[11] = 0;
      out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
      out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
      out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
      out[15] = 1;
      return out;
    }

    function mat4Multiply(out, a, b) {
      const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
      const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
      const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
      const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

      const b00 = b[0], b01 = b[1], b02 = b[2], b03 = b[3];
      const b10 = b[4], b11 = b[5], b12 = b[6], b13 = b[7];
      const b20 = b[8], b21 = b[9], b22 = b[10], b23 = b[11];
      const b30 = b[12], b31 = b[13], b32 = b[14], b33 = b[15];

      out[0]  = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
      out[1]  = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
      out[2]  = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
      out[3]  = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
      out[4]  = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
      out[5]  = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
      out[6]  = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
      out[7]  = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
      out[8]  = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
      out[9]  = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
      out[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
      out[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
      out[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
      out[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
      out[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
      out[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;
      return out;
    }

    // ====== First-person camera ======
    let camPos = [0, 2, 5];
    let yaw = 0;
    let pitch = 0;
    let velocityY = 0;
    let isGrounded = true;

    const move = {
      forward: false,
      backward: false,
      left: false,
      right: false
    };

    const moveSpeed = 15.0;
    const mouseSensitivity = 0.002;
    const jumpSpeed = 8.0;
    const gravity = 25.0;

    canvas.addEventListener("click", () => {
      canvas.requestPointerLock();
    });

    document.addEventListener("pointerlockchange", () => {
      const info = document.getElementById("info");
      if (document.pointerLockElement === canvas) {
        info.style.display = "none";
      } else {
        info.style.display = "block";
      }
    });

    document.addEventListener("mousemove", (e) => {
      if (document.pointerLockElement === canvas) {
        yaw   -= e.movementX * mouseSensitivity;
        pitch -= e.movementY * mouseSensitivity;
        const limit = Math.PI / 2 - 0.1;
        if (pitch > limit) pitch = limit;
        if (pitch < -limit) pitch = -limit;
      }
    });

    document.addEventListener("keydown", (e) => {
      switch (e.code) {
        case "KeyW":
        case "ArrowUp":
          move.forward = true; break;
        case "KeyS":
        case "ArrowDown":
          move.backward = true; break;
        case "KeyA":
        case "ArrowLeft":
          move.left = true; break;
        case "KeyD":
        case "ArrowRight":
          move.right = true; break;
        case "Space":
          if (isGrounded && isAlive) {
            velocityY = jumpSpeed;
            isGrounded = false;
          }
          break;
      }
    });

    document.addEventListener("keyup", (e) => {
      switch (e.code) {
        case "KeyW":
        case "ArrowUp":
          move.forward = false; break;
        case "KeyS":
        case "ArrowDown":
          move.backward = false; break;
        case "KeyA":
        case "ArrowLeft":
          move.left = false; break;
        case "KeyD":
        case "ArrowRight":
          move.right = false; break;
      }
    });

    document.addEventListener("mousedown", (e) => {
      if (document.pointerLockElement === canvas && isAlive) {
        if (e.button === 0) {
          spawnBullet(camPos, yaw, pitch);
        } else if (e.button === 2) {
          throwGrenade();
        }
      }
    });

    // ====== Collision ======
    function checkBulletBottleCollision(bullet) {
      const padding = 0.25;

      for (const bottle of bottles) {
        if (!bottle.alive) continue;

        const [bx, by, bz] = bottle.pos;
        const [sx, sy, sz] = bottle.size;

        const halfX = sx / 2 + padding;
        const halfY = sy / 2 + padding;
        const halfZ = sz / 2 + padding;

        if (Math.abs(bullet.pos[0] - bx) <= halfX &&
            Math.abs(bullet.pos[1] - by) <= halfY &&
            Math.abs(bullet.pos[2] - bz) <= halfZ) {
          bottle.alive = false;
          spawnShards(bottle);
          bullet.life = 0;
          return;
        }
      }
    }

    function checkBulletPlayerCollision(bullet) {
      if (!bullet.ownerId || bullet.ownerId === myPlayerId || !isAlive) return;

      const playerBottom = camPos[1] - 1.7;
      const playerTop = camPos[1] + 0.8;
      const playerRadius = 0.4;
      
      const bx = bullet.pos[0];
      const by = bullet.pos[1];
      const bz = bullet.pos[2];
      
      if (by < playerBottom || by > playerTop) {
        return;
      }
      
      const dx = bx - camPos[0];
      const dz = bz - camPos[2];
      const horizontalDistSq = dx * dx + dz * dz;
      
      if (horizontalDistSq < playerRadius * playerRadius) {
        const angle = Math.atan2(dx, dz);
        const myAngle = yaw;
        let relativeAngle = angle - myAngle;
        
        while (relativeAngle > Math.PI) relativeAngle -= Math.PI * 2;
        while (relativeAngle < -Math.PI) relativeAngle += Math.PI * 2;
        
        let direction = 'front';
        if (relativeAngle > Math.PI * 0.75 || relativeAngle < -Math.PI * 0.75) {
          direction = 'top';
        } else if (relativeAngle > Math.PI * 0.25) {
          direction = 'left';
        } else if (relativeAngle < -Math.PI * 0.25) {
          direction = 'right';
        } else {
          direction = 'bottom';
        }
        
        const damageRef = push(ref(database, 'damage'));
        set(damageRef, {
          attackerId: bullet.ownerId,
          victimId: myPlayerId,
          damage: 1,
          direction: direction,
          timestamp: Date.now()
        });
        
        bullet.life = 0;
      }
    }
    
    function showDamageIndicator(direction) {
      const indicator = document.querySelector(`.damage-indicator.${direction}`);
      const vignette = document.getElementById('vignette');
      
      if (indicator) {
        indicator.classList.add('active');
        vignette.classList.add('active');
        
        setTimeout(() => {
          indicator.classList.remove('active');
          vignette.classList.remove('active');
        }, 300);
      }
    }
    
    function showHitMarker() {
      const hitMarker = document.getElementById('hitMarker');
      hitMarker.classList.add('active');
      
      setTimeout(() => {
        hitMarker.classList.remove('active');
      }, 100);
    }

    // ====== Player Name Management ======
    const playerNames = new Map();

    async function getNextPlayerNumber() {
      return new Promise((resolve) => {
        onValue(ref(database, 'players'), (snapshot) => {
          const players = snapshot.val();
          let maxNumber = 0;
          
          if (players) {
            for (const id in players) {
              const p = players[id];
              if (p.name && p.name.startsWith('Player ')) {
                const num = parseInt(p.name.split(' ')[1]);
                if (!isNaN(num) && num > maxNumber) {
                  maxNumber = num;
                }
              }
            }
          }
          
          resolve(maxNumber + 1);
        }, { onlyOnce: true });
      });
    }

    function updatePlayerNamesCache(players) {
      playerNames.clear();
      if (players) {
        for (const id in players) {
          const p = players[id];
          if (p.name) {
            playerNames.set(id, p.name);
          }
        }
      }
    }

    // ====== Kill Feed Management ======
    const MAX_KILL_FEED_ENTRIES = 5;
    const KILL_FEED_DURATION = 5000;

    function addKillToFeed(killerName, victimName) {
      const killFeed = document.getElementById('killFeed');
      
      const entry = document.createElement('div');
      entry.className = 'kill-entry';
      entry.innerHTML = `
        <span class="killer">${killerName}</span>
        <span class="separator">â†’</span>
        <span class="victim">${victimName}</span>
      `;
      
      killFeed.insertBefore(entry, killFeed.firstChild);
      
      setTimeout(() => {
        if (entry.parentNode) {
          entry.remove();
        }
      }, KILL_FEED_DURATION);
      
      while (killFeed.children.length > MAX_KILL_FEED_ENTRIES) {
        killFeed.lastChild.remove();
      }
    }

    // ====== Canvas Text Rendering for Name Tags ======
    const nameTagOverlays = new Map();

    function updateNameTagOverlays() {
      nameTagOverlays.forEach((overlay, id) => {
        if (!remotePlayers[id] || !remotePlayers[id].x) {
          overlay.remove();
          nameTagOverlays.delete(id);
        }
      });

      const aspect = canvas.width / canvas.height;
      const proj = new Float32Array(16);
      mat4Perspective(proj, (60 * Math.PI) / 180, aspect, 0.1, 1000);

      const cosPitch = Math.cos(pitch);
      const sinPitch = Math.sin(pitch);
      const cosYaw = Math.cos(yaw);
      const sinYaw = Math.sin(yaw);

      const forward = [
        sinYaw * cosPitch,
        sinPitch,
        cosYaw * cosPitch
      ];

      const center = [
        camPos[0] + forward[0],
        camPos[1] + forward[1],
        camPos[2] + forward[2]
      ];

      const view = new Float32Array(16);
      mat4LookAt(view, camPos, center, [0, 1, 0]);

      const mvp = new Float32Array(16);
      mat4Multiply(mvp, proj, view);

      for (const id in remotePlayers) {
        const p = remotePlayers[id];
        if (p && p.x !== undefined) {
          const playerName = playerNames.get(id) || 'Player';
          const nameTagY = p.y + 1.2;

          const worldPos = [p.x, nameTagY, p.z, 1.0];
          const clipPos = [
            mvp[0] * worldPos[0] + mvp[4] * worldPos[1] + mvp[8] * worldPos[2] + mvp[12],
            mvp[1] * worldPos[0] + mvp[5] * worldPos[1] + mvp[9] * worldPos[2] + mvp[13],
            mvp[2] * worldPos[0] + mvp[6] * worldPos[1] + mvp[10] * worldPos[2] + mvp[14],
            mvp[3] * worldPos[0] + mvp[7] * worldPos[1] + mvp[11] * worldPos[2] + mvp[15]
          ];

          if (clipPos[3] > 0) {
            const ndcX = clipPos[0] / clipPos[3];
            const ndcY = clipPos[1] / clipPos[3];

            const screenX = (ndcX * 0.5 + 0.5) * canvas.width;
            const screenY = (1.0 - (ndcY * 0.5 + 0.5)) * canvas.height;

            let overlay = nameTagOverlays.get(id);
            if (!overlay) {
              overlay = document.createElement('div');
              overlay.style.position = 'absolute';
              overlay.style.pointerEvents = 'none';
              overlay.style.zIndex = '5';
              overlay.style.background = 'rgba(0, 0, 0, 0.7)';
              overlay.style.color = '#fff';
              overlay.style.padding = '4px 8px';
              overlay.style.borderRadius = '4px';
              overlay.style.fontSize = '14px';
              overlay.style.fontWeight = 'bold';
              overlay.style.whiteSpace = 'nowrap';
              overlay.style.transform = 'translate(-50%, -50%)';
              document.body.appendChild(overlay);
              nameTagOverlays.set(id, overlay);
            }

            overlay.textContent = playerName;
            overlay.style.left = `${screenX}px`;
            overlay.style.top = `${screenY}px`;
            overlay.style.display = 'block';
          } else {
            const overlay = nameTagOverlays.get(id);
            if (overlay) {
              overlay.style.display = 'none';
            }
          }
        }
      }
    }

    // ====== Firebase Multiplayer ======
    const myPlayerId = push(ref(database, 'players')).key;
    const myPlayerRef = ref(database, `players/${myPlayerId}`);
    const remotePlayers = {};
    const remotePlayerBuffer = gl.createBuffer();

    const myColor = [Math.random(), Math.random(), Math.random()];
    
    let myHealth = 8;
    const MAX_HEALTH = 8;
    let isAlive = true;
    let respawnTimer = null;
    const RESPAWN_TIME = 6;

    let myName = '';
    (async () => {
      const playerNumber = await getNextPlayerNumber();
      myName = `Player ${playerNumber}`;
      console.log('Assigned name:', myName);
      
      initGrenadePickups();
      initCaptureCircles();
      updateGrenadeDisplay();
      
      updateMyPosition();
    })();

    function updateHealthDisplay() {
      const healthDiv = document.getElementById('health');
      healthDiv.innerHTML = '';
      for (let i = 0; i < MAX_HEALTH; i++) {
        const heart = document.createElement('span');
        heart.className = i < myHealth ? 'heart' : 'heart lost';
        heart.textContent = 'â™¥';
        healthDiv.appendChild(heart);
      }
    }
    updateHealthDisplay();

    function handleDeath(killerId) {
      isAlive = false;
      canvas.classList.add('dead');
      document.getElementById('respawnOverlay').classList.add('active');
      
      if (killerId) {
        const killRef = push(ref(database, 'kills'));
        set(killRef, {
          attackerId: killerId,
          victimId: myPlayerId,
          timestamp: Date.now()
        });
      }
      
      let timeLeft = RESPAWN_TIME;
      document.getElementById('respawnTimer').textContent = timeLeft;
      
      respawnTimer = setInterval(() => {
        timeLeft--;
        document.getElementById('respawnTimer').textContent = timeLeft;
        
        if (timeLeft <= 0) {
          clearInterval(respawnTimer);
          respawn();
        }
      }, 1000);
    }

    function respawn() {
      myHealth = MAX_HEALTH;
      isAlive = true;
      updateHealthDisplay();
      
      camPos = [0, 2, 5];
      yaw = 0;
      pitch = 0;
      
      canvas.classList.remove('dead');
      document.getElementById('respawnOverlay').classList.remove('active');
      document.getElementById('respawnTimer').textContent = RESPAWN_TIME;
      
      updateMyPosition();
    }

    onDisconnect(myPlayerRef).remove();

    // Additional cleanup on page unload
    window.addEventListener('beforeunload', () => {
      // Remove player data immediately
      remove(myPlayerRef);
      
      // If we have any scores, clean them up too
      if (playerScores.has(myPlayerId)) {
        remove(ref(database, `playerScores/${myPlayerId}`));
      }
    });

    let lastUpdate = 0;
    const UPDATE_INTERVAL = 50;

    function updateMyPosition() {
      const now = Date.now();
      if (now - lastUpdate > UPDATE_INTERVAL && myName) {
        set(myPlayerRef, {
          x: camPos[0],
          y: camPos[1],
          z: camPos[2],
          yaw: yaw,
          pitch: pitch,
          color: myColor,
          ownerId: myPlayerId,
          health: myHealth,
          alive: isAlive,
          name: myName,
          lastUpdate: now
        });
        lastUpdate = now;
      }
    }

    onValue(ref(database, 'players'), (snapshot) => {
      const players = snapshot.val();
      const now = Date.now();
      
      updatePlayerNamesCache(players);
      
      for (const id in remotePlayers) {
        remotePlayers[id] = null;
      }

      let count = 0;
      if (players) {
        for (const id in players) {
          const p = players[id];
          
          if (id !== myPlayerId) {
            if (p.lastUpdate && (now - p.lastUpdate) < 5000) {
              remotePlayers[id] = p;
              count++;
            }
          }
        }
      }

      document.getElementById('playerCount').textContent = count + 1;
    });

    onValue(ref(database, 'grenadePickups'), (snapshot) => {
      const pickups = snapshot.val();
      console.log('Received grenade pickups from Firebase:', pickups);
      
      if (pickups) {
        if (grenadePickups.length === 0) {
          const positions = [
            { x: -8, z: -15 },
            { x: 8, z: -15 },
            { x: -5, z: -25 },
            { x: 12, z: -28 }
          ];
          
          Object.keys(pickups).forEach((idx) => {
            const i = parseInt(idx);
            if (positions[i]) {
              grenadePickups.push({
                x: positions[i].x,
                y: 1.5,
                z: positions[i].z,
                available: pickups[idx].available,
                respawnTime: pickups[idx].respawnTime || 0
              });
            }
          });
          console.log('Initialized local grenade pickups from Firebase:', grenadePickups);
        } else {
          Object.keys(pickups).forEach(idx => {
            const pickup = pickups[idx];
            if (grenadePickups[idx]) {
              grenadePickups[idx].available = pickup.available;
              grenadePickups[idx].respawnTime = pickup.respawnTime || 0;
            }
          });
        }
      }
    });

    onValue(ref(database, 'captureCircles'), (snapshot) => {
      const circles = snapshot.val();
      
      if (circles) {
        Object.keys(circles).forEach(id => {
          const circleId = parseInt(id);
          const remoteCircle = circles[id];
          const localCircle = captureCircles[circleId];
          
          if (localCircle) {
            // Update from remote if newer
            if (remoteCircle.lastUpdate > localCircle.lastUpdate) {
              localCircle.progress = remoteCircle.progress;
              localCircle.owner = remoteCircle.owner;
              localCircle.capturingPlayer = remoteCircle.capturingPlayer;
              localCircle.playersInside = new Set(remoteCircle.playersInside || []);
              localCircle.lastUpdate = remoteCircle.lastUpdate;
            }
          }
        });
      }
    });

    onValue(ref(database, 'playerScores'), (snapshot) => {
      const scores = snapshot.val();
      
      if (scores) {
        playerScores.clear();
        for (const playerId in scores) {
          if (scores[playerId].score !== undefined) {
            playerScores.set(playerId, scores[playerId].score);
          }
        }
      }
    });

    onValue(ref(database, 'kotpWins'), (snapshot) => {
      const wins = snapshot.val();
      const now = Date.now();
      
      if (wins) {
        for (const winId in wins) {
          const win = wins[winId];
          
          if (win.timestamp && (now - win.timestamp) < 2000) {
            const winnerName = playerNames.get(win.winnerId) || 'Unknown';
            addKillToFeed('ðŸ† ' + winnerName, 'won King of the Pillar!');
            
            // Clean up old win entries
            if ((now - win.timestamp) > 5000) {
              remove(ref(database, `kotpWins/${winId}`));
            }
          }
        }
      }
    });

    onValue(ref(database, 'thrownGrenades'), (snapshot) => {
      const grenades = snapshot.val();
      const now = Date.now();
      
      if (grenades) {
        for (const grenadeId in grenades) {
          const g = grenades[grenadeId];
          
          if (g.playerId !== myPlayerId && 
              g.timestamp && 
              (now - g.timestamp) < 500) {
            
            thrownGrenades.push({
              pos: [g.x, g.y, g.z],
              vel: [g.velX, g.velY, g.velZ],
              fuse: GRENADE_FUSE_TIME,
              ownerId: g.playerId
            });
          }
        }
      }
    });

    onValue(ref(database, 'shots'), (snapshot) => {
      const shots = snapshot.val();
      const now = Date.now();
      
      if (shots) {
        for (const shotId in shots) {
          const shot = shots[shotId];
          
          if (shot.playerId !== myPlayerId && 
              shot.timestamp && 
              (now - shot.timestamp) < 500) {
            
            bullets.push({
              pos: [shot.x, shot.y, shot.z],
              dir: [shot.dirX, shot.dirY, shot.dirZ],
              life: BULLET_LIFETIME,
              ownerId: shot.playerId
            });

            playGunshotSound();
          }
        }
      }
    });

    const processedDamage = new Set();
    const processedKills = new Set();

    onValue(ref(database, 'damage'), (snapshot) => {
      const damages = snapshot.val();
      const now = Date.now();
      
      if (damages) {
        for (const damageId in damages) {
          const dmg = damages[damageId];
          
          if (dmg.victimId === myPlayerId && 
              dmg.timestamp && 
              (now - dmg.timestamp) < 1000 &&
              !processedDamage.has(damageId)) {
            
            processedDamage.add(damageId);
            
            playHitSound();
            
            if (dmg.direction) {
              showDamageIndicator(dmg.direction);
            }
            
            const damageAmount = dmg.damage || 1;
            myHealth = Math.max(0, myHealth - damageAmount);
            updateHealthDisplay();
            
            console.log(`Took ${damageAmount} damage from ${dmg.attackerId}`);
            
            if (myHealth <= 0 && isAlive) {
              handleDeath(dmg.attackerId);
            }
          }
          
          if (dmg.attackerId === myPlayerId &&
              dmg.timestamp &&
              (now - dmg.timestamp) < 1000 &&
              !processedDamage.has(damageId)) {
            
            processedDamage.add(damageId);
            showHitMarker();
          }
        }
      }
    });

    onValue(ref(database, 'kills'), (snapshot) => {
      const kills = snapshot.val();
      const now = Date.now();
      
      if (kills) {
        for (const killId in kills) {
          const kill = kills[killId];
          
          if (kill.timestamp && 
              (now - kill.timestamp) < 2000 &&
              !processedKills.has(killId)) {
            
            processedKills.add(killId);
            
            const killerName = playerNames.get(kill.attackerId) || 'Unknown';
            const victimName = playerNames.get(kill.victimId) || 'Unknown';
            
            addKillToFeed(killerName, victimName);
          }
        }
      }
    });

    setInterval(() => {
      const shotsRef = ref(database, 'shots');
      onValue(shotsRef, (snapshot) => {
        const shots = snapshot.val();
        const now = Date.now();
        
        if (shots) {
          for (const shotId in shots) {
            const shot = shots[shotId];
            if (shot.timestamp && (now - shot.timestamp) > 1000) {
              remove(ref(database, `shots/${shotId}`));
            }
          }
        }
      }, { onlyOnce: true });

      const damageRef = ref(database, 'damage');
      onValue(damageRef, (snapshot) => {
        const damages = snapshot.val();
        const now = Date.now();
        
        if (damages) {
          for (const damageId in damages) {
            const dmg = damages[damageId];
            if (dmg.timestamp && (now - dmg.timestamp) > 1500) {
              remove(ref(database, `damage/${damageId}`));
            }
          }
        }
      }, { onlyOnce: true });

      const killsRef = ref(database, 'kills');
      onValue(killsRef, (snapshot) => {
        const kills = snapshot.val();
        const now = Date.now();
        
        if (kills) {
          for (const killId in kills) {
            const kill = kills[killId];
            if (kill.timestamp && (now - kill.timestamp) > 10000) {
              remove(ref(database, `kills/${killId}`));
            }
          }
        }
      }, { onlyOnce: true });

      const grenadesRef = ref(database, 'thrownGrenades');
      onValue(grenadesRef, (snapshot) => {
        const grenades = snapshot.val();
        const now = Date.now();
        
        if (grenades) {
          for (const grenadeId in grenades) {
            const g = grenades[grenadeId];
            if (g.timestamp && (now - g.timestamp) > 3000) {
              remove(ref(database, `thrownGrenades/${grenadeId}`));
            }
          }
        }
      }, { onlyOnce: true });
    }, 1000);

    let lastPlayerCount = 0;
    let isFirstPlayer = false;
    let cleanupTimer = null;
    
    onValue(ref(database, 'players'), (snapshot) => {
      const players = snapshot.val();
      const now = Date.now();
      
      let activeCount = 0;
      const stalePlayerIds = [];
      
      if (players) {
        for (const id in players) {
          const p = players[id];
          if (p.lastUpdate && (now - p.lastUpdate) < 5000) {
            activeCount++;
          } else {
            // Mark stale players for removal
            stalePlayerIds.push(id);
          }
        }
      }

      // Clean up stale players immediately
      stalePlayerIds.forEach(id => {
        remove(ref(database, `players/${id}`));
        console.log(`Removed stale player: ${id}`);
      });

      if (lastPlayerCount === 0 && activeCount === 1) {
        isFirstPlayer = true;
        console.log('I am the first player - initializing server state');
        
        // Complete cleanup of all game data
        remove(ref(database, 'shots'));
        remove(ref(database, 'damage'));
        remove(ref(database, 'kills'));
        remove(ref(database, 'thrownGrenades'));
        remove(ref(database, 'kotpWins'));
        remove(ref(database, 'playerScores'));
        remove(ref(database, 'grenadePickups')).then(() => {
          initGrenadePickups();
        });
        remove(ref(database, 'captureCircles')).then(() => {
          initCaptureCircles();
        });
      }

      // Schedule cleanup when last player leaves
      if (activeCount === 0 && lastPlayerCount > 0) {
        console.log('No active players - scheduling cleanup in 10 seconds...');
        
        // Clear any existing cleanup timer
        if (cleanupTimer) {
          clearTimeout(cleanupTimer);
        }
        
        // Wait 10 seconds to ensure player really left (not just a network hiccup)
        cleanupTimer = setTimeout(() => {
          // Double check there are still no players
          onValue(ref(database, 'players'), (checkSnapshot) => {
            const checkPlayers = checkSnapshot.val();
            let stillActive = 0;
            
            if (checkPlayers) {
              const checkNow = Date.now();
              for (const id in checkPlayers) {
                const p = checkPlayers[id];
                if (p.lastUpdate && (checkNow - p.lastUpdate) < 5000) {
                  stillActive++;
                }
              }
            }
            
            if (stillActive === 0) {
              console.log('Confirmed no players - cleaning up database');
              remove(ref(database, 'players'));
              remove(ref(database, 'shots'));
              remove(ref(database, 'damage'));
              remove(ref(database, 'kills'));
              remove(ref(database, 'thrownGrenades'));
              remove(ref(database, 'grenadePickups'));
              remove(ref(database, 'captureCircles'));
              remove(ref(database, 'playerScores'));
              remove(ref(database, 'kotpWins'));
            } else {
              console.log('Players rejoined - skipping cleanup');
            }
          }, { onlyOnce: true });
        }, 10000);
      }
      
      lastPlayerCount = activeCount;
    });

    // ====== Main loop ======
    let lastTime = performance.now();

    function render(now) {
      const dt = (now - lastTime) / 1000;
      lastTime = now;

      gl.clearColor(0.4, 0.6, 0.9, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      const cosPitch = Math.cos(pitch);
      const sinPitch = Math.sin(pitch);
      const cosYaw = Math.cos(yaw);
      const sinYaw = Math.sin(yaw);

      const forward = [
        sinYaw * cosPitch,
        sinPitch,
        cosYaw * cosPitch
      ];
      const right = [
        -cosYaw,
        0,
        sinYaw
      ];

      const speed = moveSpeed * dt;
      if (move.forward && isAlive) {
        camPos[0] += forward[0] * speed;
        camPos[2] += forward[2] * speed;
      }
      if (move.backward && isAlive) {
        camPos[0] -= forward[0] * speed;
        camPos[2] -= forward[2] * speed;
      }
      if (move.left && isAlive) {
        camPos[0] -= right[0] * speed;
        camPos[2] -= right[2] * speed;
      }
      if (move.right && isAlive) {
        camPos[0] += right[0] * speed;
        camPos[2] += right[2] * speed;
      }

      if (isAlive) {
        velocityY -= gravity * dt;
        camPos[1] += velocityY * dt;

        let groundHeight = 2;

        const pillarX = bottlePillarPos.x;
        const pillarZ = bottlePillarPos.z;
        const pillarH = bottlePillarPos.h;
        const pillarSize = 1.0;

        if (Math.abs(camPos[0] - pillarX) < pillarSize && 
            Math.abs(camPos[2] - pillarZ) < pillarSize) {
          groundHeight = pillarH + 2;
        }

        if (camPos[1] <= groundHeight) {
          camPos[1] = groundHeight;
          velocityY = 0;
          isGrounded = true;
        } else {
          isGrounded = false;
        }
      } else {
        camPos[1] = 2;
      }

      updateMyPosition();

      if (isAlive) {
        checkGrenadePickup();
        checkPlayerInCircles();
      }

      updateGrenadePickups(dt);
      updateThrownGrenades(dt);
      updateExplosions(dt);
      updateCaptureProgress(dt);
      updatePlayerScores(dt);
      updateCaptureProgressUI();

      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.life -= dt;
        b.pos[0] += b.dir[0] * BULLET_SPEED * dt;
        b.pos[1] += b.dir[1] * BULLET_SPEED * dt;
        b.pos[2] += b.dir[2] * BULLET_SPEED * dt;

        checkBulletBottleCollision(b);
        checkBulletPlayerCollision(b);

        if (b.life <= 0) bullets.splice(i, 1);
      }

      for (let i = shards.length - 1; i >= 0; i--) {
        const s = shards[i];
        s.life -= dt;
        s.pos[0] += s.vel[0] * dt;
        s.pos[1] += s.vel[1] * dt;
        s.pos[2] += s.vel[2] * dt;
        s.vel[1] -= 20 * dt;
        if (s.life <= 0) shards.splice(i, 1);
      }

      const aspect = canvas.width / canvas.height;
      const proj = new Float32Array(16);
      mat4Perspective(proj, (60 * Math.PI) / 180, aspect, 0.1, 1000);

      const center = [
        camPos[0] + forward[0],
        camPos[1] + forward[1],
        camPos[2] + forward[2]
      ];
      const view = new Float32Array(16);
      mat4LookAt(view, camPos, center, [0, 1, 0]);

      const mvp = new Float32Array(16);
      mat4Multiply(mvp, proj, view);
      gl.uniformMatrix4fv(uMatrixLoc, false, mvp);

      gl.bindBuffer(gl.ARRAY_BUFFER, worldVertexBuffer);
      bindAttributes();
      gl.drawArrays(gl.TRIANGLES, 0, worldVertices.length / 6);

      drawCaptureCircles();

      const liveBottles = bottles.filter(b => b.alive);
      if (liveBottles.length > 0) {
        const bottleVerts = [];
        for (const btl of liveBottles) {
          addBoxVertices(
            bottleVerts,
            btl.pos[0], btl.pos[1], btl.pos[2],
            btl.size[0], btl.size[1], btl.size[2],
            glassColor
          );
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, bottleBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(bottleVerts), gl.DYNAMIC_DRAW);
        bindAttributes();
        gl.drawArrays(gl.TRIANGLES, 0, bottleVerts.length / 6);
      }

      const remotePlayerVerts = [];
      
      for (const id in remotePlayers) {
        const p = remotePlayers[id];
        if (p && p.x !== undefined) {
          const playerColor = p.color || [1, 0, 0];
          addStickmanVertices(remotePlayerVerts, p.x, p.y - 1.3, p.z, p.yaw, playerColor);
        }
      }
      
      if (remotePlayerVerts.length > 0) {
        gl.bindBuffer(gl.ARRAY_BUFFER, remotePlayerBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(remotePlayerVerts), gl.DYNAMIC_DRAW);
        bindAttributes();
        gl.drawArrays(gl.TRIANGLES, 0, remotePlayerVerts.length / 6);
      }
      
      updateNameTagOverlays();

      if (grenadePickups.length > 0) {
        const grenadeVerts = [];
        const orangeColor = [1.0, 0.6, 0.0];
        
        for (const pickup of grenadePickups) {
          if (pickup.available) {
            addSphereVertices(grenadeVerts, pickup.x, pickup.y, pickup.z, 0.3, orangeColor, 10);
          }
        }
        
        if (grenadeVerts.length > 0) {
          gl.bindBuffer(gl.ARRAY_BUFFER, grenadePickupBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(grenadeVerts), gl.DYNAMIC_DRAW);
          bindAttributes();
          gl.drawArrays(gl.TRIANGLES, 0, grenadeVerts.length / 6);
        }
      }

      if (thrownGrenades.length > 0) {
        const thrownGrenadeVerts = [];
        const redColor = [1.0, 0.2, 0.0];
        
        for (const grenade of thrownGrenades) {
          addSphereVertices(thrownGrenadeVerts, grenade.pos[0], grenade.pos[1], grenade.pos[2], 0.2, redColor, 8);
        }
        
        if (thrownGrenadeVerts.length > 0) {
          gl.bindBuffer(gl.ARRAY_BUFFER, thrownGrenadeBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(thrownGrenadeVerts), gl.DYNAMIC_DRAW);
          bindAttributes();
          gl.drawArrays(gl.TRIANGLES, 0, thrownGrenadeVerts.length / 6);
        }
      }

      if (explosions.length > 0) {
        const explosionVerts = [];
        
        for (const exp of explosions) {
          const progress = 1 - (exp.life / exp.maxLife);
          
          const innerColor = [1.0, 0.9, 0.2];
          const midColor = [1.0, 0.4, 0.0];
          const outerColor = [0.8, 0.1, 0.0];
          
          addSphereVertices(explosionVerts, 
            exp.pos[0], exp.pos[1], exp.pos[2], 
            exp.radius * 0.4, innerColor, 8);
          
          addSphereVertices(explosionVerts, 
            exp.pos[0], exp.pos[1], exp.pos[2], 
            exp.radius * 0.7, midColor, 10);
          
          const fadeOuterColor = [
            outerColor[0] * (1 - progress * 0.5),
            outerColor[1] * (1 - progress * 0.5),
            outerColor[2] * (1 - progress * 0.5)
          ];
          addSphereVertices(explosionVerts, 
            exp.pos[0], exp.pos[1], exp.pos[2], 
            exp.radius, fadeOuterColor, 12);
        }
        
        if (explosionVerts.length > 0) {
          gl.bindBuffer(gl.ARRAY_BUFFER, explosionBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(explosionVerts), gl.DYNAMIC_DRAW);
          bindAttributes();
          gl.drawArrays(gl.TRIANGLES, 0, explosionVerts.length / 6);
        }
      }

      if (bullets.length > 0) {
        const bulletVerts = [];
        const bulletColor = [1.0, 1.0, 0.0];
        for (const b of bullets) {
          bulletVerts.push(b.pos[0], b.pos[1], b.pos[2], ...bulletColor);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, bulletBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(bulletVerts), gl.DYNAMIC_DRAW);
        bindAttributes();
        gl.drawArrays(gl.POINTS, 0, bullets.length);
      }

      if (shards.length > 0) {
        const shardVerts = [];
        for (const s of shards) {
          shardVerts.push(s.pos[0], s.pos[1], s.pos[2], ...glassColor);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, shardBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shardVerts), gl.DYNAMIC_DRAW);
        bindAttributes();
        gl.drawArrays(gl.POINTS, 0, shards.length);
      }

      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
  </script>
</body>
</html>