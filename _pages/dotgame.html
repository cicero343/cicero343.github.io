<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dotgame - Multiplayer Adventure</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: #1a2817;
            color: #e8f5e8;
            font-family: 'Courier New', monospace;
            background-image: 
                radial-gradient(circle at 25% 25%, #2d4a2a 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, #1f3a1c 0%, transparent 50%);
        }
        canvas {
            border: 3px solid #4a6b47;
            background-color: #0f1f0c;
            display: block;
            margin: 20px auto;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(74, 107, 71, 0.3);
            position: relative;
        }
        .info {
            text-align: center;
            margin: 10px;
        }
        .controls {
            text-align: center;
            margin: 20px;
            background-color: #2d4a2a;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #4a6b47;
        }
        .player-info {
            display: inline-block;
            margin: 0 20px;
            padding: 10px;
            background-color: #1f3a1c;
            border-radius: 5px;
            border: 1px solid #4a6b47;
        }
        .status {
            text-align: center;
            margin: 10px;
            font-size: 14px;
            color: #a8c5a8;
        }
        .hearts {
            display: inline-block;
            margin-left: 30px;
            font-size: 22px;
            line-height: 1.2;
            max-width: 320px;
            background-color: rgba(45, 74, 42, 0.8);
            padding: 8px 15px;
            border-radius: 15px;
            border: 2px solid #4a6b47;
            vertical-align: middle;
            word-wrap: break-word;
        }
        h1 {
            color: #9fd89f;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .inventory-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
        }
        .skills-panel {
            position: absolute;
            top: 50px;
            left: 50px;
            width: 200px;
            height: 400px;
            background-color: #2d4a2a;
            border: 3px solid #4a6b47;
            border-radius: 8px;
            padding: 15px;
            color: #e8f5e8;
            font-family: 'Courier New', monospace;
        }
        .inventory-panel {
            position: absolute;
            top: 50px;
            right: 50px;
            width: 300px;
            height: 280px;
            background-color: #2d4a2a;
            border: 3px solid #4a6b47;
            border-radius: 8px;
            padding: 15px;
            color: #e8f5e8;
            font-family: 'Courier New', monospace;
        }
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(5, 40px);
            grid-template-rows: repeat(4, 40px);
            gap: 2px;
            margin-top: 10px;
        }
        .inventory-slot {
            width: 40px;
            height: 40px;
            background-color: #1f3a1c;
            border: 2px solid #4a6b47;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            position: relative;
        }
        .inventory-slot.selected {
            border-color: #9fd89f;
            background-color: #3a5a37;
        }
        .inventory-slot.equipped {
            border-color: #ffd700;
            background-color: #5a5a37;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }
        .inventory-slot.occupied {
            background-color: #4a6b47;
        }
        .item-description {
            position: absolute;
            bottom: 15px;
            right: 50px;
            width: 300px;
            height: 80px;
            background-color: #2d4a2a;
            border: 3px solid #4a6b47;
            border-radius: 8px;
            padding: 15px;
            color: #e8f5e8;
            font-family: 'Courier New', monospace;
        }
        .skill-line {
            margin: 8px 0;
            font-size: 14px;
        }
        .skill-name {
            display: inline-block;
            width: 110px;
        }
        .item-stack {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 10px;
            color: #ffd700;
            font-weight: bold;
        }
        .quick-chat-overlay {
            position: absolute;
            width: 280px;
            background-color: rgba(45, 74, 42, 0.95);
            border: 2px solid #4a6b47;
            border-radius: 6px;
            padding: 10px;
            color: #e8f5e8;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            display: none;
            /* Position at bottom left of canvas */
            bottom: 20px;
            left: 20px;
        }
        .quick-chat-header {
            text-align: center;
            color: #9fd89f;
            margin: 0 0 8px 0;
            font-weight: bold;
            font-size: 12px;
        }
        .quick-chat-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 3px;
            margin-bottom: 8px;
        }
        .quick-chat-message {
            padding: 6px 2px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            border: 1px solid transparent;
            text-align: center;
            background-color: rgba(31, 58, 28, 0.8);
        }
        .quick-chat-message.selected {
            background-color: #3a5a37;
            border-color: #9fd89f;
        }
        .quick-chat-message:hover {
            background-color: #2d4a2a;
        }
        .quick-chat-instructions {
            text-align: center;
            font-size: 9px;
            color: #a8c5a8;
        }
        
        /* Game layout container - keeps canvas centered */
        .game-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        /* Quest Panel - positioned as overlay to the right of screen */
        .quest-panel {
            position: fixed;
            top: 300px;
            right: 20px;
            width: 200px;
            background-color: rgba(45, 74, 42, 0.95);
            border: 3px solid #4a6b47;
            border-radius: 8px;
            padding: 12px;
            color: #e8f5e8;
            font-family: 'Courier New', monospace;
            display: none;
            max-height: 350px;
            overflow-y: auto;
            z-index: 100;
        }
        
        .quest-panel h3 {
            margin: 0 0 12px 0;
            text-align: center;
            color: #9fd89f;
            font-size: 16px;
        }
        
        .quest-item {
            background-color: rgba(31, 58, 28, 0.8);
            border: 2px solid #4a6b47;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
        }
        
        .quest-title {
            color: #e8f5e8;
            font-weight: bold;
            font-size: 13px;
            margin-bottom: 6px;
        }
        
        .quest-description {
            color: #a8c5a8;
            font-size: 10px;
            line-height: 1.3;
        }

        /* Canvas wrapper for relative positioning */
        .canvas-wrapper {
            position: relative;
        }
    </style>
</head>
<body>
    <div class="info">
        <div style="display: flex; align-items: center; justify-content: center; gap: 15px;">
            <a href="https://cicero343.github.io" style="text-decoration: none;">
                <img src="https://avatars.githubusercontent.com/u/175522457?v=4" alt="Logo" style="width: 60px; height: 60px; border-radius: 50%; cursor: pointer; border: 3px solid #9fd89f; transition: border-color 0.3s ease;">
            </a>
            <h1 style="margin: 0;">üå≤ Dotgame - Multiplayer Adventure üî•</h1>
        </div>
        <p>Go fishing ‚Ä¢ Cook ‚Ä¢ Craft fires ‚Ä¢ Hunt mobs ‚Ä¢ Quickchat with friends!</p>
    </div>

    <div class="controls">
        <div class="player-info">
            <strong>Your Character:</strong> <span id="playerColor">‚óè</span>
            <br><strong>WASD:</strong> Move | <strong>SPACE:</strong> Fireball | <strong>F:</strong> Melee | <strong>R:</strong> Shield | <strong>E:</strong> Interact
        </div>
        <div class="player-info">
            <strong>Health:</strong> <span id="healthDisplay">4/4</span>
            <br><strong>I:</strong> Inventory | <strong>Q:</strong> Quick Chat | <strong>ESC:</strong> Close
        </div>
        <div class="player-info">
            <strong>Zone:</strong> <span id="zoneDisplay">Town</span>
            <br><strong>Gold:</strong> <span id="goldDisplay">0</span> üí∞
        </div>
        <div class="player-info">
            <strong>Music:</strong> <span id="musicToggle" style="cursor: pointer; user-select: none;">üîä ON</span>
            <br><strong>M:</strong> Toggle Music
        </div>
    </div>

    <div class="game-container">
        <div class="canvas-wrapper">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            
            <!-- Quick Chat Overlay positioned within canvas area -->
            <div class="quick-chat-overlay" id="quickChatOverlay">
                <div class="quick-chat-header">Quick Chat</div>
                <div class="quick-chat-grid">
                    <div class="quick-chat-message selected" data-index="0"><strong>Hi!</strong></div>
                    <div class="quick-chat-message" data-index="1"><strong>Bye!</strong></div>
                    <div class="quick-chat-message" data-index="2"><strong>Thanks!</strong></div>
                    <div class="quick-chat-message" data-index="3"><strong>Sorry!</strong></div>
                    <div class="quick-chat-message" data-index="4"><strong>LOL</strong></div>
                    <div class="quick-chat-message" data-index="5"><strong>Let's go!</strong></div>
                    <div class="quick-chat-message" data-index="6"><strong>Stop!</strong></div>
                    <div class="quick-chat-message" data-index="7"><strong>Help!</strong></div>
                    <div class="quick-chat-message" data-index="8"><strong>Attack!</strong></div>
                    <div class="quick-chat-message" data-index="9"><strong>Nice!</strong></div>
                </div>
                <div class="quick-chat-instructions">Q: Cycle | ENTER: Send | WASD: Cancel</div>
            </div>
            
            <!-- Inventory Overlay inside canvas area -->
            <div class="inventory-overlay" id="inventoryOverlay">
                <div class="skills-panel">
                    <h3 style="margin: 0 0 15px 0; text-align: center; color: #9fd89f;">Skills</h3>
                    <div class="skill-line"><span class="skill-name">Level</span><span id="playerLevel">1</span></div>
                    <div class="skill-line"><span class="skill-name">Life</span><span id="playerLife">4/4</span></div>
                    <div class="skill-line"><span class="skill-name">Magic</span><span id="playerMagic">1</span></div>
                    <div class="skill-line"><span class="skill-name">Attack</span><span id="playerAttack">1</span></div>
                    <div class="skill-line"><span class="skill-name">Fishing</span><span id="playerFishing">1</span></div>
                    <div class="skill-line"><span class="skill-name">Cooking</span><span id="playerCooking">1</span></div>
                    <div class="skill-line"><span class="skill-name">Woodcutting</span><span id="playerWoodcutting">1</span></div>
                    <div class="skill-line"><span class="skill-name">EXP</span><span id="playerEXP">0</span></div>
                    <div class="skill-line"><span class="skill-name">Gold</span><span id="playerGoldInv">0</span></div>
                </div>
                
                <div class="inventory-panel">
                    <h3 style="margin: 0 0 10px 0; text-align: center; color: #9fd89f;">Inventory</h3>
                    <p style="margin: 0 0 10px 0; font-size: 12px; color: #a8c5a8; text-align: center;">Press SPACE/ENTER to equip or use items</p>
                    <div class="inventory-grid" id="inventoryGrid">
                        <!-- 20 inventory slots will be generated here -->
                    </div>
                </div>
                
                <div class="item-description" id="itemDescription">
                    <h4 style="margin: 0 0 10px 0; color: #9fd89f;">[Empty Slot]</h4>
                    <p style="margin: 0; font-size: 12px;">Select an item to view its description.</p>
                </div>
            </div>
        </div>

        <!-- Quest Panel - positioned as fixed overlay to the right of screen -->
        <div class="quest-panel" id="questPanel">
            <h3>Active Quests</h3>
            <div id="questList">
                <!-- Quests will be dynamically added here -->
            </div>
        </div>
    </div>

    <div class="status">
        <div style="display: inline-block;">Connected Adventurers: <span id="playerCount">0</span></div>
        <div class="hearts" id="hearts">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
        <div class="hearts" id="manaHearts" style="margin-left: 15px;">üíôüíôüíô</div>
        <div style="display: inline-block; margin-left: 30px;">Position: <span id="gridPos">10, 7</span></div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
        import { getDatabase, ref, set, onValue, onDisconnect, serverTimestamp, remove } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyC4TEgmhq4vCdb6lty0XwXObx21MEGzELo",
            authDomain: "dot-multiplayer-game.firebaseapp.com",
            databaseURL: "https://dot-multiplayer-game-default-rtdb.firebaseio.com",
            projectId: "dot-multiplayer-game",
            storageBucket: "dot-multiplayer-game.firebasestorage.app",
            messagingSenderId: "155804791894",
            appId: "1:155804791894:web:75c96073046a40ed8bb7f7",
            measurementId: "G-WC2Q2PRTGV"
        };

        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const GRID_SIZE = 40;
        const GRID_WIDTH = Math.floor(canvas.width / GRID_SIZE);
        const GRID_HEIGHT = Math.floor(canvas.height / GRID_SIZE);
        
        // Damage scaling constants (easy to adjust later)
        const ATTACK_DAMAGE_THRESHOLD = 20; // Level at which sword damage increases
        const MAGIC_DAMAGE_THRESHOLD = 20; // Level at which fireball damage increases
        const BASE_DAMAGE = 1;
        const ENHANCED_DAMAGE = 2;

        const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b', '#eb4d4b', '#6c5ce7', '#a29bfe'];
        
        let playerId = null;
        let playerNumber = 1;
        let players = {};
        let fireballs = {};
        let mobs = {};
        let drops = {};
        let myColor = '';
        let myGridPos = { x: 10, y: 7 };
        let myHealth = 4;
        let myMana = 3; // Starting mana
        let myMaxMana = 3; // Max mana
        let myGold = 0;
        let myDirection = 'right';
        let myZone = 1;
        // Zone IDs: 1=Town, 2=Farm, 3=Lake, 4=Forest, 5=Cave
        let showDialog = false;
        let dialogText = '';
        let isRespawning = false;
        let isPlayerCreated = false;

        // Typewriter effect variables
        let displayedText = '';
        let charIndex = 0;
        let lastCharTime = 0;
        const typewriterSpeed = 30; // ms per character (lower = faster)
        let isTypewriterActive = false;
        let typewriterJustSkipped = false; // NEW: Prevents double-action on ENTER

        // Music system variables
        let currentMusicTrack = null;
        let musicVolume = 0.2; // Adjust volume (0.0 to 1.0)
        let isMusicEnabled = true;
        
        // Music track URLs - update these paths to match your hosting
        const musicTracks = {
            1: 'assets/music/town.mp3',    // Town Zone
            2: 'assets/music/town.mp3',    // Farm Zone uses same file as Town Zone
            3: 'assets/music/lake.mp3',    // Lake Zone
            4: 'assets/music/forest.mp3'   // Forest Zone
        };
        
        // Quick chat system
        let showQuickChat = false;
        let selectedChatMessage = 0;
        let playerMessages = {}; // Store player chat messages
        const chatMessages = [
            'Hi!', 'Bye!', 'Thanks!', 'Sorry!', 'LOL',
            'Let\'s go!', 'Stop!', 'Help!', 'Attack!', 'Nice!'
        ];
        
        // Inventory, skills, and equipment system
        let showInventory = false;
        let selectedInventorySlot = 0;
        let playerLevel = 1;
        let playerEXP = 0;
        let playerMagic = 1;
        let playerAttack = 1;
        let playerFishing = 1;
        let playerCooking = 1;
        let playerWoodcutting = 1;
        let inventory = new Array(20).fill(null);
        let equippedWeapon = null;
        let equippedTool = null;
        let equippedShield = null; // NEW: Track equipped shield
        
        // Sound system variables
        let audioContext = null;
        let soundEnabled = true;

        // Initialize audio context (call this once during game initialization)
        function initializeAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                console.log('Audio system initialized');
            } catch (error) {
                console.log('Web Audio API not supported:', error);
                soundEnabled = false;
            }
        }

        // Generate woodcutting/chopping sound effect
        function playChoppingSound() {
            if (!soundEnabled || !audioContext) return;
            
            // Resume audio context if suspended (browser autoplay policy)
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            // Create oscillator for the chopping sound
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            // Connect: oscillator -> gainNode -> speakers
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Configure the chopping sound (sharp attack, quick decay)
            oscillator.frequency.setValueAtTime(150, audioContext.currentTime); // Low thump
            oscillator.frequency.linearRampToValueAtTime(80, audioContext.currentTime + 0.05); // Quick drop
            
            // Volume envelope (sharp attack, quick fade)
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.01); // Quick attack
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15); // Quick decay
            
            // Use square wave for woody sound
            oscillator.type = 'square';
            
            // Play for 150ms
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.15);
        }

        // Generate sword hit/impact sound effect
        function playSwordStabSound() {
            if (!soundEnabled || !audioContext) return;
            
            // Resume audio context if suspended (browser autoplay policy)
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            try {
                // Create noise-based impact sound (more realistic hit sound)
                const bufferSize = audioContext.sampleRate * 0.1; // 100ms of audio
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const output = buffer.getChannelData(0);
                
                // Generate white noise burst for impact
                for (let i = 0; i < bufferSize; i++) {
                    // Create decaying noise burst
                    const decay = Math.exp(-i / (bufferSize * 0.1)); // Quick decay
                    output[i] = (Math.random() * 2 - 1) * decay * 0.3;
                }
                
                // Create buffer source
                const noiseSource = audioContext.createBufferSource();
                const gainNode = audioContext.createGain();
                const filterNode = audioContext.createBiquadFilter();
                
                // Connect: noise -> filter -> gain -> speakers
                noiseSource.connect(filterNode);
                filterNode.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Configure filter to shape the hit sound
                filterNode.type = 'highpass';
                filterNode.frequency.setValueAtTime(800, audioContext.currentTime); // Remove muddy low frequencies
                filterNode.Q.setValueAtTime(0.5, audioContext.currentTime);
                
                // Volume envelope - sharp impact with quick fade
                const now = audioContext.currentTime;
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(0.6, now + 0.001); // Very sharp attack
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.08); // Quick fade
                
                // Play the noise burst
                noiseSource.buffer = buffer;
                noiseSource.start(now);
                noiseSource.stop(now + 0.1);
                
                console.log('Sword hit played'); // Debug log
                
            } catch (error) {
                console.error('Error playing sword hit sound:', error);
                
                // Fallback to simple click if noise generation fails
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(1500, audioContext.currentTime);
                oscillator.type = 'square';
                
                const now = audioContext.currentTime;
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(0.35, now + 0.001);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.03);
                
                oscillator.start(now);
                oscillator.stop(now + 0.03);
            }
        }

        // Generate cooking fire crackling sound effect (improved crackling)
        function playCookingSound() {
            if (!soundEnabled || !audioContext) return;
            
            // Resume audio context if suspended (browser autoplay policy)
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            try {
                // Create more realistic crackling fire sound
                const bufferSize = audioContext.sampleRate * 0.25; // 250ms
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const output = buffer.getChannelData(0);
                
                // Generate more realistic crackling pattern
                for (let i = 0; i < bufferSize; i++) {
                    // Create multiple layers of crackling at different frequencies
                    const time = i / audioContext.sampleRate;
                    
                    // Multiple random pops at different intervals for realistic crackling
                    const pop1 = Math.random() > 0.98 ? (Math.random() - 0.5) * 0.8 : 0; // Sharp pops
                    const pop2 = Math.random() > 0.96 ? (Math.random() - 0.5) * 0.4 : 0; // Medium pops  
                    const pop3 = Math.random() > 0.92 ? (Math.random() - 0.5) * 0.2 : 0; // Small pops
                    
                    // Continuous low-level crackling background
                    const baseCrackle = (Math.random() - 0.5) * 0.1 * Math.sin(time * 2000 + Math.random());
                    
                    // Gentle overall decay
                    const decay = Math.exp(-time * 2); // Slower decay for more crackling time
                    
                    output[i] = (pop1 + pop2 + pop3 + baseCrackle) * decay;
                }
                
                // Create audio nodes
                const noiseSource = audioContext.createBufferSource();
                const gainNode = audioContext.createGain();
                const filterNode = audioContext.createBiquadFilter();
                
                // Connect: noise -> filter -> gain -> speakers
                noiseSource.connect(filterNode);
                filterNode.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Configure filter for realistic fire crackling
                filterNode.type = 'highpass';  // Changed to highpass to remove muddy low end
                filterNode.frequency.setValueAtTime(300, audioContext.currentTime); // Remove very low frequencies
                filterNode.Q.setValueAtTime(0.7, audioContext.currentTime); // Gentle slope
                
                // Volume envelope - much louder and more gradual (less "slap-like")
                const now = audioContext.currentTime;
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(0.7, now + 0.01); // Much louder (0.7) and gentler attack
                gainNode.gain.linearRampToValueAtTime(0.6, now + 0.1); // Sustain the crackling
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.25); // Gentle fade
                
                // Play the crackling sound
                noiseSource.buffer = buffer;
                noiseSource.start(now);
                noiseSource.stop(now + 0.25);
                
                console.log('Cooking crackling played');
                
            } catch (error) {
                console.error('Error playing cooking sound:', error);
            }
        }

        // Generate fireball blast sound effect (subtle, less intrusive)
        function playFireballSound() {
            if (!soundEnabled || !audioContext) return;
            
            // Resume audio context if suspended (browser autoplay policy)
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            try {
                // Create subtle whoosh sound
                const bufferSize = audioContext.sampleRate * 0.4; // Shorter 400ms
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const output = buffer.getChannelData(0);
                
                // Generate smooth whooshing noise
                for (let i = 0; i < bufferSize; i++) {
                    const time = i / audioContext.sampleRate;
                    
                    // Gentler envelope
                    const envelope = Math.min(time * 12, 1) * Math.exp(-time * 4);
                    
                    // Softer noise
                    const noise = (Math.random() * 2 - 1) * envelope;
                    
                    output[i] = noise;
                }
                
                // Create audio nodes for the whoosh
                const noiseSource = audioContext.createBufferSource();
                const noiseGain = audioContext.createGain();
                const noiseFilter = audioContext.createBiquadFilter();
                
                // Connect: noise -> filter -> gain -> speakers
                noiseSource.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(audioContext.destination);
                
                // Bandpass filter for balanced sound
                noiseFilter.type = 'bandpass';
                noiseFilter.frequency.setValueAtTime(400, audioContext.currentTime); // Slightly higher for less bass-heavy
                noiseFilter.Q.setValueAtTime(1, audioContext.currentTime);
                
                // Create softer bass rumble with varying pitch to avoid "note" feeling
                const rumble = audioContext.createOscillator();
                const rumbleGain = audioContext.createGain();
                
                rumble.connect(rumbleGain);
                rumbleGain.connect(audioContext.destination);
                
                // Configure subtle varying bass (avoids single-note feeling)
                rumble.type = 'sine'; // Back to sine for softer bass
                rumble.frequency.setValueAtTime(100, audioContext.currentTime); // Start higher
                rumble.frequency.exponentialRampToValueAtTime(60, audioContext.currentTime + 0.15); // Quick drop
                rumble.frequency.exponentialRampToValueAtTime(80, audioContext.currentTime + 0.3); // Slight rise for variation
                
                const now = audioContext.currentTime;
                
                // Whoosh envelope - reduced volume
                noiseGain.gain.setValueAtTime(0, now);
                noiseGain.gain.linearRampToValueAtTime(0.3, now + 0.06); // Reduced from 0.5 to 0.3
                noiseGain.gain.linearRampToValueAtTime(0.25, now + 0.15); // Sustain lower
                noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.4); // Quicker fade
                
                // Bass rumble envelope - much softer and less prominent
                rumbleGain.gain.setValueAtTime(0, now);
                rumbleGain.gain.linearRampToValueAtTime(0.2, now + 0.04); // Much softer (was 0.5)
                rumbleGain.gain.linearRampToValueAtTime(0.15, now + 0.15); // Lower sustain
                rumbleGain.gain.exponentialRampToValueAtTime(0.01, now + 0.3); // Quicker fade
                
                // Play both sounds simultaneously
                noiseSource.buffer = buffer;
                noiseSource.start(now);
                noiseSource.stop(now + 0.4);
                
                rumble.start(now);
                rumble.stop(now + 0.3);
                
                console.log('Fireball whoosh played');
                
            } catch (error) {
                console.error('Error playing fireball sound:', error);
            }
        }

        // Generate water trickling/bubbling sound effect
        function playFishingSound() {
            if (!soundEnabled || !audioContext) return;
            
            // Resume audio context if suspended (browser autoplay policy)
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            try {
                // Create longer water trickling sound
                const bufferSize = audioContext.sampleRate * 0.6; // Longer 600ms for drawn-out effect
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const output = buffer.getChannelData(0);
                
                // Generate water trickling with bubbles
                for (let i = 0; i < bufferSize; i++) {
                    const time = i / audioContext.sampleRate;
                    
                    // Multiple bubble frequencies for realistic water
                    const bubble1 = Math.sin(time * 300 + Math.random() * 2) * 0.3;
                    const bubble2 = Math.sin(time * 500 + Math.random() * 3) * 0.2;
                    const bubble3 = Math.sin(time * 700 + Math.random() * 4) * 0.15;
                    
                    // Random pops/splashes for water texture
                    const splash = Math.random() > 0.97 ? (Math.random() - 0.5) * 0.4 : 0;
                    
                    // Continuous noise for water texture
                    const waterNoise = (Math.random() * 2 - 1) * 0.2;
                    
                    // Gentle envelope - sustained throughout
                    const envelope = Math.min(time * 8, 1) * Math.exp(-time * 2);
                    
                    output[i] = (bubble1 + bubble2 + bubble3 + splash + waterNoise) * envelope;
                }
                
                // Create audio nodes
                const noiseSource = audioContext.createBufferSource();
                const noiseGain = audioContext.createGain();
                const noiseFilter = audioContext.createBiquadFilter();
                
                // Connect: noise -> filter -> gain -> speakers
                noiseSource.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(audioContext.destination);
                
                // Bandpass filter to keep mid-range bubbling frequencies
                noiseFilter.type = 'bandpass';
                noiseFilter.frequency.setValueAtTime(500, audioContext.currentTime); // Mid-range for bubbles
                noiseFilter.Q.setValueAtTime(1.2, audioContext.currentTime); // Focused on bubble frequencies
                
                const now = audioContext.currentTime;
                
                // Much louder and more sustained volume envelope
                noiseGain.gain.setValueAtTime(0, now);
                noiseGain.gain.linearRampToValueAtTime(0.4, now + 0.05); // Much louder (0.4 vs 0.15)
                noiseGain.gain.linearRampToValueAtTime(0.35, now + 0.3); // Sustained throughout
                noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.6); // Longer fade
                
                // Play the water trickling
                noiseSource.buffer = buffer;
                noiseSource.start(now);
                noiseSource.stop(now + 0.6);
                
                console.log('Water trickling played');
                
            } catch (error) {
                console.error('Error playing fishing sound:', error);
            }
        }

        // Load and play zone music
        function playZoneMusic(zoneId) {
            if (!isMusicEnabled) return;
            
            const trackUrl = musicTracks[zoneId];
            if (!trackUrl) {
                console.log('No music track for zone', zoneId);
                return;
            }

            // üéµ NEW: Check if we're already playing this track
            if (currentMusicTrack && currentMusicTrack.src.includes(trackUrl)) {
                console.log(`Already playing music for zone ${zoneId}, continuing...`);
                return; // Don't restart the same track
            }
            
            // Stop current track if playing a different one
            if (currentMusicTrack) {
                currentMusicTrack.pause();
                currentMusicTrack.currentTime = 0;
            }
            
            // Create new audio element
            currentMusicTrack = new Audio(trackUrl);
            currentMusicTrack.loop = true; // Loop the music
            currentMusicTrack.volume = musicVolume;
            
            // Play the music
            currentMusicTrack.play().catch(error => {
                console.log('Music playback failed:', error);
                // Browser may block autoplay - user interaction required
            });
            
            console.log(`Playing music for zone ${zoneId}`);
        }
        
        // Stop zone music
        function stopZoneMusic() {
            if (currentMusicTrack) {
                currentMusicTrack.pause();
                currentMusicTrack.currentTime = 0;
                currentMusicTrack = null;
            }
        }

        // Fishing system
        let isFishing = false;
        let fishingStartTime = 0;
        let nextFishTime = 0;
        
        // Cooking system
        let isCooking = false;
        let cookingStartTime = 0;
        let nextCookTime = 0;
        let showCookingDialog = false;
        let selectedCookingOption = 0;
        let cookingOptions = [];
        
        // Woodcutting system
        let isWoodcutting = false;
        let woodcuttingStartTime = 0;
        let nextWoodcutTime = 0;
        let showWoodcuttingDialog = false;
        let selectedWoodcuttingOption = 0; // 0 = Yes, 1 = No
        let currentTree = null;
        
        // Level up popup variables
        let showLevelUpPopup = false;
        let levelUpPopupTimer = 0;
        let newLevel = 1;
        
        // Fish catch popup variables
        let showFishCatchPopup = false;
        let fishCatchPopupTimer = 0;
        
        // Cooking popup variables
        let showCookingPopup = false;
        let cookingPopupTimer = 0;
        let cookedItemName = '';
        
        // Woodcutting popup variables
        let showWoodcuttingPopup = false;
        let woodcuttingPopupTimer = 0;
        
        // Melee attack system
        let isAttacking = false;
        let attackStartTime = 0;
        let attackDuration = 300; // Attack animation lasts 300ms
        let attackComboCount = 0; // Tracks which attack in combo (0, 1, or 2)
        let lastAttackTime = 0; // Track time of last attack for combo reset
        const comboResetTime = 1000; // Reset combo after 1 second of no attacks
        
        // Merchant trading system
        let showMerchantDialog = false;
        let showTradeScreen = false;
        let selectedTradeOption = 0; // 0 = Buy, 1 = Sell
        let tradeMode = 'buy'; // 'buy' or 'sell'
        let selectedTradeSlot = 0;
        
        // Quest system - Enhanced with proper tracking
        let questNPCCompleted = false; // Track if player completed the fish quest this session
        let questNPCActive = false; // Track if player has the fish quest active
        let skyQuestCompleted = false; // Track if player completed Sky's goblin quest this session
        let skyQuestActive = false; // Track if player has Sky's goblin quest active
        let goblinKillCount = 0; // Track how many goblins player has killed
        let showQuestDialog = false;
        let selectedQuestOption = 0; // 0 = Accept, 1 = Decline or 0 = Yes, 1 = No for completion
        let questDialogType = 'initial'; // 'initial', 'during', 'completion', 'completed'
        let activeQuests = []; // Array to store active quests (max 5)
        let currentDialogNPC = ''; // Track which NPC is talking
        
        // Shield purchase tracking (new)
        let hasShieldInInventory = false; // Track if player has shield

        // Shield blocking mechanics (NEW)
        let isBlocking = false; // Is player currently holding shield up
        let shieldHitCount = 0; // How many hits the shield has taken
        const MAX_SHIELD_HITS = 2; // Shield breaks after 2 hits
        let shieldBroken = false; // Is shield currently broken

        // Butterflies in Town Zone
        let townButterflies = [
            { x: 5, y: 11, offsetX: 0, offsetY: 0, time: 0 },
            { x: 8, y: 11, offsetX: 0, offsetY: 0, time: Math.PI },
            { x: 5, y: 9, offsetX: 0, offsetY: 0, time: Math.PI * 0.5 },
            { x: 8, y: 9, offsetX: 0, offsetY: 0, time: Math.PI * 1.5 }
        ];
        
        // Firemaking system - UPDATED for inventory-based interface
        let isSelectingFiremaking = false; // New state for tinderbox selection
        let firemakingStep = 0; // 0 = selecting logs, 1 = selecting quantity
        let selectedFiremakingOption = 0;
        let firemakingOptions = [];
        let selectedQuantity = 0; // 0 = 1x, 1 = All
        let selectedLogsSlot = 0;
        let isFiremaking = false;
        let firemakingDirection = 'down'; // Direction to place fires
        let firemakingCount = 0;
        let targetFireCount = 0;
        let nextFireTime = 0;
        
        // Player-created campfires
        let playerCampfires = [];
        
        // Initialize starting items
        inventory[0] = {
            id: 'sword',
            name: 'Old Sword',
            description: 'An old rusty sword. Still sharp enough to hurt.',
            icon: 'üó°Ô∏è',
            type: 'weapon',
            rotateIcon: true  // NEW: Flag to rotate this icon
        };
        
        inventory[1] = {
            id: 'fishing_rod',
            name: 'Old Fishing Rod',
            description: 'An old fishing rod. Perfect for catching fish in the lake.',
            icon: 'üé£',
            type: 'tool'
        };
        
        inventory[2] = {
            id: 'iron_axe',
            name: 'Iron Axe',
            description: 'An iron axe. Perfect for chopping trees.',
            icon: 'ü™ì',
            type: 'tool'
        };
        
        const expRequirements = [
            0, 10, 25, 45, 70, 100, 140, 190, 250, 320, 
            400, 500, 620, 760, 920, 1100, 1300, 1520, 1760, 2000
        ];

        const npc = { x: 5, y: 4, color: '#ffd700' };
        const fireplace = { x: 16, y: 9, color: '#ff6600' };
        const merchant = { x: 11, y: 3, color: '#ff8c00' };
        const questNPC = { x: 15, y: 9, color: '#4169E1' }; // Quest NPC in Lake Zone
        const skyNPC = { x: 16, y: 2, color: '#87CEEB' }; // Sky NPC in Town Zone
        
        // Trees in Town Zone
        const trees = [
            { x: 12, y: 9, chopped: false },
            { x: 16, y: 9, chopped: false },
            { x: 12, y: 12, chopped: false },
            { x: 16, y: 12, chopped: false }
        ];

        // Cave entrance in Forest Zone
        const caveEntrance = { x: 10, y: 6 };

        // Lake water area (7x7 grid in center)
        const LAKE_CENTER_X = Math.floor(GRID_WIDTH / 2);
        const LAKE_CENTER_Y = Math.floor(GRID_HEIGHT / 2);
        const LAKE_SIZE = 7;
        const LAKE_MIN_X = LAKE_CENTER_X - Math.floor(LAKE_SIZE / 2);
        const LAKE_MAX_X = LAKE_CENTER_X + Math.floor(LAKE_SIZE / 2);
        const LAKE_MIN_Y = LAKE_CENTER_Y - Math.floor(LAKE_SIZE / 2);
        const LAKE_MAX_Y = LAKE_CENTER_Y + Math.floor(LAKE_SIZE / 2);

        function gridToPixel(gridX, gridY) {
            return {
                x: gridX * GRID_SIZE + GRID_SIZE / 2,
                y: gridY * GRID_SIZE + GRID_SIZE / 2
            };
        }

        function isWaterTile(gridX, gridY) {
            return myZone === 3 && 
                   gridX >= LAKE_MIN_X && gridX <= LAKE_MAX_X &&
                   gridY >= LAKE_MIN_Y && gridY <= LAKE_MAX_Y;
        }

        function isAdjacentToWater(gridX, gridY) {
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    if (isWaterTile(gridX + dx, gridY + dy)) {
                        return true;
                    }
                }
            }
            return false;
        }

        function isAdjacentToFireplace(gridX, gridY) {
            if (myZone !== 3) return false;
            const distance = Math.abs(gridX - fireplace.x) + Math.abs(gridY - fireplace.y);
            return distance <= 1;
        }

        function findAdjacentTree(gridX, gridY) {
            if (myZone !== 1) return null;
            
            for (let tree of trees) {
                if (!tree.chopped) {
                    const distance = Math.abs(gridX - tree.x) + Math.abs(gridY - tree.y);
                    if (distance <= 1) {
                        return tree;
                    }
                }
            }
            return null;
        }

        function wrapText(text, maxWidth, font) {
            ctx.font = font;
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';
            
            for (let word of words) {
                const testLine = currentLine + (currentLine ? ' ' : '') + word;
                const metrics = ctx.measureText(testLine);
                
                if (metrics.width > maxWidth && currentLine) {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            }
            
            if (currentLine) {
                lines.push(currentLine);
            }
            
            return lines;
        }

        // Typewriter effect update function
        function updateTypewriter(currentTime) {
            if (isTypewriterActive && charIndex < dialogText.length) {
                if (currentTime - lastCharTime >= typewriterSpeed) {
                    charIndex++;
                    displayedText = dialogText.substring(0, charIndex);
                    lastCharTime = currentTime;

                    // Check if we've reached the end naturally
                    if (charIndex >= dialogText.length) {
                        isTypewriterActive = false; // Automatically stop typewriter
                    }
                }
            }
        }

        // Start typewriter effect for new dialogue
        function startTypewriter(text) {
            dialogText = text;
            displayedText = '';
            charIndex = 0;
            lastCharTime = Date.now();
            isTypewriterActive = true;
        }

        // Skip to end of typewriter (instant show all text)
        function skipTypewriter() {
            if (isTypewriterActive) {
                charIndex = dialogText.length;
                displayedText = dialogText;
                isTypewriterActive = false;
                typewriterJustSkipped = true; // NEW: Set flag to prevent immediate action

                // Clear the flag after a short delay
                setTimeout(() => {
                    typewriterJustSkipped = false;
                }, 200); // 200ms grace period
            }
        }

        // Track previous player count for drop cleanup
        let previousPlayerCount = 0;

        // FIXED: This function waits for Firebase data before creating the player
        function initializeGame() {
            console.log('=== INITIALIZING GAME ===');
            initializeAudio();

            // Create unique player ID
            playerId = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            console.log('Generated Player ID:', playerId);
            
            // Set up the players listener - this will fire immediately with current data
            const playersRef = ref(database, 'players');
            onValue(playersRef, (snapshot) => {
                const currentPlayers = snapshot.val() || {};
                console.log('Firebase players data received:', currentPlayers);
                
                // Update local players object
                players = currentPlayers;
                const currentPlayerCount = Object.keys(players).length;
                document.getElementById('playerCount').textContent = currentPlayerCount;
                
                // FIXED: Enhanced cleanup when player count goes from >0 to 0
                if (previousPlayerCount > 0 && currentPlayerCount === 0) {
                    console.log('üßπ Player count dropped to 0 - cleaning up all drops and fireballs');

                    // Clean up drops (existing functionality)
                    const dropsRef = ref(database, 'drops');
                    set(dropsRef, null).then(() => {
                        console.log('‚úÖ All drops cleaned up successfully');
                    }).catch((error) => {
                        console.error('‚ùå Failed to clean drops:', error);
                    });

                    // NEW: Clean up fireballs
                    const fireballsRef = ref(database, 'fireballs');
                    set(fireballsRef, null).then(() => {
                        console.log('‚úÖ All fireballs cleaned up successfully');
                    }).catch((error) => {
                        console.error('‚ùå Failed to clean fireballs:', error);
                    });
                }
                previousPlayerCount = currentPlayerCount;
                
                // Clean up old players
                const now = Date.now();
                Object.entries(players).forEach(([id, player]) => {
                    if (player && player.lastSeen && (now - player.lastSeen) > 30000) {
                        console.log('Removing old player:', id);
                        const inactivePlayerRef = ref(database, `players/${id}`);
                        remove(inactivePlayerRef);
                    }
                });
                
                // IMPORTANT: Only create our player once, when we first get Firebase data
                if (!isPlayerCreated) {
                    createPlayerWithFirebaseData(currentPlayers);
                    isPlayerCreated = true;
                }
            });
        }

        // Start music after player is created
        function startInitialMusic() {
            setTimeout(() => {
                playZoneMusic(myZone); // Start music for current zone
                console.log('Initial zone music started');
            }, 1000); // 1 second delay to help with autoplay policy
        }

        function createPlayerWithFirebaseData(currentPlayers) {
            console.log('=== CREATING PLAYER WITH FIREBASE DATA ===');
            console.log('Current Firebase players:', currentPlayers);
            
            // Get existing player numbers from Firebase data
            const existingNumbers = Object.values(currentPlayers)
                .filter(p => p && typeof p.playerNumber === 'number' && p.playerNumber > 0)
                .map(p => p.playerNumber);
            
            console.log('Existing player numbers from Firebase:', existingNumbers);
            
            // Find first available number
            playerNumber = 1;
            while (existingNumbers.includes(playerNumber) && playerNumber <= 20) {
                playerNumber++;
            }
            if (playerNumber > 20) {
                playerNumber = Math.floor(Math.random() * 1000) + 21;
            }
            
            console.log('Assigned player number:', playerNumber);
            
            // Set color based on player number with fallback
            myColor = colors[(playerNumber - 1) % colors.length] || '#ff6b6b'; // Fallback to red
            console.log('Assigned color:', myColor);
            
            // Ensure color is valid - additional fallback
            if (!myColor || myColor === '') {
                myColor = '#ff6b6b'; // Force red as backup
                console.log('Using fallback color:', myColor);
            }
            
            // Find starting position
            let startPos;
            do {
                startPos = {
                    x: Math.floor(Math.random() * (GRID_WIDTH - 2)) + 1,
                    y: Math.floor(Math.random() * (GRID_HEIGHT - 2)) + 1
                };
            } while (isPositionOccupied(startPos.x, startPos.y));
            
            myGridPos = startPos;
            console.log('Starting position:', myGridPos);
            
            // Initialize mana
            myMana = myMaxMana; // Start with full mana
            myHealth = 4;

            // Calculate max mana based on starting level (usually 1)
            myMaxMana = 3 + Math.floor(playerLevel / 20);
            myMana = myMaxMana; // Ensure mana matches new max

            // Update UI
            document.getElementById('playerColor').innerHTML = '‚óè';
            document.getElementById('playerColor').style.color = myColor;
            document.getElementById('gridPos').textContent = `${myGridPos.x}, ${myGridPos.y}`;
            updateZoneDisplay();
            updateHeartDisplay();
            updateManaDisplay();
            updateGoldDisplay();
            updateSkillsDisplay();
            
            // Create player in Firebase
            updatePlayerData();
            
            // Set up cleanup
            const playerRef = ref(database, `players/${playerId}`);
            onDisconnect(playerRef).remove();
            window.addEventListener('beforeunload', () => remove(playerRef));
            
            console.log('Player created successfully!');

            startInitialMusic(); // Start the zone music
        }

        function updateZoneDisplay() {
            const zoneNames = { 1: 'Town', 2: 'Farm', 3: 'Lake', 4: 'Forest', 5: 'Cave' };
            document.getElementById('zoneDisplay').textContent = zoneNames[myZone];
        }

        function updatePlayerData() {
            if (playerId && isPlayerCreated) {
                console.log('Attempting to write player data to Firebase...');
                const playerRef = ref(database, `players/${playerId}`);
                const playerData = {
                    gridX: myGridPos.x,
                    gridY: myGridPos.y,
                    color: myColor,
                    health: myHealth,
                    mana: myMana || 3,           // Add with fallback
                    maxMana: myMaxMana || 3,     // Add with fallback
                    gold: myGold,
                    direction: myDirection,
                    zone: myZone,
                    playerNumber: playerNumber,
                    isRespawning: isRespawning,
                    isFishing: isFishing,
                    isCooking: isCooking,
                    isWoodcutting: isWoodcutting,
                    isAttacking: isAttacking,
                    attackComboCount: attackComboCount,
                    isFiremaking: isFiremaking,
                    isBlocking: isBlocking, // NEW
                    shieldHitCount: shieldHitCount, // NEW
                    level: playerLevel,
                    exp: playerEXP,
                    magic: playerMagic,
                    attack: playerAttack,
                    fishing: playerFishing,
                    cooking: playerCooking,
                    woodcutting: playerWoodcutting,
                    lastSeen: serverTimestamp()
                };
                
                console.log('Writing player data:', playerData);
                
                set(playerRef, playerData).then(() => {
                    console.log('Successfully wrote to Firebase!');
                }).catch((error) => {
                    console.error('Firebase write failed:', error);
                    console.error('Error code:', error.code);
                    console.error('Error message:', error.message);
                });
            } else {
                console.log('Cannot update player data - missing playerId or not created');
            }
        }

        function isPositionOccupied(gridX, gridY) {
            if (isWaterTile(gridX, gridY)) {
                return true;
            }

            // Check for trees in Town Zone
            if (myZone === 1) {
                for (let tree of trees) {
                    if (!tree.chopped && tree.x === gridX && tree.y === gridY) {
                        return true;
                    }
                }
            }

            // Check for goblins in Forest Zone - they now block movement
            if (myZone === 4) {
                for (let [mobId, mob] of Object.entries(mobs)) {
                    if (mob && mob.type === 'goblin' && mob.health > 0 &&
                        mob.x === gridX && mob.y === gridY) {
                        return true;
                    }
                }
            }

            // Check for Goblin Warlord in Cave Zone - blocks 4x4 area
            if (myZone === 5) {
                for (let [mobId, mob] of Object.entries(mobs)) {
                    if (mob && mob.type === 'warlord' && mob.health > 0) {
                        // Boss occupies 4x4 tiles centered on its position
                        const bossMinX = mob.x - 1;
                        const bossMaxX = mob.x + 2;
                        const bossMinY = mob.y - 1;
                        const bossMaxY = mob.y + 2;
                        if (gridX >= bossMinX && gridX <= bossMaxX &&
                            gridY >= bossMinY && gridY <= bossMaxY) {
                            return true;
                        }
                    }
                } // ‚Üê Boss loop ends here
                
                // NEW: Check for entrance barrier fences - side exits open at y=12
                const entranceX = Math.floor(GRID_WIDTH / 2); // x=10
                const entranceY = GRID_HEIGHT - 1; // y=14

                // Left wall (x=9) - at y=14, 13, 11 ONLY (skip y=12 for side exit)
                if (gridX === entranceX - 1 && (gridY === entranceY || gridY === entranceY - 1 || gridY === entranceY - 3)) {
                    return true;
                }

                // Right wall (x=11) - at y=14, 13, 11 ONLY (skip y=12 for side exit)
                if (gridX === entranceX + 1 && (gridY === entranceY || gridY === entranceY - 1 || gridY === entranceY - 3)) {
                    return true;
                }

                // DO NOT block (10,10), (8,12), or (12,12) - these are exits!

                // Right corridor walls (leading to exit at 12,12)
                for (let y = 13; y >= 12; y--) {
                    // Left wall of right corridor (x=11) - but don't double-block main path
                    if (gridX === 11 && gridY === y && gridY < entranceY - 4) {
                        return true;
                    }
                }
            } // ‚Üê Cave zone check ends here
            
            // Player campfires are passable - don't check them here
            // Only permanent structures block movement
            
            return Object.values(players).some(player => 
                player && player.gridX === gridX && player.gridY === gridY && player.zone === myZone
            ) || (myZone === 1 && npc.x === gridX && npc.y === gridY) || 
               (myZone === 1 && merchant.x === gridX && merchant.y === gridY) ||
               (myZone === 1 && skyNPC.x === gridX && skyNPC.y === gridY) ||
               (myZone === 3 && fireplace.x === gridX && fireplace.y === gridY) ||
               (myZone === 3 && questNPC.x === gridX && questNPC.y === gridY);
        }

        function addItemToInventory(item) {
            if (item.stackable) {
                // Try to add to existing stacks first
                for (let i = 0; i < inventory.length; i++) {
                    if (inventory[i] && inventory[i].id === item.id) {
                        const spaceAvailable = item.maxStack - inventory[i].stack;
                        if (spaceAvailable > 0) {
                            const amountToAdd = Math.min(spaceAvailable, item.stack);
                            inventory[i].stack += amountToAdd;
                            item.stack -= amountToAdd;
                            if (item.stack <= 0) {
                                updateShieldInventoryStatus(); // NEW - Track shield ownership
                                return true; // All items added
                            }
                        }
                    }
                }
                // If we still have items left, create new stacks
                while (item.stack > 0) {
                    for (let i = 0; i < inventory.length; i++) {
                        if (!inventory[i]) {
                            const stackSize = Math.min(item.stack, item.maxStack);
                            inventory[i] = {
                                ...item,
                                stack: stackSize
                            };
                            item.stack -= stackSize;
                            if (item.stack <= 0) {
                                updateShieldInventoryStatus(); // NEW - Track shield ownership
                                return true;
                            }
                            break;
                        }
                    }
                    // If we get here, inventory is full
                    if (item.stack > 0) {
                        updateShieldInventoryStatus(); // NEW - Track shield ownership
                        return false;
                    }
                }
                updateShieldInventoryStatus(); // NEW - Track shield ownership
                return true;
            }
            // Non-stackable items
            for (let i = 0; i < inventory.length; i++) {
                if (!inventory[i]) {
                    inventory[i] = item;
                    updateShieldInventoryStatus(); // NEW - Track shield ownership
                    return true;
                }
            }
            updateShieldInventoryStatus(); // NEW - Track shield ownership
            return false;
        }

        function startFishing() {
            if (equippedTool && equippedTool.id === 'fishing_rod' && isAdjacentToWater(myGridPos.x, myGridPos.y)) {
                isFishing = true;
                fishingStartTime = Date.now();
                nextFishTime = fishingStartTime + 3000 + Math.random() * 2000;
                updatePlayerData();
                console.log('Started fishing...');
            }
        }

        function stopFishing() {
            if (isFishing) {
                isFishing = false;
                updatePlayerData();
                console.log('Stopped fishing.');
            }
        }

        function startCooking() {
            // Check if adjacent to Lake fireplace
            if (myZone === 3 && isAdjacentToFireplace(myGridPos.x, myGridPos.y)) {
                // Find cookable items in inventory
                cookingOptions = [];
                inventory.forEach((item, index) => {
                    if (item && item.id === 'fish' && item.stack > 0) {
                        cookingOptions.push({
                            name: 'Fresh Fish',
                            description: 'Cook into Cooked Fresh Fish (+1 Health when eaten)',
                            icon: 'üêü',
                            requiredItem: 'fish',
                            resultItem: {
                                id: 'cooked_fish',
                                name: 'Cooked Fresh Fish',
                                description: 'A cooked fresh-water fish. Smells yummy!',
                                icon: 'üçñ',
                                type: 'food',
                                stackable: true,
                                stack: 1,
                                maxStack: 250,
                                healAmount: 1
                            },
                            expGain: 3
                        });
                    }
                });
                
                if (cookingOptions.length > 0) {
                    showCookingDialog = true;
                    selectedCookingOption = 0;

                    // Build cooking text dynamically
                    const option = cookingOptions[0];
                    const cookingText = `I can cook food here\n\n${option.icon} ${option.name}: ${option.description}`;
                    startTypewriter(cookingText);
                } else {
                    showDialog = true;
                    startTypewriter("I need some raw food to cook here. Maybe I should try fishing first!");
                }
                return;
            }
            
            // Check if adjacent to player campfire
            let nearCampfire = false;
            for (let campfire of playerCampfires) {
                if (campfire.zone === myZone) {
                    const distance = Math.abs(myGridPos.x - campfire.x) + Math.abs(myGridPos.y - campfire.y);
                    if (distance <= 1) {
                        nearCampfire = true;
                        break;
                    }
                }
            }
            
            if (nearCampfire) {
                // Find cookable items in inventory
                cookingOptions = [];
                inventory.forEach((item, index) => {
                    if (item && item.id === 'fish' && item.stack > 0) {
                        cookingOptions.push({
                            name: 'Fresh Fish',
                            description: 'Cook into Cooked Fresh Fish (+1 Health when eaten)',
                            icon: 'üü§',
                            requiredItem: 'fish',
                            resultItem: {
                                id: 'cooked_fish',
                                name: 'Cooked Fresh Fish',
                                description: 'A cooked fresh-water fish. Smells yummy!',
                                icon: 'üçñ',
                                type: 'food',
                                stackable: true,
                                stack: 1,
                                maxStack: 250,
                                healAmount: 1
                            },
                            expGain: 3
                        });
                    }
                });
                
                if (cookingOptions.length > 0) {
                    showCookingDialog = true;
                    selectedCookingOption = 0;

                    // Build cooking text dynamically
                    const option = cookingOptions[0];
                    const cookingText = `I can cook food here\n\n${option.icon} ${option.name}: ${option.description}`;
                    startTypewriter(cookingText);
                } else {
                    showDialog = true;
                    startTypewriter("I need some raw food to cook here. Maybe I should try fishing first!");
                }
            }
        }

        function stopCooking() {
            if (isCooking) {
                isCooking = false;
                showCookingDialog = false;
                updatePlayerData();
                console.log('Stopped cooking.');
            }
        }

        function processCooking() {
            if (isCooking && Date.now() >= nextCookTime) {
                const option = cookingOptions[selectedCookingOption];
                if (!option) {
                    // No more cooking options available, stop cooking
                    stopCooking();
                    return;
                }

                // Find the required item in inventory
                let foundItem = false;
                for (let i = 0; i < inventory.length; i++) {
                    if (inventory[i] && inventory[i].id === option.requiredItem && inventory[i].stack > 0) {
                        // Remove one raw item
                        inventory[i].stack--;
                        if (inventory[i].stack <= 0) {
                            inventory[i] = null;
                        }

                        // Add cooked item - create a fresh copy
                        const cookedItem = {
                            id: option.resultItem.id,
                            name: option.resultItem.name,
                            description: option.resultItem.description,
                            icon: option.resultItem.icon,
                            type: option.resultItem.type,
                            stackable: option.resultItem.stackable,
                            stack: 1,
                            maxStack: option.resultItem.maxStack,
                            healAmount: option.resultItem.healAmount
                        };

                        if (addItemToInventory(cookedItem)) {
                            console.log(`Cooked ${option.name}!`);
                            
                            // PLAY COOKING SOUND each time something is cooked (like woodcutting)
                            playCookingSound();
                            
                            // Show cooking popup
                            cookedItemName = option.name;
                            showCookingPopup = true;
                            cookingPopupTimer = 1500;
                            
                            // Give cooking XP
                            if (playerCooking < 20) {
                                playerCooking += 1;
                                console.log(`Cooking skill increased to ${playerCooking}!`);
                            }
                            
                            givePlayerEXP(option.expGain);
                            updatePlayerData();
                            foundItem = true;
                        }
                        break;
                    }
                }
                
                // Check if we still have items to cook after this cooking action
                let hasMoreItems = false;
                for (let i = 0; i < inventory.length; i++) {
                    if (inventory[i] && inventory[i].id === option.requiredItem && inventory[i].stack > 0) {
                        hasMoreItems = true;
                        break;
                    }
                }
                
                if (!hasMoreItems || !foundItem) {
                    // No more items to cook, stop cooking
                    stopCooking();
                    return;
                }
                
                nextCookTime = Date.now() + 2000 + Math.random() * 1000;
            }
        }

        function cycleCookingOption() {
            if (cookingOptions.length > 0) {
                selectedCookingOption = (selectedCookingOption + 1) % cookingOptions.length;
            }
        }

        function selectCookingOption() {
            if (cookingOptions.length > 0 && cookingOptions[selectedCookingOption]) {
                isCooking = true;
                showCookingDialog = false;
                cookingStartTime = Date.now();
                nextCookTime = cookingStartTime + 2000 + Math.random() * 1000;
                updatePlayerData();
                console.log(`Started cooking ${cookingOptions[selectedCookingOption].name}...`);
            }
        }

        function startWoodcutting() {
            const nearbyTree = findAdjacentTree(myGridPos.x, myGridPos.y);
            if (nearbyTree && equippedTool && equippedTool.id === 'iron_axe') {
                currentTree = nearbyTree;
                showWoodcuttingDialog = true;
                selectedWoodcuttingOption = 0; // Default to "Yes"
                startTypewriter('Chop down the tree?');
            } else if (!equippedTool || equippedTool.id !== 'iron_axe') {
                showDialog = true;
                startTypewriter("I need to equip my axe first before I can chop down trees!");
            }
        }

        function stopWoodcutting() {
            if (isWoodcutting) {
                isWoodcutting = false;
                showWoodcuttingDialog = false;
                currentTree = null;
                updatePlayerData();
                console.log('Stopped woodcutting.');
            }
        }

        // REPLACE the existing processWoodcutting() function
        function processWoodcutting() {
            if (isWoodcutting && currentTree && Date.now() >= nextWoodcutTime) {
                // Create logs item
                const logs = {
                    id: 'logs',
                    name: 'Logs',
                    description: 'Fresh wood logs. I could make a fire with these.',
                    icon: 'ü™µ',
                    type: 'resource',
                    stackable: true,
                    stack: 1,
                    maxStack: 250
                };
                
                if (addItemToInventory(logs)) {
                    console.log('Chopped down tree and got logs!');
                    
                    // PLAY FINAL CHOPPING SOUND when tree is successfully chopped
                    playChoppingSound();
                    
                    // Show woodcutting popup
                    showWoodcuttingPopup = true;
                    woodcuttingPopupTimer = 1500;
                    
                    // Mark tree as chopped and record time
                    currentTree.chopped = true;
                    currentTree.choppedTime = Date.now();
                    
                    // Give woodcutting XP
                    if (playerWoodcutting < 20) {
                        playerWoodcutting += 1;
                        console.log(`Woodcutting skill increased to ${playerWoodcutting}!`);
                    }
                    
                    givePlayerEXP(4);
                    updatePlayerData();
                }
                
                // Stop woodcutting after tree is chopped
                stopWoodcutting();
            }
        }

        function cycleWoodcuttingOption() {
            selectedWoodcuttingOption = (selectedWoodcuttingOption + 1) % 2; // 0 = Yes, 1 = No
        }

        // REPLACE the existing selectWoodcuttingOption() function
        function selectWoodcuttingOption() {
            if (selectedWoodcuttingOption === 0) { // Yes
                isWoodcutting = true;
                showWoodcuttingDialog = false;
                woodcuttingStartTime = Date.now();
                nextWoodcutTime = woodcuttingStartTime + 3000 + Math.random() * 1000; // 3-4 seconds
                updatePlayerData();
                console.log('Started woodcutting...');
                
                // PLAY CHOPPING SOUND when woodcutting starts
                playChoppingSound();
                
            } else { // No
                showWoodcuttingDialog = false;
                currentTree = null;
            }
        }

        function performMeleeAttack() {
            if (myHealth <= 0 || isRespawning || isFishing || isCooking || isWoodcutting || isAttacking) return;

            // Check if sword is equipped
            if (!equippedWeapon || equippedWeapon.id !== 'sword') {
                return; // No sword equipped, can't attack
            }

            // Check if combo should reset (too much time passed)
            const now = Date.now();
            if (now - lastAttackTime > comboResetTime) {
                attackComboCount = 0;
            }

            // PLAY SWORD SOUND when attacking with sword
            playSwordStabSound();

            isAttacking = true;
            attackStartTime = Date.now();
            lastAttackTime = Date.now();
            updatePlayerData();

            // After attack finishes, increment combo count
            setTimeout(() => {
                attackComboCount = (attackComboCount + 1) % 3; // Cycle 0 -> 1 -> 2 -> 0
            }, attackDuration);
            
            // Calculate attack position based on direction
            const directions = {
                'up': { x: 0, y: -1 },
                'down': { x: 0, y: 1 },
                'left': { x: -1, y: 0 },
                'right': { x: 1, y: 0 }
            };
            
            const dir = directions[myDirection];
            const attackX = myGridPos.x + dir.x;
            const attackY = myGridPos.y + dir.y;
            
            console.log(`Melee attack targeting position: ${attackX}, ${attackY}`);
            
            // Check for mobs in attack range (Wilderness, Forest, and Cave zones)
            if (myZone === 2 || myZone === 4 || myZone === 5) {
                Object.entries(mobs).forEach(([mobId, mob]) => {
                    if (mob && mob.health > 0) {
                        // For boss (4x4), check if attack hits any of its tiles
                        let isHit = false;

                        if (mob.type === 'warlord') {
                            // Boss occupies 4x4 area centered on position
                            const bossMinX = mob.x - 1;
                            const bossMaxX = mob.x + 2;
                            const bossMinY = mob.y - 1;
                            const bossMaxY = mob.y + 2;

                            isHit = (attackX >= bossMinX && attackX <= bossMaxX &&
                                    attackY >= bossMinY && attackY <= bossMaxY);
                        } else {
                            // Normal mobs use single tile
                            isHit = (mob.x === attackX && mob.y === attackY);
                        }

                        if (!isHit) return;

                        // Only attack mobs in current zone
                        const mobZone = mob.zone || (mob.type === 'goblin' ? 4 : 2);
                        if (mobZone !== myZone) return;

                        console.log(`Melee attack hit ${mob.type} at ${mob.x}, ${mob.y}`);

                        // Check if this is the third attack (knockback attack)
                        const isKnockbackAttack = (attackComboCount === 2);

                        // Calculate damage based on Attack skill level
                        const attackDamage = playerAttack >= ATTACK_DAMAGE_THRESHOLD ? ENHANCED_DAMAGE : BASE_DAMAGE;
                        const newHealth = Math.max(0, mob.health - attackDamage);

                        // Determine correct Firebase reference
                        let mobRef;
                        if (myZone === 5) {
                            mobRef = ref(database, `caveMobs/${mobId}`);
                        } else if (myZone === 4) {
                            mobRef = ref(database, `forestMobs/${mobId}`);
                        } else {
                            mobRef = ref(database, `mobs/${mobId}`);
                        }

                        // Apply knockback if it's the third attack AND mob is not a boss
                        let knockbackX = mob.x;
                        let knockbackY = mob.y;

                        if (isKnockbackAttack && newHealth > 0 && !mob.noKnockback) {
                            // Calculate knockback direction (2 tiles back)
                            const knockbackDistance = 2;

                            switch (myDirection) {
                                case 'up':
                                    knockbackY = Math.max(1, mob.y - knockbackDistance);
                                    break;
                                case 'down':
                                    knockbackY = Math.min(GRID_HEIGHT - 2, mob.y + knockbackDistance);
                                    break;
                                case 'left':
                                    knockbackX = Math.max(1, mob.x - knockbackDistance);
                                    break;
                                case 'right':
                                    knockbackX = Math.min(GRID_WIDTH - 2, mob.x + knockbackDistance);
                                    break;
                            }

                            console.log(`Knockback! Moving ${mob.type} from ${mob.x},${mob.y} to ${knockbackX},${knockbackY}`);
                        }

                        if (newHealth <= 0) {
                            console.log(`${mob.type} ${mobId} killed by melee attack - creating drops`);

                            // Give attack skill XP
                            if (playerAttack < 20) {
                                playerAttack += 1;
                                console.log(`Attack skill increased to ${playerAttack}!`);
                            }

                            // Calculate EXP based on mob type (BOSS GIVES MASSIVE XP)
                            let expValue;
                            if (mob.type === 'warlord') {
                                expValue = 800; // MASSIVE XP BOOST - approximately 5-6 levels
                            } else if (mob.type === 'goblin') {
                                expValue = 12;
                            } else if (mob.type === 'chicken') {
                                expValue = 8;
                            } else {
                                expValue = 6;
                            }

                            const expDropRef = ref(database, `drops/exp_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`);
                            set(expDropRef, {
                                x: mob.x,
                                y: mob.y,
                                zone: myZone,
                                type: 'exp',
                                value: expValue,
                                createdAt: Date.now()
                            });
                            
                            // Gold drops - BOSS drops guaranteed 150 gold, goblins drop 4-5, others drop 2-4
                            if (mob.type === 'warlord' || Math.random() < 0.8) {
                                let goldValue;
                                if (mob.type === 'warlord') {
                                    goldValue = 150; // MASSIVE GOLD REWARD
                                } else if (mob.type === 'goblin') {
                                    goldValue = Math.floor(Math.random() * 2) + 4; // 4-5 gold
                                } else {
                                    goldValue = Math.floor(Math.random() * 3) + 2; // 2-4 gold
                                }
                                const goldDropRef = ref(database, `drops/gold_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`);
                                set(goldDropRef, {
                                    x: mob.x,
                                    y: mob.y,
                                    zone: myZone,
                                    type: 'gold',
                                    value: goldValue,
                                    createdAt: Date.now()
                                });
                            }
                            
                            // Chicken feather drops
                            if (mob.type === 'chicken' && Math.random() < 0.8) {
                                const featherDropRef = ref(database, `drops/feather_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`);
                                set(featherDropRef, {
                                    x: mob.x,
                                    y: mob.y,
                                    zone: myZone,
                                    type: 'feather',
                                    value: 1,
                                    createdAt: Date.now()
                                });
                            }
                            
                            // Track goblin kills for Sky's quest
                            if (mob.type === 'goblin' && skyQuestActive) {
                                goblinKillCount++;
                                console.log(`Goblin killed! Progress: ${goblinKillCount}/4`);
                            }

                            // FIXED: Set respawn timer - 15 seconds for all mobs including boss
                            set(mobRef, { ...mob, health: 0, respawnTime: Date.now() + 15000 });
                        } else {
                            // Mob is still alive - update health and position (with knockback if applicable)
                            set(mobRef, { ...mob, health: newHealth, x: knockbackX, y: knockbackY });
                        }
                        
                        givePlayerEXP(3); // Give some general XP for combat
                        updatePlayerData();
                    }
                });
            }
            
            // Attack animation will be handled in the draw function
            setTimeout(() => {
                isAttacking = false;
                updatePlayerData();
            }, attackDuration);
        }

        function startBlocking() {
            // Can only block if shield is equipped and not broken
            if (!equippedShield || shieldBroken || isBlocking) return;

            // Can't block while doing other actions
            if (isFishing || isCooking || isWoodcutting || isAttacking || isFiremaking || isRespawning) return;

            isBlocking = true;
            console.log('Started blocking with shield');
            updatePlayerData();
        }

        function stopBlocking() {
            if (!isBlocking) return;

            isBlocking = false;
            console.log('Stopped blocking');
            updatePlayerData();
        }

        function resetShield() {
            // Reset shield when player releases R key
            shieldHitCount = 0;
            shieldBroken = false;
            console.log('Shield reset');
        }

        function shieldTakeHit() {
            if (!isBlocking || shieldBroken) return false;

            shieldHitCount++;
            console.log(`Shield took hit ${shieldHitCount}/${MAX_SHIELD_HITS}`);

            if (shieldHitCount >= MAX_SHIELD_HITS) {
                shieldBroken = true;
                stopBlocking();
                console.log('Shield broken! Release R to reset.');
                return false; // Shield broke, damage goes through
            }

            updatePlayerData();
            return true; // Shield absorbed the hit
        }

        function processFishing() {
            if (isFishing && Date.now() >= nextFishTime) {
                const fish = {
                    id: 'fish',
                    name: 'Fresh Fish',
                    description: 'A fresh-water fish. Can be cooked or sold.',
                    icon: 'üêü',
                    type: 'resource',
                    stackable: true,
                    stack: 1,
                    maxStack: 250
                };
                
                if (addItemToInventory(fish)) {
                    console.log('Caught a fish!');
                    
                    // PLAY GENTLE FISHING SOUND when fish is caught
                    playFishingSound();
                    
                    showFishCatchPopup = true;
                    fishCatchPopupTimer = 1500;
                    
                    if (playerFishing < 20) {
                        playerFishing += 1;
                        console.log(`Fishing skill increased to ${playerFishing}!`);
                    }
                    
                    givePlayerEXP(2);
                    updatePlayerData();
                }
                
                nextFishTime = Date.now() + 3000 + Math.random() * 2000;
            }
        }

        function equipItem(slotIndex) {
            const item = inventory[slotIndex];
            if (!item) return;
            
            // Special handling for tinderbox - start firemaking selection within inventory
            if (item.id === 'tinderbox') {
                if (!isSelectingFiremaking) {
                    // Find logs in inventory for firemaking
                    firemakingOptions = [];
                    inventory.forEach((invItem, index) => {
                        if (invItem && invItem.id === 'logs' && invItem.stack > 0) {
                            firemakingOptions.push({
                                name: 'Logs',
                                description: 'Light these logs to create campfires for cooking.',
                                icon: 'ü™µ',
                                slotIndex: index,
                                stack: invItem.stack
                            });
                        }
                    });
                    
                    if (firemakingOptions.length > 0) {
                        isSelectingFiremaking = true;
                        firemakingStep = 0; // Start with log selection
                        selectedFiremakingOption = 0;
                        updateItemDescription();
                    } else {
                        // No logs available - this will be handled in updateItemDescription()
                        isSelectingFiremaking = true;
                        firemakingStep = 0;
                        updateItemDescription();
                    }
                }
                return;
            }
            
            // AFTER - Add shield equip logic
            if (item.type === 'weapon') {
                if (equippedWeapon) {
                    equippedWeapon = null;
                }
                equippedWeapon = item;
                console.log(`Equipped weapon: ${item.name}`);
            } else if (item.type === 'tool') {
                if (equippedTool) {
                    equippedTool = null;
                }
                equippedTool = item;
                console.log(`Equipped tool: ${item.name}`);
            } else if (item.type === 'shield') {
                // NEW: Shield equip logic
                if (equippedShield && equippedShield.id === item.id) {
                    equippedShield = null; // Only unequip if THIS shield is already equipped
                    console.log('Unequipped shield');
                } else {
                    equippedShield = item; // Otherwise, equip it
                    console.log(`Equipped shield: ${item.name}`);
                }
            } else if (item.type === 'food' && item.healAmount && myHealth < 4) {
                // Consume food/potion item
                const healAmount = Math.min(item.healAmount, 4 - myHealth);
                myHealth = Math.min(4, myHealth + healAmount);
                
                // Remove one from stack
                inventory[slotIndex].stack--;
                if (inventory[slotIndex].stack <= 0) {
                    inventory[slotIndex] = null;
                }
                
                updateHeartDisplay();
                updateManaDisplay(); // Add this line
                updatePlayerData();
                console.log(`Consumed ${item.name} and restored ${healAmount} health!`);
            }
            
            initializeInventory();
            updateShieldInventoryStatus(); // NEW
        }

        // AFTER - Include shield check
        function isItemEquipped(item) {
            return (equippedWeapon && equippedWeapon.id === item.id) ||
                (equippedTool && equippedTool.id === item.id) ||
                (equippedShield && equippedShield.id === item.id); // NEW
        }

        // NEW FUNCTION - Add after isItemEquipped()
        function updateShieldInventoryStatus() {
            // Check if player has shield in inventory
            hasShieldInInventory = inventory.some(item => item && item.id === 'shield');
        }

        function castFireball() {
            if (myHealth <= 0 || isRespawning || isFishing) return;

            // Check if player has mana
            if (myMana <= 0) {
                console.log('Not enough mana!');
                return; // Can't cast without mana
            }

            // Consume 1 mana
            myMana = Math.max(0, myMana - 1);
            updateManaDisplay();
            updatePlayerData();

            // PLAY FIREBALL SOUND when casting
            playFireballSound();
            
            const fireballId = 'fireball_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
            const directions = {
                'up': { x: 0, y: -1 },
                'down': { x: 0, y: 1 },
                'left': { x: -1, y: 0 },
                'right': { x: 1, y: 0 }
            };
            
            const dir = directions[myDirection];
            const fireballRef = ref(database, `fireballs/${fireballId}`);
            
            set(fireballRef, {
                x: myGridPos.x,
                y: myGridPos.y,
                dirX: dir.x,
                dirY: dir.y,
                ownerId: playerId,
                zone: myZone,
                createdAt: Date.now(),
                lastMove: Date.now()
            });
            
            setTimeout(() => {
                set(fireballRef, null);
            }, 5000);
        }

        // AFTER - Check shield before taking damage
        function takeDamage() {
            if (isRespawning || myHealth <= 0) return;

            // NEW: Check if shield blocks the damage
            if (isBlocking && shieldTakeHit()) {
                console.log('Shield blocked the damage!');
                return; // Damage blocked, don't take health damage
            }

            myHealth = Math.max(0, myHealth - 1);
            updateHeartDisplay();
            updatePlayerData();

            if (myHealth <= 0) {
                startRespawn();
            }
        }

        function startRespawn() {
            isRespawning = true;
            myHealth = 0;
            stopFishing();
            stopCooking();
            stopWoodcutting();
            updatePlayerData();
            updateHeartDisplay();
            updateManaDisplay(); // Add this line

            setTimeout(() => {
                const maxHealth = 4 + Math.floor(playerLevel / 10);
                myHealth = maxHealth;
                myMana = myMaxMana; // Restore mana on respawn
                isRespawning = false;

                let newPos;

                // FIXED: Zone-specific respawn logic
                if (myZone === 5) {
                    // Cave zone - always respawn near entrance/exit area to avoid warlord
                    // Respawn in the safe entrance corridor area
                    const entranceX = Math.floor(GRID_WIDTH / 2); // x=10
                    const entranceY = GRID_HEIGHT - 1; // y=14

                    // Respawn in main corridor between y=11 and y=13, x=10 (center path)
                    newPos = {
                        x: entranceX,
                        y: Math.floor(Math.random() * 3) + (entranceY - 3) // Random between y=11,12,13
                    };
                } else {
                    // Other zones - use normal random respawn with collision check
                    do {
                        newPos = {
                            x: Math.floor(Math.random() * (GRID_WIDTH - 2)) + 1,
                            y: Math.floor(Math.random() * (GRID_HEIGHT - 2)) + 1
                        };
                    } while (isPositionOccupied(newPos.x, newPos.y));
                }

                myGridPos = newPos;
                document.getElementById('gridPos').textContent = `${myGridPos.x}, ${myGridPos.y}`;
                updateHeartDisplay();
                updateManaDisplay();
                updatePlayerData();
            }, 3000);
        }

        function updateHeartDisplay() {
            const maxHealth = 4 + Math.floor(playerLevel / 10);
            const hearts = '‚ù§Ô∏è'.repeat(myHealth) + 'üñ§'.repeat(maxHealth - myHealth);
            document.getElementById('hearts').textContent = hearts;
            document.getElementById('healthDisplay').textContent = `${myHealth}/${maxHealth}`;
            document.getElementById('playerLife').textContent = `${myHealth}/${maxHealth}`;
        }

        function updateManaDisplay() {
            const manaHearts = 'üíô'.repeat(myMana) + 'üñ§'.repeat(myMaxMana - myMana);
            document.getElementById('manaHearts').textContent = manaHearts;
        }

        function updateGoldDisplay() {
            const goldCounter = document.getElementById('goldCounter');
            if (goldCounter) goldCounter.textContent = myGold;

            const goldDisplay = document.getElementById('goldDisplay');
            if (goldDisplay) goldDisplay.textContent = myGold;

            const playerGoldInv = document.getElementById('playerGoldInv');
            if (playerGoldInv) playerGoldInv.textContent = myGold;
        }

        // FIXED: Magic skill now works like attack skill - only levels from killing mobs with magic
        function givePlayerEXP(expAmount) {
            playerEXP += expAmount;

            const oldLevel = playerLevel;
            while (playerLevel < 20 && playerEXP >= expRequirements[playerLevel]) {
                playerLevel++;
            }

            if (playerLevel > oldLevel) {
                newLevel = playerLevel;
                showLevelUpPopup = true;
                levelUpPopupTimer = 3000;
                console.log('LEVEL UP! Now level ' + playerLevel);

                // FIXED: Award hearts for crossing level 10 or 20 thresholds
                const oldHeartThreshold = Math.floor(oldLevel / 10); // How many heart upgrades before
                const newHeartThreshold = Math.floor(playerLevel / 10); // How many heart upgrades now

                if (newHeartThreshold > oldHeartThreshold) {
                    // Crossed a threshold! Award hearts equal to the difference
                    const heartsToAdd = newHeartThreshold - oldHeartThreshold;
                    const maxHealth = 4 + Math.floor(playerLevel / 10);
                    myHealth = Math.min(myHealth + heartsToAdd, maxHealth);
                    updateHeartDisplay();
                    console.log(`Heart capacity increased! Now ${maxHealth} hearts maximum`);
                }

                // FIXED: Award mana hearts for crossing level 20, 40, 60, etc. thresholds
                const oldManaThreshold = Math.floor(oldLevel / 20); // How many mana upgrades before
                const newManaThreshold = Math.floor(playerLevel / 20); // How many mana upgrades now

                if (newManaThreshold > oldManaThreshold) {
                    // Crossed a mana threshold! Award mana hearts equal to the difference
                    const manaHeartsToAdd = newManaThreshold - oldManaThreshold;
                    myMaxMana = 3 + Math.floor(playerLevel / 20);
                    myMana = Math.min(myMana + manaHeartsToAdd, myMaxMana);
                    updateManaDisplay();
                    console.log(`Mana capacity increased! Now ${myMaxMana} mana hearts maximum`);
                }
            }

            updateSkillsDisplay();
            updatePlayerData();
        }

        function initializeInventory() {
            const inventoryGrid = document.getElementById('inventoryGrid');
            inventoryGrid.innerHTML = '';
            
            for (let i = 0; i < 20; i++) {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                slot.dataset.index = i;
                
                if (inventory[i]) {
                    slot.classList.add('occupied');

                    // NEW: Create a span for the icon so we can rotate it without affecting the slot
                    const iconSpan = document.createElement('span');
                    iconSpan.textContent = inventory[i].icon;
                    if (inventory[i].rotateIcon) {
                        iconSpan.style.display = 'inline-block';
                        iconSpan.style.transform = 'rotate(90deg)';
                    }
                    slot.appendChild(iconSpan);

                    if (inventory[i].stackable && inventory[i].stack > 1) {
                        const stackDiv = document.createElement('div');
                        stackDiv.className = 'item-stack';
                        stackDiv.textContent = inventory[i].stack;
                        slot.appendChild(stackDiv);
                    }
                    
                    if (isItemEquipped(inventory[i])) {
                        slot.classList.add('equipped');
                    }
                }
                
                if (i === selectedInventorySlot) {
                    slot.classList.add('selected');
                }
                
                inventoryGrid.appendChild(slot);
            }
            
            updateItemDescription();
        }

        function updateItemDescription() {
            const descriptionDiv = document.getElementById('itemDescription');
            const selectedItem = inventory[selectedInventorySlot];
            
            // Check if we're in firemaking selection mode
            if (isSelectingFiremaking && selectedItem && selectedItem.id === 'tinderbox') {
                if (firemakingStep === 0) {
                    // Selecting logs
                    if (firemakingOptions.length > 0) {
                        const option = firemakingOptions[selectedFiremakingOption];
                        descriptionDiv.innerHTML = `
                            <h4 style="margin: 0 0 10px 0; color: #9fd89f;">Light Logs</h4>
                            <p style="margin: 0 0 5px 0; font-size: 12px;">${option.icon} ${option.name} (${option.stack})</p>
                            <p style="margin: 0 0 5px 0; font-size: 11px; color: #a8c5a8;">TAB: Cycle logs | ENTER: Select</p>
                        `;
                    } else {
                        descriptionDiv.innerHTML = `
                            <h4 style="margin: 0 0 10px 0; color: #ff6b6b;">No Logs Available</h4>
                            <p style="margin: 0; font-size: 12px;">I need some logs to make a fire with the tinderbox! Try chopping down trees first.</p>
                        `;
                    }
                } else if (firemakingStep === 1) {
                    // Selecting quantity
                    const quantityText = selectedQuantity === 0 ? '1x log' : 'All logs';
                    descriptionDiv.innerHTML = `
                        <h4 style="margin: 0 0 10px 0; color: #9fd89f;">Quantity: ${quantityText}</h4>
                        <p style="margin: 0 0 5px 0; font-size: 12px;">How many fires to light?</p>
                        <p style="margin: 0; font-size: 11px; color: #a8c5a8;">TAB: 1x/All | ENTER: Start | ESC: Cancel</p>
                    `;
                }
                return;
            }
            
            // Normal item description
            if (selectedItem) {
                let stackText = '';
                if (selectedItem.stackable) {
                    stackText = ` (${selectedItem.stack}/${selectedItem.maxStack})`;
                }
                
                descriptionDiv.innerHTML = `
                    <h4 style="margin: 0 0 10px 0; color: #9fd89f;">[${selectedItem.name}]${stackText}</h4>
                    <p style="margin: 0; font-size: 12px;">${selectedItem.description}</p>
                `;
            } else {
                descriptionDiv.innerHTML = `
                    <h4 style="margin: 0 0 10px 0; color: #9fd89f;">[Empty Slot]</h4>
                    <p style="margin: 0; font-size: 12px;">Select an item to view its description.</p>
                `;
            }
        }

        function updateSkillsDisplay() {
            document.getElementById('playerLevel').textContent = playerLevel;
            document.getElementById('playerLife').textContent = `${myHealth}/4`;
            document.getElementById('playerMagic').textContent = playerMagic;
            document.getElementById('playerAttack').textContent = playerAttack;
            document.getElementById('playerFishing').textContent = playerFishing;
            document.getElementById('playerCooking').textContent = playerCooking;
            document.getElementById('playerWoodcutting').textContent = playerWoodcutting;
            document.getElementById('playerEXP').textContent = playerEXP;
            document.getElementById('playerGoldInv').textContent = myGold;
        }

        function toggleQuickChat() {
            showQuickChat = !showQuickChat;
            const overlay = document.getElementById('quickChatOverlay');
            
            if (showQuickChat) {
                overlay.style.display = 'block';
                selectedChatMessage = 0;
                updateQuickChatSelection();
            } else {
                overlay.style.display = 'none';
            }
        }

        function updateQuickChatSelection() {
            const messages = document.querySelectorAll('.quick-chat-message');
            messages.forEach((msg, index) => {
                if (index === selectedChatMessage) {
                    msg.classList.add('selected');
                } else {
                    msg.classList.remove('selected');
                }
            });
        }

        function cycleChatMessage() {
            selectedChatMessage = (selectedChatMessage + 1) % chatMessages.length;
            updateQuickChatSelection();
        }

        function sendChatMessage() {
            if (showQuickChat && isPlayerCreated && playerId) {
                const message = chatMessages[selectedChatMessage];
                console.log('Sending chat message:', message);
                console.log('Player ID:', playerId);
                console.log('Player position:', myGridPos);
                
                // Store the message with timestamp in Firebase
                const messageRef = ref(database, `playerMessages/${playerId}`);
                const messageData = {
                    message: message,
                    timestamp: serverTimestamp(),
                    gridX: myGridPos.x,
                    gridY: myGridPos.y,
                    zone: myZone,
                    playerNumber: playerNumber,
                    color: myColor
                };
                
                console.log('Sending message data:', messageData);
                
                set(messageRef, messageData).then(() => {
                    console.log('Message sent successfully to Firebase');
                }).catch((error) => {
                    console.error('Error sending message:', error);
                });
                
                // Auto-remove message after 3 seconds
                setTimeout(() => {
                    set(messageRef, null);
                }, 3000);
                
                toggleQuickChat();
            } else {
                console.log('Cannot send message - conditions not met:', {
                    showQuickChat,
                    isPlayerCreated,
                    playerId
                });
            }
        }

        function toggleInventory() {
            showInventory = !showInventory;
            const overlay = document.getElementById('inventoryOverlay');
            
            if (showInventory) {
                overlay.style.display = 'block';
                initializeInventory();
                updateSkillsDisplay();
            } else {
                overlay.style.display = 'none';
                // Reset firemaking selection when closing inventory
                if (isSelectingFiremaking) {
                    isSelectingFiremaking = false;
                    firemakingStep = 0;
                }
            }
        }

        function navigateInventory(direction) {
            if (!showInventory) return;
            
            let newSlot = selectedInventorySlot;
            
            switch (direction) {
                case 'up':
                    newSlot = Math.max(0, selectedInventorySlot - 5);
                    break;
                case 'down':
                    newSlot = Math.min(19, selectedInventorySlot + 5);
                    break;
                case 'left':
                    if (selectedInventorySlot % 5 !== 0) {
                        newSlot = selectedInventorySlot - 1;
                    }
                    break;
                case 'right':
                    if ((selectedInventorySlot + 1) % 5 !== 0) {
                        newSlot = selectedInventorySlot + 1;
                    }
                    break;
            }
            
            selectedInventorySlot = newSlot;
            initializeInventory();
        }

        function initializeMobs() {
            if (myZone === 5) {
                // NEW: Cave Zone - Goblin Warlord Boss
                console.log('Checking Cave Zone boss...');
                const caveMobsRef = ref(database, 'caveMobs');

                onValue(caveMobsRef, (snapshot) => {
                    const currentMobs = snapshot.val() || {};
                    console.log('Current Cave Mobs:', currentMobs);

                    // Only create boss if it doesn't exist
                    if (!currentMobs.goblinWarlord) {
                        console.log('Creating Goblin Warlord boss...');

                        // Spawn in upper-center of cave (away from entrance)
                        const bossRef = ref(database, 'caveMobs/goblinWarlord');
                        set(bossRef, {
                            x: Math.floor(GRID_WIDTH / 2),
                            y: 5, // Spawn deep in cave, away from entrance
                            health: 50,
                            maxHealth: 50,
                            type: 'warlord',
                            lastMove: Date.now(),
                            moveCounter: 0,
                            aggroTarget: null,
                            aggroRange: 5, // Larger aggro range
                            isAggro: false,
                            isBoss: true, // Flag for special handling
                            noKnockback: true // Boss cannot be knocked back
                        });
                    }
                }, { onlyOnce: true });
            } else if (myZone === 2) {
                // FIXED: Farm Zone mob initialization with better persistence
                console.log('Checking Farm Zone mobs...');
                const mobsRef = ref(database, 'mobs');
                onValue(mobsRef, (snapshot) => {
                    const currentMobs = snapshot.val() || {};
                    console.log('Current Farm Mobs:', Object.keys(currentMobs));
                    
                    // Count current farm mobs (not goblins)
                    const farmMobs = Object.entries(currentMobs).filter(([id, mob]) => 
                        mob && mob.type !== 'goblin'
                    );
                    
                    // If we have fewer than 6 farm mobs, create missing ones
                    if (farmMobs.length < 6) {
                        console.log(`Only ${farmMobs.length} farm mobs found, creating missing ones...`);
                        
                        const fenceMinX = Math.floor(GRID_WIDTH * 0.3) - 1;
                        const fenceMaxX = Math.floor(GRID_WIDTH * 0.7) + 1;
                        const fenceMinY = Math.floor(GRID_HEIGHT * 0.3) - 1;
                        const fenceMaxY = Math.floor(GRID_HEIGHT * 0.7) + 1;
                        
                        for (let i = 1; i <= 6; i++) {
                            const mobId = `farm_mob_${i}`;
                            if (!currentMobs[mobId] || currentMobs[mobId].health <= 0) {
                                const mobRef = ref(database, `mobs/${mobId}`);
                                console.log(`Creating farm mob ${mobId}`);
                                set(mobRef, {
                                    x: Math.floor(Math.random() * (fenceMaxX - fenceMinX)) + fenceMinX,
                                    y: Math.floor(Math.random() * (fenceMaxY - fenceMinY)) + fenceMinY,
                                    health: 2,
                                    maxHealth: 2,
                                    type: i <= 3 ? 'chicken' : 'mouse',
                                    lastMove: Date.now(),
                                    moveCounter: 0
                                });
                            }
                        }
                    }
                }, { onlyOnce: true });
            } else if (myZone === 4) {
                // FIXED: Simple Forest Zone goblin initialization - only create if none exist
                console.log('Checking Forest Zone goblins...');
                const forestMobsRef = ref(database, 'forestMobs');
                
                // Use onlyOnce to prevent duplicate creation
                onValue(forestMobsRef, (snapshot) => {
                    const currentMobs = snapshot.val() || {};
                    console.log('Current Forest Mobs:', Object.keys(currentMobs));
                    
                    // Only create if completely empty
                    if (Object.keys(currentMobs).length === 0) {
                        console.log('Creating initial 4 goblins...');
                        
                        const goblinPositions = [
                            { x: 5, y: 4, id: 'goblin_1' },   
                            { x: 15, y: 4, id: 'goblin_2' },  
                            { x: 5, y: 11, id: 'goblin_3' },  
                            { x: 15, y: 11, id: 'goblin_4' } 
                        ];
                        
                        goblinPositions.forEach((pos) => {
                            const mobRef = ref(database, `forestMobs/${pos.id}`);
                            console.log(`Creating goblin ${pos.id} at ${pos.x}, ${pos.y}`);
                            set(mobRef, {
                                x: pos.x,
                                y: pos.y,
                                health: 5,
                                maxHealth: 5,
                                type: 'goblin',
                                lastMove: Date.now(),
                                moveCounter: 0,
                                aggroTarget: null,
                                aggroRange: 3,
                                isAggro: false
                            });
                        });
                    }
                }, { onlyOnce: true }); // IMPORTANT: Only run once per zone entry
            }
        }

        function checkZoneTransition() {
            if (myZone === 1 && myGridPos.x >= GRID_WIDTH - 1) {
                myZone = 2;
                myGridPos.x = 1;
                stopFishing();
                updateZoneDisplay();
                updatePlayerData();
                initializeMobs();
                playZoneMusic(2);
            }
            else if (myZone === 2 && myGridPos.x <= 0) {
                myZone = 1;
                myGridPos.x = GRID_WIDTH - 2;
                stopFishing();
                updateZoneDisplay();
                updatePlayerData();
                playZoneMusic(1);
            }
            else if (myZone === 1 && myGridPos.x <= 0) {
                myZone = 3;
                myGridPos.x = GRID_WIDTH - 2;
                stopFishing();
                updateZoneDisplay();
                updatePlayerData();
                playZoneMusic(3);
            }
            else if (myZone === 3 && myGridPos.x >= GRID_WIDTH - 1) {
                myZone = 1;
                myGridPos.x = 1;
                stopFishing();
                updateZoneDisplay();
                updatePlayerData();
                playZoneMusic(1);
            }
            else if (myZone === 1 && myGridPos.y <= 0) {
                myZone = 4;
                myGridPos.y = GRID_HEIGHT - 2;
                stopFishing();
                updateZoneDisplay();
                updatePlayerData();
                initializeMobs();
                playZoneMusic(4);
            }
            else if (myZone === 4 && myGridPos.y >= GRID_HEIGHT - 1) {
                myZone = 1;
                myGridPos.y = 1;
                stopFishing();
                updateZoneDisplay();
                updatePlayerData();
                playZoneMusic(1);
            }
            // NEW: Cave entrance transition from Forest Zone
            else if (myZone === 4 && myGridPos.x === caveEntrance.x && myGridPos.y === caveEntrance.y) {
                myZone = 5; // Enter Cave
                myGridPos.x = Math.floor(GRID_WIDTH / 2); // Spawn at bottom-center
                myGridPos.y = GRID_HEIGHT - 2;
                stopFishing();
                updateZoneDisplay();
                updatePlayerData();
                initializeMobs();
                playZoneMusic(4); // Use same music as Forest
            }
            // NEW: Cave exit back to Forest Zone
            else if (myZone === 5 && myGridPos.y >= GRID_HEIGHT - 1) {
                myZone = 4; // Return to Forest
                myGridPos.x = caveEntrance.x;
                myGridPos.y = caveEntrance.y;
                stopFishing();
                updateZoneDisplay();
                updatePlayerData();
                playZoneMusic(4);
            }
        }

        // Quest management functions
        function addQuest(quest) {
            // Check if quest already exists
            const existingIndex = activeQuests.findIndex(q => q.id === quest.id);
            if (existingIndex !== -1) {
                return; // Quest already active
            }
            
            // Add quest to beginning of list
            activeQuests.unshift(quest);
            
            // If more than 5 quests, remove the oldest one
            if (activeQuests.length > 5) {
                const droppedQuest = activeQuests.pop();
                console.log(`Quest "${droppedQuest.title}" was dropped due to quest limit`);
                
                // Reset quest availability for dropped quest
                if (droppedQuest.id === 'fish_quest') {
                    questNPCCompleted = false;
                    questNPCActive = false;
                } else if (droppedQuest.id === 'goblin_quest') {
                    skyQuestCompleted = false;
                    skyQuestActive = false;
                    goblinKillCount = 0;
                }
            }
            
            updateQuestPanel();
        }
        
        function removeQuest(questId) {
            const index = activeQuests.findIndex(q => q.id === questId);
            if (index !== -1) {
                activeQuests.splice(index, 1);
            }
            updateQuestPanel();
        }
        
        function updateQuestPanel() {
            const questPanel = document.getElementById('questPanel');
            const questList = document.getElementById('questList');
            
            if (activeQuests.length === 0) {
                questPanel.style.display = 'none';
            } else {
                questPanel.style.display = 'block';
                questList.innerHTML = '';
                
                activeQuests.forEach((quest, index) => {
                    if (index >= 5) return; // Only show first 5
                    
                    const questItem = document.createElement('div');
                    questItem.className = 'quest-item';
                    
                    questItem.innerHTML = `
                        <div class="quest-title">${quest.title}</div>
                        <div class="quest-description">${quest.description}</div>
                    `;
                    
                    questList.appendChild(questItem);
                });
            }
        }
        
        function updateQuestProgress(questId, progress) {
            const quest = activeQuests.find(q => q.id === questId);
            if (quest) {
                quest.progress = progress;
            }
        }
        
        function checkQuestCompletion(questId) {
            const quest = activeQuests.find(q => q.id === questId);
            if (!quest) return false;
            
            if (questId === 'fish_quest') {
                let fishCount = 0;
                inventory.forEach(item => {
                    if (item && item.id === 'fish') {
                        fishCount += item.stack || 1;
                    }
                });
                quest.progress = `${Math.min(fishCount, 5)}/5`;
                return fishCount >= 5;
            } else if (questId === 'goblin_quest') {
                quest.progress = `${Math.min(goblinKillCount, 4)}/4`;
                return goblinKillCount >= 4;
            }
            
            return false;
        }
        
        // Draw NPC name tab above dialog
        function drawNPCNameTab(npcName, dialogBoxX, dialogBoxY, dialogBoxWidth) {
            const tabWidth = 120;
            const tabHeight = 25;
            const tabX = dialogBoxX + 20;
            const tabY = dialogBoxY - tabHeight;
            
            // Tab background
            ctx.fillStyle = 'rgba(45, 74, 42, 0.95)';
            ctx.fillRect(tabX, tabY, tabWidth, tabHeight);
            
            // Tab border
            ctx.strokeStyle = '#4a6b47';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(tabX, tabY + tabHeight);
            ctx.lineTo(tabX, tabY);
            ctx.lineTo(tabX + tabWidth, tabY);
            ctx.lineTo(tabX + tabWidth, tabY + tabHeight);
            ctx.stroke();
            
            // NPC name text
            ctx.fillStyle = '#9fd89f';
            ctx.font = 'bold 14px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(npcName, tabX + tabWidth/2, tabY + 17);
        }
        
        // Draw quest tracking panel
        function drawQuestPanel() {
            // This function is no longer needed since we moved to HTML-based panel
            // But keeping it empty in case it's called elsewhere
        }

        function checkNPCInteraction() {
            if (myZone === 1) {
                // Check regular NPC (Town Crier)
                const npcDistance = Math.abs(myGridPos.x - npc.x) + Math.abs(myGridPos.y - npc.y);
                if (npcDistance <= 1) {
                    showDialog = true;
                    currentDialogNPC = 'Town Crier';
                    startTypewriter("Hello there, brave adventurer! Head east to the Farm for adventure, west to the peaceful lake for fishing, or north to the dangerous forest!");
                    return;
                }
                
                // Check merchant cat
                const merchantDistance = Math.abs(myGridPos.x - merchant.x) + Math.abs(myGridPos.y - merchant.y);
                if (merchantDistance <= 1) {
                    showMerchantDialog = true;
                    selectedTradeOption = 0; // Default to "Buy"
                    startTypewriter('*meow* hey, wanna trade? ;3');
                    return;
                }
                
                // FIXED: Check Sky NPC for goblin quest (separate from Sam)
                const skyDistance = Math.abs(myGridPos.x - skyNPC.x) + Math.abs(myGridPos.y - skyNPC.y);
                if (skyDistance <= 1) {
                    if (skyQuestCompleted) {
                        // Quest completed state
                        showDialog = true;
                        currentDialogNPC = 'Sky';
                        startTypewriter("Thank you for clearing out those goblins! The forest is safe again.");
                    } else if (skyQuestActive) {
                        // Check if player has killed 4 goblins for completion
                        if (goblinKillCount >= 4) {
                            // Player has killed enough goblins - offer completion
                            questDialogType = 'completion';
                            selectedQuestOption = 0;
                            currentDialogNPC = 'Sky';
                            showQuestDialog = true;
                            startTypewriter("Excellent work! Here's your 40 gold reward!");
                        } else {
                            // Quest is active but player hasn't killed enough goblins
                            showDialog = true;
                            currentDialogNPC = 'Sky';
                            startTypewriter(`Come back to me once you've cleared out those goblins! (${goblinKillCount}/4 killed)`);
                        }
                    } else {
                        // Initial quest offering
                        questDialogType = 'initial';
                        selectedQuestOption = 0;
                        currentDialogNPC = 'Sky';
                        showQuestDialog = true;
                        startTypewriter('The forest is overrun with goblins! Kill 4 of them for a reward!');
                    }
                    return;
                }
            } else if (myZone === 3) {
                // FIXED: Check Sam quest NPC in Lake Zone (separate from Sky)
                const questNPCDistance = Math.abs(myGridPos.x - questNPC.x) + Math.abs(myGridPos.y - questNPC.y);
                if (questNPCDistance <= 1) {
                    if (questNPCCompleted) {
                        // Quest completed state
                        showDialog = true;
                        currentDialogNPC = 'Sam';
                        startTypewriter("Thanks for helping me catch those fish, this stew is going to be delicious!");
                    } else if (questNPCActive) {
                        // Check if player has 5 fish for completion
                        let fishCount = 0;
                        inventory.forEach(item => {
                            if (item && item.id === 'fish') {
                                fishCount += item.stack || 1;
                            }
                        });
                        
                        if (fishCount >= 5) {
                            // Player has enough fish - offer completion
                            questDialogType = 'completion';
                            selectedQuestOption = 0;
                            currentDialogNPC = 'Sam';
                            showQuestDialog = true;
                            startTypewriter('Perfect! You have the fish I need. Trade 5 fish for 30 gold?');
                        } else {
                            // Quest is active but player doesn't have enough fish
                            showDialog = true;
                            currentDialogNPC = 'Sam';
                            startTypewriter("Come back to me when you've caught 5 fish!");
                        }
                    } else {
                        // Initial quest offering
                        questDialogType = 'initial';
                        selectedQuestOption = 0;
                        currentDialogNPC = 'Sam';
                        showQuestDialog = true;
                        startTypewriter("Would you mind bringing me 5 fish? I'll give you a nice reward!");
                    }
                    return;
                }
            }
        }

        function checkFireplaceInteraction() {
            if (myZone === 3 && isAdjacentToFireplace(myGridPos.x, myGridPos.y)) {
                startCooking();
            } else if (isAdjacentToPlayerCampfire(myGridPos.x, myGridPos.y)) {
                startCooking();
            }
        }

        function checkTreeInteraction() {
            if (myZone === 1) {
                const nearbyTree = findAdjacentTree(myGridPos.x, myGridPos.y);
                if (nearbyTree) {
                    startWoodcutting();
                }
            }
        }

        function checkMerchantInteraction() {
            if (myZone === 1) {
                const distance = Math.abs(myGridPos.x - merchant.x) + Math.abs(myGridPos.y - merchant.y);
                if (distance <= 1) {
                    showMerchantDialog = true;
                    selectedTradeOption = 0; // Default to "Buy"
                }
            }
        }

        // Merchant inventory (infinite items) - UPDATED with feathers
        const merchantInventory = [
            {
                id: 'tinderbox',
                name: 'Tinderbox',
                description: 'A small box with flint and steel. Useful for starting fires.',
                icon: 'üì¶',
                type: 'tool',
                price: 15,
                stock: 999, // Infinite
                untradeable: true // Cannot be sold back
            },
            {
                id: 'health_potion',
                name: 'Health Potion',
                description: 'A red potion that restores 1 health. Cannot be traded.',
                icon: 'üß™',
                type: 'potion',
                price: 15,
                stock: 999, // Infinite
                untradeable: true
            },
            {
                id: 'shield',
                name: 'Wooden Shield',
                description: 'A sturdy wooden shield. Can be equipped for defense.',
                icon: 'üõ°Ô∏è',
                type: 'shield',
                price: 50,
                stock: 1, // Only 1 available per session
                untradeable: false // Can be sold back if needed
            }
        ];

        // AFTER - Filter out shield if already owned
        function getMerchantStock() {
            return merchantInventory.filter(item => {
                // Hide shield from merchant if player already has one
                if (item.id === 'shield' && hasShieldInInventory) {
                    return false;
                }
                return true;
            });
        }

        function getPlayerSellableItems() {
            const sellableItems = [];
            inventory.forEach((item, index) => {
                if (item && !item.untradeable) {
                    let price = 1; // Base price
                    
                    // Set prices based on item type and ID
                    switch (item.id) {
                        case 'fish': price = 3; break;
                        case 'cooked_fish': price = 8; break;
                        case 'logs': price = 5; break;
                        case 'feathers': price = 2; break; // NEW: Feathers sell for 2 gold
                        case 'sword': price = 50; break;
                        case 'fishing_rod': price = 30; break;
                        case 'iron_axe': price = 45; break;
                        case 'shield': price = 50; break; // NEW: Shield sells for 50 gold
                        default: price = Math.max(1, Math.floor(Math.random() * 10) + 1);
                    }
                    
                    sellableItems.push({
                        ...item,
                        slotIndex: index,
                        sellPrice: price
                    });
                }
            });
            return sellableItems;
        }

        function cycleMerchantOption() {
            selectedTradeOption = (selectedTradeOption + 1) % 2; // 0 = Buy, 1 = Sell
        }

        function selectMerchantOption() {
            if (selectedTradeOption === 0) { // Buy
                tradeMode = 'buy';
                showMerchantDialog = false;
                showTradeScreen = true;
                selectedTradeSlot = 0;
            } else { // Sell
                tradeMode = 'sell';
                showMerchantDialog = false;
                showTradeScreen = true;
                selectedTradeSlot = 0;
            }
        }

        function navigateTrade(direction) {
            const items = tradeMode === 'buy' ? getMerchantStock() : getPlayerSellableItems();
            const maxSlots = Math.max(0, items.length - 1);
            
            if (direction === 'up') {
                selectedTradeSlot = Math.max(0, selectedTradeSlot - 1);
            } else if (direction === 'down') {
                selectedTradeSlot = Math.min(maxSlots, selectedTradeSlot + 1);
            }
        }

        function executeTrade() {
            if (tradeMode === 'buy') {
                const merchantItems = getMerchantStock();
                const item = merchantItems[selectedTradeSlot];
                
                // AFTER - Track shield purchase
                if (item && myGold >= item.price) {
                    const itemToAdd = {
                        id: item.id,
                        name: item.name,
                        description: item.description,
                        icon: item.icon,
                        type: item.type,
                        stackable: item.type === 'potion',
                        stack: item.type === 'potion' ? 1 : undefined,
                        maxStack: item.type === 'potion' ? 50 : undefined,
                        healAmount: item.id === 'health_potion' ? 1 : undefined,
                        untradeable: item.untradeable || false
                    };

                    if (addItemToInventory(itemToAdd)) {
                        myGold -= item.price;
                        updateGoldDisplay();
                        updatePlayerData();
                        console.log(`Bought ${item.name} for ${item.price} gold`);

                        // Track shield purchase (NEW)
                        if (item.id === 'shield') {
                            hasShieldInInventory = true;
                            console.log('Shield purchased - removed from merchant stock');
                        }
                    }
                }
            } else { // sell
                const sellableItems = getPlayerSellableItems();
                const item = sellableItems[selectedTradeSlot];
                
                if (item) {
                    // Remove item from inventory
                    if (item.stackable && item.stack > 1) {
                        inventory[item.slotIndex].stack--;
                    } else {
                        inventory[item.slotIndex] = null;
                    }
                    
                    myGold += item.sellPrice;
                    updateGoldDisplay();
                    updatePlayerData();
                    console.log(`Sold ${item.name} for ${item.sellPrice} gold`);
                    
                    // Refresh the trade screen
                    if (getPlayerSellableItems().length === 0) {
                        showTradeScreen = false;
                    } else if (selectedTradeSlot >= getPlayerSellableItems().length) {
                        selectedTradeSlot = Math.max(0, getPlayerSellableItems().length - 1);
                    }
                }
            }
        }

        function closeTradeScreen() {
            showTradeScreen = false;
            showMerchantDialog = false;
        }

        function processFiremaking() {
            if (!isFiremaking || Date.now() < nextFireTime) return;
            
            const logsItem = inventory[selectedLogsSlot];
            if (!logsItem || logsItem.stack <= 0) {
                stopFiremaking();
                return;
            }
            
            // Calculate fire position (place at current position)
            const fireX = myGridPos.x;
            const fireY = myGridPos.y;
            
            // Create temporary campfire (lasts 90 seconds, enough for 8-10 cooking actions)
            playerCampfires.push({
                x: fireX,
                y: fireY,
                zone: myZone,
                createdAt: Date.now(),
                duration: 90000 // 90 seconds in milliseconds
            });
            
            // Remove one log from inventory
            logsItem.stack--;
            if (logsItem.stack <= 0) {
                inventory[selectedLogsSlot] = null;
            }
            
            firemakingCount++;
            console.log(`Placed campfire ${firemakingCount}/${targetFireCount} at ${fireX}, ${fireY}`);
            
            // Move player to next position for additional fires
            if (firemakingCount < targetFireCount) {
                const directions = {
                    'up': { x: 0, y: -1 },
                    'down': { x: 0, y: 1 },
                    'left': { x: -1, y: 0 },
                    'right': { x: 1, y: 0 }
                };
                
                const dir = directions[firemakingDirection];
                const nextX = myGridPos.x + dir.x;
                const nextY = myGridPos.y + dir.y;
                
                // Check if player can move to next position
                if (nextX < 0 || nextX >= GRID_WIDTH || nextY < 0 || nextY >= GRID_HEIGHT ||
                    isPositionOccupied(nextX, nextY)) {
                    console.log('Cannot move player - stopping firemaking');
                    stopFiremaking();
                    return;
                }
                
                myGridPos.x = nextX;
                myGridPos.y = nextY;
                document.getElementById('gridPos').textContent = `${myGridPos.x}, ${myGridPos.y}`;
                nextFireTime = Date.now() + 1000;
            } else {
                stopFiremaking();
            }
            
            updatePlayerData();
        }

        function stopFiremaking() {
            if (isFiremaking) {
                isFiremaking = false;
                firemakingCount = 0;
                targetFireCount = 0;
                updatePlayerData();
                console.log('Stopped firemaking');
            }
        }

        function isAdjacentToPlayerCampfire(gridX, gridY) {
            for (let campfire of playerCampfires) {
                if (campfire.zone === myZone) {
                    // Check if player is on the campfire tile OR adjacent to it
                    const distance = Math.abs(gridX - campfire.x) + Math.abs(gridY - campfire.y);
                    if (distance <= 1) {
                        return true;
                    }
                }
            }
            return false;
        }

        function checkDropPickup() {
            Object.entries(drops).forEach(([dropId, drop]) => {
                if (drop && 
                    drop.x === myGridPos.x && 
                    drop.y === myGridPos.y &&
                    drop.zone === myZone) {
                    
                    if (drop.type === 'heart' && myHealth < 4) {
                        myHealth = Math.min(4, myHealth + 1);
                        updateHeartDisplay();
                        console.log('Health restored!');
                    } else if (drop.type === 'gold') {
                        myGold += drop.value;
                        updateGoldDisplay();
                        console.log('Found ' + drop.value + ' gold!');
                    } else if (drop.type === 'exp') {
                        givePlayerEXP(drop.value);
                        console.log('Gained ' + drop.value + ' EXP from orb!');
                    } else if (drop.type === 'feather') {
                        // NEW: Handle feather drops
                        const feather = {
                            id: 'feathers',
                            name: 'Feathers',
                            description: 'Soft chicken feathers. Light and fluffy.',
                            icon: 'ü™∂',
                            type: 'resource',
                            stackable: true,
                            stack: 1,
                            maxStack: 250
                        };
                        
                        if (addItemToInventory(feather)) {
                            console.log('Picked up feather!');
                        }
                    }
                    
                    const dropRef = ref(database, `drops/${dropId}`);
                    set(dropRef, null);
                    updatePlayerData();
                }
            });
        }

        function listenToGameData() {
            const fireballsRef = ref(database, 'fireballs');
            onValue(fireballsRef, (snapshot) => {
                fireballs = snapshot.val() || {};
            });

            const mobsRef = ref(database, 'mobs');
            onValue(mobsRef, (snapshot) => {
                mobs = snapshot.val() || {};
            });

            // Listen to Forest Zone goblins
            const forestMobsRef = ref(database, 'forestMobs');
            onValue(forestMobsRef, (snapshot) => {
                const forestMobs = snapshot.val() || {};
                // Merge forest mobs with regular mobs for unified handling
                Object.entries(forestMobs).forEach(([id, mob]) => {
                    if (mob) {
                        mobs[id] = { ...mob, zone: 4 }; // Mark as forest zone
                    }
                });
            });

            // NEW: Listen to Cave Zone boss
            const caveMobsRef = ref(database, 'caveMobs');
            onValue(caveMobsRef, (snapshot) => {
                const caveMobs = snapshot.val() || {};
                // Merge cave mobs with regular mobs for unified handling
                Object.entries(caveMobs).forEach(([id, mob]) => {
                    if (mob) {
                        mobs[id] = { ...mob, zone: 5 }; // Mark as cave zone
                    }
                });
            });

            const dropsRef = ref(database, 'drops');
            onValue(dropsRef, (snapshot) => {
                drops = snapshot.val() || {};
            });

            const messagesRef = ref(database, 'playerMessages');
            onValue(messagesRef, (snapshot) => {
                playerMessages = snapshot.val() || {};
            });
        }

        function drawChicken(x, y) {
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(x, y + 2, 8, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(x, y - 5, 5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#ff8c00';
            ctx.beginPath();
            ctx.moveTo(x - 7, y - 5);
            ctx.lineTo(x - 3, y - 3);
            ctx.lineTo(x - 7, y - 1);
            ctx.fill();
            
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 2, y - 6, 1, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.moveTo(x - 2, y - 10);
            ctx.lineTo(x, y - 12);
            ctx.lineTo(x + 2, y - 10);
            ctx.lineTo(x + 1, y - 8);
            ctx.fill();
        }

        function drawMouse(x, y) {
            ctx.fillStyle = '#888';
            ctx.beginPath();
            ctx.arc(x, y, 6, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#888';
            ctx.beginPath();
            ctx.arc(x - 3, y - 2, 4, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#ffb6c1';
            ctx.beginPath();
            ctx.arc(x - 5, y - 6, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x - 1, y - 6, 2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 5, y - 3, 1, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x + 8, y + 2, 4, Math.PI, Math.PI * 1.5);
            ctx.stroke();
        }

        function drawFireParticles(x, y, time) {
            // Ember particles (rising sparks)
            for (let i = 0; i < 8; i++) {
                const particleTime = (time * 0.001 + i * 0.4) % 2; // 2-second loop
                const particleY = y - 10 - particleTime * 25; // Rise upward
                const particleX = x + Math.sin(time * 0.003 + i) * 8; // Slight drift
                const opacity = 1 - particleTime/2; // Fade as it rises

                ctx.fillStyle = `rgba(255, ${120 + Math.sin(time * 0.01 + i) * 50}, 0, ${opacity * 0.6})`;
                ctx.beginPath();
                ctx.arc(particleX, particleY, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }

            // Smoke particles (subtle gray)
            for (let i = 0; i < 3; i++) {
                const smokeTime = (time * 0.0005 + i * 0.6) % 3; // 3-second loop
                const smokeY = y - 15 - smokeTime * 20;
                const smokeX = x + Math.sin(time * 0.002 + i) * 10;
                const smokeOpacity = Math.max(0, 0.3 - smokeTime/10);

                ctx.fillStyle = `rgba(200, 200, 200, ${smokeOpacity})`;
                ctx.beginPath();
                ctx.arc(smokeX, smokeY, 3 + smokeTime, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawWaterTile(x, y, time) {
            const pixel = gridToPixel(x, y);

            // Base water color with depth variation
            const depthVariation = Math.sin(x * 0.5 + y * 0.3) * 10;
            ctx.fillStyle = `rgb(${65 + depthVariation}, ${105 + depthVariation}, 225)`;
            ctx.fillRect(pixel.x - GRID_SIZE/2, pixel.y - GRID_SIZE/2, GRID_SIZE, GRID_SIZE);

            // Flowing wave layers (multiple for depth)
            const wave1 = Math.sin(time * 0.002 + x * 0.3 + y * 0.2) * 8;
            const wave2 = Math.cos(time * 0.0015 + x * 0.4) * 5;

            ctx.fillStyle = 'rgba(135, 206, 235, 0.4)';
            ctx.fillRect(
                pixel.x - GRID_SIZE/2,
                pixel.y - GRID_SIZE/2 + wave1,
                GRID_SIZE,
                GRID_SIZE/4
            );

            ctx.fillStyle = 'rgba(173, 216, 230, 0.3)';
            ctx.fillRect(
                pixel.x - GRID_SIZE/2,
                pixel.y - GRID_SIZE/2 + wave2,
                GRID_SIZE,
                GRID_SIZE/5
            );
        }

        // NEW: Draw butterfly function
        function drawButterfly(x, y, time) {
            // Draw butterfly body
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x - 1, y - 3, 2, 6);
            
            // Draw butterfly wings with flutter animation
            const wingFlutter = Math.sin(time * 20) * 0.3;
            
            // Left wing
            ctx.fillStyle = '#FFB6C1';
            ctx.save();
            ctx.translate(x - 3, y - 2);
            ctx.rotate(wingFlutter);
            ctx.beginPath();
            ctx.ellipse(0, 0, 3, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // Right wing
            ctx.save();
            ctx.translate(x + 3, y - 2);
            ctx.rotate(-wingFlutter);
            ctx.beginPath();
            ctx.ellipse(0, 0, 3, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // Wing patterns
            ctx.fillStyle = '#FF69B4';
            ctx.save();
            ctx.translate(x - 3, y - 2);
            ctx.rotate(wingFlutter);
            ctx.beginPath();
            ctx.ellipse(0, 0, 1.5, 2.5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            ctx.save();
            ctx.translate(x + 3, y - 2);
            ctx.rotate(-wingFlutter);
            ctx.beginPath();
            ctx.ellipse(0, 0, 1.5, 2.5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function drawGoblin(x, y) {
            // Draw goblin body (green)
            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.arc(x, y, 12, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw goblin head (darker green)
            ctx.fillStyle = '#006400';
            ctx.beginPath();
            ctx.arc(x, y - 8, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw pointed ears
            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.moveTo(x - 10, y - 8);
            ctx.lineTo(x - 14, y - 12);
            ctx.lineTo(x - 8, y - 10);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(x + 10, y - 8);
            ctx.lineTo(x + 14, y - 12);
            ctx.lineTo(x + 8, y - 10);
            ctx.fill();
            
            // Draw red eyes
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.arc(x - 3, y - 10, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 3, y - 10, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw small club/weapon
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x + 12, y - 15, 3, 15);
            ctx.fillStyle = '#654321';
            ctx.beginPath();
            ctx.arc(x + 13, y - 17, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawGoblinWarlord(x, y) {
            // This boss is 4x scale - occupies 4x4 tiles
            const scale = 4;

            // === LEGS (wide stance for stability) ===
            ctx.fillStyle = '#1a7a1a';
            // Left leg
            ctx.fillRect(x - 45, y + 40, 25, 50);
            // Right leg
            ctx.fillRect(x + 20, y + 40, 25, 50);

            // Leg armor (metal knee guards)
            ctx.fillStyle = '#4a4a4a';
            ctx.fillRect(x - 45, y + 55, 25, 8);
            ctx.fillRect(x + 20, y + 55, 25, 8);

            // === MASSIVE BODY ===
            ctx.fillStyle = '#1a7a1a';
            ctx.beginPath();
            ctx.ellipse(x, y + 10, 55, 65, 0, 0, Math.PI * 2);
            ctx.fill();

            // Body shading for depth
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(x + 15, y + 20, 50, 55, 0, 0, Math.PI * 2);
            ctx.fill();

            // === CHEST ARMOR (metal plate) ===
            ctx.fillStyle = '#5a5a5a';
            ctx.fillRect(x - 40, y - 15, 80, 40);

            // Armor details (rivets)
            ctx.fillStyle = '#3a3a3a';
            for (let i = 0; i < 5; i++) {
                for (let j = 0; j < 3; j++) {
                    ctx.beginPath();
                    ctx.arc(x - 30 + i * 15, y - 10 + j * 15, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // === ARMS (thick and muscular) ===
            ctx.fillStyle = '#1a7a1a';
            // Left arm
            ctx.fillRect(x - 65, y - 10, 20, 55);
            // Right arm (holding weapon)
            ctx.fillRect(x + 45, y - 10, 20, 55);

            // Shoulder armor (spikes)
            ctx.fillStyle = '#4a4a4a';
            // Left shoulder
            ctx.beginPath();
            ctx.arc(x - 55, y - 10, 18, 0, Math.PI * 2);
            ctx.fill();
            // Shoulder spikes
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                ctx.fillStyle = '#6a6a6a';
                ctx.beginPath();
                ctx.moveTo(x - 55 + Math.cos(angle) * 18, y - 10 + Math.sin(angle) * 18);
                ctx.lineTo(x - 55 + Math.cos(angle) * 28, y - 10 + Math.sin(angle) * 28);
                ctx.lineTo(x - 55 + Math.cos(angle + 0.3) * 18, y - 10 + Math.sin(angle + 0.3) * 18);
                ctx.fill();
            }

            // Right shoulder
            ctx.fillStyle = '#4a4a4a';
            ctx.beginPath();
            ctx.arc(x + 55, y - 10, 18, 0, Math.PI * 2);
            ctx.fill();

            // === SKULL TROPHY ON BELT ===
            ctx.fillStyle = '#e8e8e8';
            ctx.beginPath();
            ctx.arc(x - 35, y + 30, 8, 0, Math.PI * 2);
            ctx.fill();
            // Eye sockets
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 38, y + 28, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x - 32, y + 28, 2, 0, Math.PI * 2);
            ctx.fill();

            // === MASSIVE HEAD ===
            ctx.fillStyle = '#004d00';
            ctx.beginPath();
            ctx.arc(x, y - 50, 40, 0, Math.PI * 2);
            ctx.fill();

            // Head shading
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.arc(x + 10, y - 45, 35, 0, Math.PI * 2);
            ctx.fill();

            // === HUGE POINTED EARS ===
            ctx.fillStyle = '#1a7a1a';
            // Left ear
            ctx.beginPath();
            ctx.moveTo(x - 40, y - 50);
            ctx.lineTo(x - 60, y - 65);
            ctx.lineTo(x - 35, y - 55);
            ctx.fill();
            // Right ear
            ctx.beginPath();
            ctx.moveTo(x + 40, y - 50);
            ctx.lineTo(x + 60, y - 65);
            ctx.lineTo(x + 35, y - 55);
            ctx.fill();

            // === BATTLE HELMET/CROWN ===
            ctx.fillStyle = '#8B7500';
            // Helmet base
            ctx.fillRect(x - 35, y - 75, 70, 15);
            // Helmet horns
            ctx.fillStyle = '#6a5a00';
            // Left horn
            ctx.beginPath();
            ctx.moveTo(x - 35, y - 70);
            ctx.lineTo(x - 50, y - 95);
            ctx.lineTo(x - 30, y - 75);
            ctx.fill();
            // Right horn
            ctx.beginPath();
            ctx.moveTo(x + 35, y - 70);
            ctx.lineTo(x + 50, y - 95);
            ctx.lineTo(x + 30, y - 75);
            ctx.fill();

            // === GLOWING RED EYES (very menacing) ===
            // Eye glow effect
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#FF0000';
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.arc(x - 15, y - 55, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 15, y - 55, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Bright eye centers
            ctx.fillStyle = '#FF6666';
            ctx.beginPath();
            ctx.arc(x - 15, y - 55, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 15, y - 55, 4, 0, Math.PI * 2);
            ctx.fill();

            // === BATTLE SCARS ===
            ctx.strokeStyle = '#003300';
            ctx.lineWidth = 3;
            // Scar across face
            ctx.beginPath();
            ctx.moveTo(x - 30, y - 60);
            ctx.lineTo(x + 25, y - 45);
            ctx.stroke();

            // === TUSKS/FANGS ===
            ctx.fillStyle = '#FFFFFF';
            // Left tusk
            ctx.beginPath();
            ctx.moveTo(x - 20, y - 35);
            ctx.lineTo(x - 15, y - 25);
            ctx.lineTo(x - 25, y - 30);
            ctx.fill();
            // Right tusk
            ctx.beginPath();
            ctx.moveTo(x + 20, y - 35);
            ctx.lineTo(x + 15, y - 25);
            ctx.lineTo(x + 25, y - 30);
            ctx.fill();

            // === MASSIVE WAR HAMMER ===
            ctx.lineWidth = 2;
            // Hammer handle (thick wooden shaft)
            ctx.fillStyle = '#5a3a1a';
            ctx.fillRect(x + 45, y - 70, 12, 110);

            // Handle grip wrapping
            ctx.strokeStyle = '#3a2a0a';
            for (let i = 0; i < 10; i++) {
                ctx.beginPath();
                ctx.moveTo(x + 45, y - 60 + i * 12);
                ctx.lineTo(x + 57, y - 60 + i * 12);
                ctx.stroke();
            }

            // Hammer head (MASSIVE metal block)
            ctx.fillStyle = '#3a3a3a';
            ctx.fillRect(x + 35, y - 100, 32, 35);

            // Hammer head details
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(x + 37, y - 98, 28, 5);
            ctx.fillRect(x + 37, y - 88, 28, 5);
            ctx.fillRect(x + 37, y - 78, 28, 5);

            // Spikes on hammer
            ctx.fillStyle = '#4a4a4a';
            for (let i = 0; i < 8; i++) {
                const spikeX = x + 37 + (i % 4) * 8;
                const spikeY = y - 100 + Math.floor(i / 4) * 35;
                ctx.beginPath();
                ctx.moveTo(spikeX, spikeY);
                ctx.lineTo(spikeX + 3, spikeY - 8);
                ctx.lineTo(spikeX + 6, spikeY);
                ctx.fill();
            }

            // === MASSIVE SHADOW ===
            const shadowGradient = ctx.createRadialGradient(x, y + 95, 0, x, y + 95, 85);
            shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0.6)');
            shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = shadowGradient;
            ctx.beginPath();
            ctx.ellipse(x, y + 95, 85, 15, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw a cute Nintendo-style character sprite
        function drawPlayerSprite(pixelX, pixelY, direction, color) {
            ctx.save();

            // More neutral color palette
            const skinTone = '#ffdbac';
            const hairColor = '#d4a574'; // Lighter, more neutral sandy brown
            const topColor = color; // Uses player color (can be any color)
            const bottomColor = '#a67c52'; // Neutral tan/brown shorts/pants

            if (direction === 'down') {
                // FRONT VIEW

                // Body/top (rounded rectangle - neutral style)
                ctx.fillStyle = topColor;
                ctx.beginPath();
                ctx.roundRect(pixelX - 8, pixelY - 2, 16, 12, 3);
                ctx.fill();

                // Shorts/pants (neutral tan/brown)
                ctx.fillStyle = bottomColor;
                ctx.fillRect(pixelX - 7, pixelY + 9, 6, 8);
                ctx.fillRect(pixelX + 1, pixelY + 9, 6, 8);

                // Shoes (neutral brown)
                ctx.fillStyle = '#8B7355';
                ctx.beginPath();
                ctx.ellipse(pixelX - 4, pixelY + 17, 3, 2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(pixelX + 4, pixelY + 17, 3, 2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head (slightly rounder/fuller)
                ctx.fillStyle = skinTone;
                ctx.beginPath();
                ctx.arc(pixelX, pixelY - 7, 7.5, 0, Math.PI * 2);
                ctx.fill();

                // Hair (medium length, gender-neutral)
                ctx.fillStyle = hairColor;
                ctx.beginPath();
                // Arc only covers top of head
                ctx.arc(pixelX, pixelY - 12, 8, Math.PI * 0.75, Math.PI * 2.25);
                ctx.fill();
                // Small side pieces
                ctx.fillRect(pixelX - 8, pixelY - 12, 2, 5);
                ctx.fillRect(pixelX + 6, pixelY - 12, 2, 5);

                // Eyes (rounder, more friendly)
                ctx.fillStyle = '#3d2817';
                ctx.beginPath();
                ctx.arc(pixelX - 3, pixelY - 8, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(pixelX + 3, pixelY - 8, 2, 0, Math.PI * 2);
                ctx.fill();

                // Eye highlights (makes eyes less hollow)
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(pixelX - 2.5, pixelY - 8.5, 0.8, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(pixelX + 3.5, pixelY - 8.5, 0.8, 0, Math.PI * 2);
                ctx.fill();

                // Subtle smile (small curve, not overly happy)
                ctx.strokeStyle = '#3d2817';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(pixelX, pixelY - 3.5, 2, 0.2, Math.PI - 0.2);
                ctx.stroke();

                // Rosy cheeks
                ctx.fillStyle = 'rgba(255, 182, 193, 0.4)';
                ctx.beginPath();
                ctx.ellipse(pixelX - 6, pixelY - 5, 2, 1.5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(pixelX + 6, pixelY - 5, 2, 1.5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Arms
                ctx.fillStyle = skinTone;
                ctx.beginPath();
                ctx.ellipse(pixelX - 10, pixelY + 2, 2.5, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(pixelX + 10, pixelY + 2, 2.5, 5, 0, 0, Math.PI * 2);
                ctx.fill();

            } else if (direction === 'up') {
                // BACK VIEW

                // Body/top (back view)
                ctx.fillStyle = topColor;
                ctx.beginPath();
                ctx.roundRect(pixelX - 8, pixelY - 2, 16, 12, 3);
                ctx.fill();

                // Shorts/pants
                ctx.fillStyle = bottomColor;
                ctx.fillRect(pixelX - 7, pixelY + 9, 6, 8);
                ctx.fillRect(pixelX + 1, pixelY + 9, 6, 8);

                // Shoes (back view)
                ctx.fillStyle = '#8B7355';
                ctx.fillRect(pixelX - 6, pixelY + 16, 5, 2);
                ctx.fillRect(pixelX + 1, pixelY + 16, 5, 2);

                // Head (back of head)
                ctx.fillStyle = skinTone;
                ctx.beginPath();
                ctx.arc(pixelX, pixelY - 8, 7, 0, Math.PI * 2);
                ctx.fill();

                // Hair (fuller on back, covers most of head)
                ctx.fillStyle = hairColor;
                ctx.beginPath();
                ctx.arc(pixelX, pixelY - 8, 7.5, 0, Math.PI * 2);
                ctx.fill();
                // Hair flowing down sides
                ctx.fillRect(pixelX - 7, pixelY - 8, 3, 6);
                ctx.fillRect(pixelX + 4, pixelY - 8, 3, 6);

                // Arms (back view, less visible)
                ctx.fillStyle = skinTone;
                ctx.fillRect(pixelX - 10, pixelY, 2, 6);
                ctx.fillRect(pixelX + 8, pixelY, 2, 6);

            } else if (direction === 'left') {
                // LEFT SIDE VIEW

                // Body/top
                ctx.fillStyle = topColor;
                ctx.beginPath();
                ctx.roundRect(pixelX - 5, pixelY - 2, 10, 12, 3);
                ctx.fill();

                // Shorts/pants (side view, stacked)
                ctx.fillStyle = bottomColor;
                ctx.fillRect(pixelX - 4, pixelY + 9, 8, 8);

                // Shoe
                ctx.fillStyle = '#8B7355';
                ctx.beginPath();
                ctx.ellipse(pixelX, pixelY + 17, 4, 2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.fillStyle = skinTone;
                ctx.beginPath();
                ctx.arc(pixelX, pixelY - 8, 7, 0, Math.PI * 2);
                ctx.fill();

                // Hair (natural continuous coverage)
                ctx.fillStyle = hairColor;
                // Main hair mass covering top and back
                ctx.beginPath();
                ctx.arc(pixelX + 1, pixelY - 10, 8, Math.PI * 0.85, Math.PI * 1.95);
                ctx.fill();
                // Connect to create smooth coverage
                ctx.fillRect(pixelX + 1, pixelY - 14, 7, 10);

                // Eye (side view)
                ctx.fillStyle = '#3d2817';
                ctx.beginPath();
                ctx.arc(pixelX - 3, pixelY - 8, 2, 0, Math.PI * 2);
                ctx.fill();

                // Eye highlight
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(pixelX - 2.5, pixelY - 8.5, 0.8, 0, Math.PI * 2);
                ctx.fill();

                // Simple nose
                ctx.fillStyle = '#3d2817';
                ctx.fillRect(pixelX - 6, pixelY - 6, 1, 2);

                // Subtle smile (side view)
                ctx.strokeStyle = '#3d2817';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(pixelX - 6, pixelY - 3);
                ctx.quadraticCurveTo(pixelX - 5, pixelY - 2.5, pixelX - 4, pixelY - 3);
                ctx.stroke();

                // Rosy cheek
                ctx.fillStyle = 'rgba(255, 182, 193, 0.4)';
                ctx.beginPath();
                ctx.ellipse(pixelX - 5, pixelY - 4, 2.5, 2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Arm (front arm visible)
                ctx.fillStyle = skinTone;
                ctx.beginPath();
                ctx.ellipse(pixelX - 8, pixelY + 2, 2, 5, -0.3, 0, Math.PI * 2);
                ctx.fill();

            } else if (direction === 'right') {
                // RIGHT SIDE VIEW (mirrored)

                // Body/top
                ctx.fillStyle = topColor;
                ctx.beginPath();
                ctx.roundRect(pixelX - 5, pixelY - 2, 10, 12, 3);
                ctx.fill();

                // Shorts/pants (side view, stacked)
                ctx.fillStyle = bottomColor;
                ctx.fillRect(pixelX - 4, pixelY + 9, 8, 8);

                // Shoe
                ctx.fillStyle = '#8B7355';
                ctx.beginPath();
                ctx.ellipse(pixelX, pixelY + 17, 4, 2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.fillStyle = skinTone;
                ctx.beginPath();
                ctx.arc(pixelX, pixelY - 8, 7, 0, Math.PI * 2);
                ctx.fill();

                // Hair (natural continuous coverage)
                ctx.fillStyle = hairColor;
                // Main hair mass covering top and back
                ctx.beginPath();
                ctx.arc(pixelX - 1, pixelY - 10, 8, Math.PI * 1.05, Math.PI * 2.15);
                ctx.fill();
                // Connect to create smooth coverage
                ctx.fillRect(pixelX - 8, pixelY - 14, 7, 10);

                // Eye (side view)
                ctx.fillStyle = '#3d2817';
                ctx.beginPath();
                ctx.arc(pixelX + 3, pixelY - 8, 2, 0, Math.PI * 2);
                ctx.fill();

                // Eye highlight
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(pixelX + 3.5, pixelY - 8.5, 0.8, 0, Math.PI * 2);
                ctx.fill();

                // Simple nose
                ctx.fillStyle = '#3d2817';
                ctx.fillRect(pixelX + 5, pixelY - 6, 1, 2);

                // Subtle smile (side view)
                ctx.strokeStyle = '#3d2817';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(pixelX + 4, pixelY - 3);
                ctx.quadraticCurveTo(pixelX + 5, pixelY - 2.5, pixelX + 6, pixelY - 3);
                ctx.stroke();

                // Rosy cheek
                ctx.fillStyle = 'rgba(255, 182, 193, 0.4)';
                ctx.beginPath();
                ctx.ellipse(pixelX + 5, pixelY - 4, 2.5, 2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Arm (front arm visible)
                ctx.fillStyle = skinTone;
                ctx.beginPath();
                ctx.ellipse(pixelX + 8, pixelY + 2, 2, 5, 0.3, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        // Draw subtle shadow under any character/entity
        function drawCharacterShadow(x, y, size = 12) {
            // Soft circular shadow with gradient for realism
            const gradient = ctx.createRadialGradient(x, y + 18, 0, x, y + 18, size);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0.3)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.ellipse(x, y + 18, size, 4, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // INSERT THE NEW drawMerchantCat FUNCTION HERE
        function drawMerchantCat(pixelX, pixelY) {
            ctx.save();

            const catOrange = '#ff9f5a';
            const catLightOrange = '#ffc89a';
            const catDarkOrange = '#e08040';
            const vestColor = '#8B6914'; // Golden brown merchant vest
            const beltColor = '#654321';

            // Body (standing upright) - round and chubby
            ctx.fillStyle = vestColor;
            ctx.beginPath();
            ctx.roundRect(pixelX - 9, pixelY - 3, 18, 14, 5);
            ctx.fill();

            // Belt/sash (merchant detail)
            ctx.fillStyle = beltColor;
            ctx.fillRect(pixelX - 9, pixelY + 3, 18, 3);

            // Gold buckle on belt
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(pixelX - 2, pixelY + 3, 4, 3);

            // Legs (short, stubby cat legs)
            ctx.fillStyle = catOrange;
            ctx.fillRect(pixelX - 7, pixelY + 10, 5, 6);
            ctx.fillRect(pixelX + 2, pixelY + 10, 5, 6);

            // Paws/feet (rounded and cute)
            ctx.fillStyle = catLightOrange;
            ctx.beginPath();
            ctx.ellipse(pixelX - 4.5, pixelY + 16, 3.5, 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(pixelX + 4.5, pixelY + 16, 3.5, 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head (larger, rounder - cute cat proportions)
            ctx.fillStyle = catOrange;
            ctx.beginPath();
            ctx.arc(pixelX, pixelY - 9, 10, 0, Math.PI * 2);
            ctx.fill();

            // Ears (rounded triangles - softer)
            ctx.fillStyle = catOrange;
            ctx.beginPath();
            ctx.arc(pixelX - 7, pixelY - 15, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(pixelX + 7, pixelY - 15, 4, 0, Math.PI * 2);
            ctx.fill();

            // Inner ears (pink, smaller)
            ctx.fillStyle = '#ffb6c1';
            ctx.beginPath();
            ctx.arc(pixelX - 7, pixelY - 14, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(pixelX + 7, pixelY - 14, 2, 0, Math.PI * 2);
            ctx.fill();

            // Cheek fluff (makes cat cuter)
            ctx.fillStyle = catLightOrange;
            ctx.beginPath();
            ctx.arc(pixelX - 8, pixelY - 7, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(pixelX + 8, pixelY - 7, 3, 0, Math.PI * 2);
            ctx.fill();

            // Muzzle area (lighter patch)
            ctx.fillStyle = catLightOrange;
            ctx.beginPath();
            ctx.ellipse(pixelX, pixelY - 7, 5, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Eyes (big, round, cute cat eyes)
            ctx.fillStyle = '#2d5016'; // Deep green
            ctx.beginPath();
            ctx.ellipse(pixelX - 3.5, pixelY - 10, 2.5, 3, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(pixelX + 3.5, pixelY - 10, 2.5, 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Pupils (vertical slits, but rounder)
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(pixelX - 3.5, pixelY - 10, 0.8, 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(pixelX + 3.5, pixelY - 10, 0.8, 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Large eye highlights (makes eyes sparkly and cute)
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(pixelX - 3, pixelY - 11, 1.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(pixelX + 4, pixelY - 11, 1.2, 0, Math.PI * 2);
            ctx.fill();

            // Smaller eye highlights
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(pixelX - 4, pixelY - 9, 0.6, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(pixelX + 3, pixelY - 9, 0.6, 0, Math.PI * 2);
            ctx.fill();

            // Nose (pink triangle, nicely positioned)
            ctx.fillStyle = '#ffb6c1';
            ctx.beginPath();
            ctx.moveTo(pixelX, pixelY - 7);
            ctx.lineTo(pixelX - 1.5, pixelY - 5.5);
            ctx.lineTo(pixelX + 1.5, pixelY - 5.5);
            ctx.fill();

            // Mouth (simple cute smile, HIGHER UP - closer to nose)
            ctx.strokeStyle = '#3d2817';
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            ctx.moveTo(pixelX, pixelY - 5.5);
            ctx.lineTo(pixelX, pixelY - 4.5);
            ctx.stroke();

            // Smile curves (higher placement, smaller)
            ctx.beginPath();
            ctx.arc(pixelX - 1.2, pixelY - 4.5, 1.2, 0, Math.PI);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(pixelX + 1.2, pixelY - 4.5, 1.2, 0, Math.PI);
            ctx.stroke();

            // Whiskers (thinner, more delicate)
            ctx.strokeStyle = '#3d2817';
            ctx.lineWidth = 0.8;
            // Left whiskers
            ctx.beginPath();
            ctx.moveTo(pixelX - 8, pixelY - 6);
            ctx.lineTo(pixelX - 14, pixelY - 7);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(pixelX - 8, pixelY - 5);
            ctx.lineTo(pixelX - 14, pixelY - 5);
            ctx.stroke();

            // Right whiskers
            ctx.beginPath();
            ctx.moveTo(pixelX + 8, pixelY - 6);
            ctx.lineTo(pixelX + 14, pixelY - 7);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(pixelX + 8, pixelY - 5);
            ctx.lineTo(pixelX + 14, pixelY - 5);
            ctx.stroke();

            // Subtle stripes on head (tabby pattern, lighter)
            ctx.strokeStyle = 'rgba(224, 128, 64, 0.4)';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(pixelX - 5, pixelY - 13);
            ctx.lineTo(pixelX - 3, pixelY - 11);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(pixelX + 5, pixelY - 13);
            ctx.lineTo(pixelX + 3, pixelY - 11);
            ctx.stroke();

            // Arms (cute little paws at sides)
            ctx.fillStyle = catOrange;
            ctx.beginPath();
            ctx.ellipse(pixelX - 11, pixelY + 2, 2.5, 5, -0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(pixelX + 11, pixelY + 2, 2.5, 5, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Paw pads (pink)
            ctx.fillStyle = '#ffb6c1';
            ctx.beginPath();
            ctx.arc(pixelX - 11, pixelY + 4, 1.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(pixelX + 11, pixelY + 4, 1.2, 0, Math.PI * 2);
            ctx.fill();

            // Tail (curled, fluffy)
            ctx.strokeStyle = catOrange;
            ctx.lineWidth = 5;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(pixelX + 13, pixelY + 6, 9, Math.PI * 0.9, Math.PI * 1.6);
            ctx.stroke();

            // Tail tip (lighter)
            ctx.strokeStyle = catLightOrange;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(pixelX + 13, pixelY + 6, 9, Math.PI * 1.4, Math.PI * 1.6);
            ctx.stroke();

            // Merchant coin pouch
            ctx.fillStyle = '#8B7355';
            ctx.beginPath();
            ctx.ellipse(pixelX + 7, pixelY + 9, 3, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // String on pouch
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(pixelX + 7, pixelY + 7, 1.5, 0, Math.PI);
            ctx.stroke();

            // Coin symbol on pouch
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.arc(pixelX + 7, pixelY + 10, 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#daa520';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.arc(pixelX + 7, pixelY + 10, 1.5, 0, Math.PI * 2);
            ctx.stroke();

            ctx.restore();
        }

        // INSERT THE NEW drawTownCrier FUNCTION HERE
        function drawTownCrier(pixelX, pixelY) {
            ctx.save();

            const skinTone = '#ffdbac';
            const coatColor = '#8B0000'; // Dark red coat
            const trimColor = '#ffd700'; // Gold trim
            const pantsColor = '#2F4F4F'; // Dark grey pants
            const bellColor = '#ffd700'; // Gold bell

            // Body - fancy coat
            ctx.fillStyle = coatColor;
            ctx.beginPath();
            ctx.roundRect(pixelX - 10, pixelY - 3, 20, 15, 4);
            ctx.fill();

            // Gold trim on coat
            ctx.fillStyle = trimColor;
            ctx.fillRect(pixelX - 10, pixelY - 3, 20, 2);
            ctx.fillRect(pixelX - 10, pixelY + 10, 20, 2);

            // Gold buttons
            ctx.fillStyle = trimColor;
            ctx.beginPath();
            ctx.arc(pixelX, pixelY, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(pixelX, pixelY + 5, 2, 0, Math.PI * 2);
            ctx.fill();

            // Pants/legs
            ctx.fillStyle = pantsColor;
            ctx.fillRect(pixelX - 7, pixelY + 11, 6, 7);
            ctx.fillRect(pixelX + 1, pixelY + 11, 6, 7);

            // Shoes (black)
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(pixelX - 4, pixelY + 18, 3, 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(pixelX + 4, pixelY + 18, 3, 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.fillStyle = skinTone;
            ctx.beginPath();
            ctx.arc(pixelX, pixelY - 10, 8, 0, Math.PI * 2);
            ctx.fill();

            // Tricorn hat (classic town crier hat)
            ctx.fillStyle = '#000';
            // Hat base
            ctx.beginPath();
            ctx.ellipse(pixelX, pixelY - 16, 11, 3, 0, 0, Math.PI * 2);
            ctx.fill();
            // Hat crown (triangular shape)
            ctx.beginPath();
            ctx.moveTo(pixelX - 9, pixelY - 16);
            ctx.lineTo(pixelX, pixelY - 24);
            ctx.lineTo(pixelX + 9, pixelY - 16);
            ctx.closePath();
            ctx.fill();

            // Gold trim on hat
            ctx.strokeStyle = trimColor;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(pixelX - 9, pixelY - 16);
            ctx.lineTo(pixelX, pixelY - 24);
            ctx.lineTo(pixelX + 9, pixelY - 16);
            ctx.stroke();

            // Feather in hat
            ctx.strokeStyle = '#FF6347'; // Red feather
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(pixelX + 7, pixelY - 22);
            ctx.quadraticCurveTo(pixelX + 10, pixelY - 26, pixelX + 8, pixelY - 28);
            ctx.stroke();

            // Eyes
            ctx.fillStyle = '#3d2817';
            ctx.beginPath();
            ctx.arc(pixelX - 3, pixelY - 11, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(pixelX + 3, pixelY - 11, 2, 0, Math.PI * 2);
            ctx.fill();

            // Eye highlights
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(pixelX - 2.5, pixelY - 11.5, 0.8, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(pixelX + 3.5, pixelY - 11.5, 0.8, 0, Math.PI * 2);
            ctx.fill();

            // Nose
            ctx.fillStyle = '#d4a574';
            ctx.beginPath();
            ctx.arc(pixelX, pixelY - 9, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Subtle, dignified smile (much smaller and less curved)
            ctx.strokeStyle = '#3d2817';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(pixelX, pixelY - 5.5, 2, 0.3, Math.PI - 0.3);
            ctx.stroke();

            // Rosy cheeks (lighter/subtler)
            ctx.fillStyle = 'rgba(255, 182, 193, 0.3)';
            ctx.beginPath();
            ctx.ellipse(pixelX - 6, pixelY - 8, 2, 1.5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(pixelX + 6, pixelY - 8, 2, 1.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Left arm (holding bell up)
            ctx.fillStyle = coatColor;
            ctx.beginPath();
            ctx.ellipse(pixelX - 13, pixelY - 5, 3, 7, -0.8, 0, Math.PI * 2);
            ctx.fill();

            // Left hand (holding bell)
            ctx.fillStyle = skinTone;
            ctx.beginPath();
            ctx.arc(pixelX - 15, pixelY - 10, 2.5, 0, Math.PI * 2);
            ctx.fill();

            // Bell in left hand
            ctx.fillStyle = bellColor;
            ctx.beginPath();
            // Bell body (trapezoid shape)
            ctx.moveTo(pixelX - 18, pixelY - 12);
            ctx.lineTo(pixelX - 12, pixelY - 12);
            ctx.lineTo(pixelX - 13, pixelY - 8);
            ctx.lineTo(pixelX - 17, pixelY - 8);
            ctx.closePath();
            ctx.fill();

            // Bell shine
            ctx.fillStyle = '#ffed4e';
            ctx.fillRect(pixelX - 16, pixelY - 11, 2, 2);

            // Bell handle
            ctx.strokeStyle = bellColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(pixelX - 15, pixelY - 13, 2, Math.PI, 0);
            ctx.stroke();

            // Bell clapper
            ctx.fillStyle = '#8B7355';
            ctx.beginPath();
            ctx.arc(pixelX - 15, pixelY - 8, 1, 0, Math.PI * 2);
            ctx.fill();

            // Right arm (at side)
            ctx.fillStyle = coatColor;
            ctx.beginPath();
            ctx.ellipse(pixelX + 12, pixelY + 2, 2.5, 6, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Right hand
            ctx.fillStyle = skinTone;
            ctx.beginPath();
            ctx.arc(pixelX + 13, pixelY + 6, 2, 0, Math.PI * 2);
            ctx.fill();

            // Scroll/paper in right hand (town crier announcements)
            ctx.fillStyle = '#FFF8DC';
            ctx.fillRect(pixelX + 11, pixelY + 6, 4, 8);

            // Lines on scroll
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(pixelX + 11.5, pixelY + 8);
            ctx.lineTo(pixelX + 14.5, pixelY + 8);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(pixelX + 11.5, pixelY + 10);
            ctx.lineTo(pixelX + 14.5, pixelY + 10);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(pixelX + 11.5, pixelY + 12);
            ctx.lineTo(pixelX + 14.5, pixelY + 12);
            ctx.stroke();

            ctx.restore();
        }

        // INSERT THE NEW drawSky FUNCTION HERE
        function drawSky(pixelX, pixelY) {
            ctx.save();

            const skinTone = '#ffdbac';
            const hairColor = '#d4a76a'; // Golden blonde/light brown
            const dressColor = '#87CEEB'; // Baby blue
            const dressAccent = '#B0E0E6'; // Lighter blue accent

            // Dress - simple A-line style
            ctx.fillStyle = dressColor;
            ctx.beginPath();
            // A-line dress shape (slightly flared)
            ctx.moveTo(pixelX - 7, pixelY - 2);
            ctx.lineTo(pixelX - 10, pixelY + 12);
            ctx.lineTo(pixelX + 10, pixelY + 12);
            ctx.lineTo(pixelX + 7, pixelY - 2);
            ctx.closePath();
            ctx.fill();

            // Simple collar/neckline
            ctx.fillStyle = dressAccent;
            ctx.fillRect(pixelX - 7, pixelY - 2, 14, 2);

            // Hem accent at bottom
            ctx.fillStyle = dressAccent;
            ctx.fillRect(pixelX - 10, pixelY + 10, 20, 2);

            // Legs (visible below dress)
            ctx.fillStyle = skinTone;
            ctx.fillRect(pixelX - 6, pixelY + 12, 4, 4);
            ctx.fillRect(pixelX + 2, pixelY + 12, 4, 4);

            // Shoes (simple)
            ctx.fillStyle = '#B0B0B0';
            ctx.beginPath();
            ctx.ellipse(pixelX - 4, pixelY + 16, 3, 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(pixelX + 4, pixelY + 16, 3, 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.fillStyle = skinTone;
            ctx.beginPath();
            ctx.arc(pixelX, pixelY - 8, 7, 0, Math.PI * 2);
            ctx.fill();

            // Hair (golden blonde, shoulder-length)
            ctx.fillStyle = hairColor;
            // Top of head
            ctx.beginPath();
            ctx.arc(pixelX, pixelY - 12, 8, Math.PI * 0.75, Math.PI * 2.25);
            ctx.fill();
            // Side hair pieces
            ctx.fillRect(pixelX - 8, pixelY - 12, 3, 6);
            ctx.fillRect(pixelX + 5, pixelY - 12, 3, 6);
            // Soft bangs
            ctx.beginPath();
            ctx.ellipse(pixelX - 3, pixelY - 10, 2.5, 3, 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(pixelX + 1, pixelY - 11, 2.5, 3, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(pixelX + 4, pixelY - 10, 2, 3, -0.3, 0, Math.PI * 2);
            ctx.fill();

            // Eyes (smaller, more subtle)
            ctx.fillStyle = '#5a7a8a'; // Muted blue-grey
            ctx.beginPath();
            ctx.ellipse(pixelX - 3, pixelY - 8, 1.8, 2.2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(pixelX + 3, pixelY - 8, 1.8, 2.2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Pupils
            ctx.fillStyle = '#3d2817';
            ctx.beginPath();
            ctx.arc(pixelX - 3, pixelY - 8, 1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(pixelX + 3, pixelY - 8, 1, 0, Math.PI * 2);
            ctx.fill();

            // Single eye highlight (subtle)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(pixelX - 2.5, pixelY - 8.5, 0.7, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(pixelX + 3.5, pixelY - 8.5, 0.7, 0, Math.PI * 2);
            ctx.fill();

            // Nose (small, subtle)
            ctx.fillStyle = '#d4a574';
            ctx.beginPath();
            ctx.arc(pixelX, pixelY - 6, 1, 0, Math.PI * 2);
            ctx.fill();

            // Mouth (very subtle)
            ctx.strokeStyle = '#3d2817';
            ctx.lineWidth = 0.8;
            ctx.beginPath();
            ctx.arc(pixelX, pixelY - 4, 1.5, 0.4, Math.PI - 0.4);
            ctx.stroke();

            // Subtle cheeks
            ctx.fillStyle = 'rgba(255, 182, 193, 0.25)';
            ctx.beginPath();
            ctx.ellipse(pixelX - 5.5, pixelY - 5, 2, 1.5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(pixelX + 5.5, pixelY - 5, 2, 1.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Arms (coming out from dress)
            ctx.fillStyle = skinTone;
            ctx.beginPath();
            ctx.ellipse(pixelX - 10, pixelY + 2, 2, 5, -0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(pixelX + 10, pixelY + 2, 2, 5, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Hands
            ctx.fillStyle = skinTone;
            ctx.beginPath();
            ctx.arc(pixelX - 11, pixelY + 6, 1.8, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(pixelX + 11, pixelY + 6, 1.8, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // INSERT THE NEW drawSam FUNCTION HERE
        function drawSam(pixelX, pixelY) {
            ctx.save();

            const skinTone = '#ffdbac';
            const hairColor = '#8B6F47'; // Brown
            const vestColor = '#8B7355'; // Brown fishing vest
            const shirtColor = '#E8DCC0'; // Cream/beige shirt
            const pantsColor = '#5C4033'; // Brown pants
            const hatColor = '#7a6e5c'; // Tan/khaki fishing hat

            // Body - side view
            ctx.fillStyle = shirtColor;
            ctx.beginPath();
            ctx.roundRect(pixelX - 5, pixelY - 2, 10, 12, 3);
            ctx.fill();

            // Fishing vest (side view)
            ctx.fillStyle = vestColor;
            ctx.fillRect(pixelX - 5, pixelY - 2, 10, 12);

            // Vest pocket (visible on side)
            ctx.fillStyle = '#6B5A48';
            ctx.fillRect(pixelX - 3, pixelY + 3, 3, 3);

            // Pants (side view, legs stacked)
            ctx.fillStyle = pantsColor;
            ctx.fillRect(pixelX - 4, pixelY + 9, 8, 8);

            // Boot (side view)
            ctx.fillStyle = '#3d3d3d';
            ctx.fillRect(pixelX - 4, pixelY + 15, 8, 3);

            // Head (side profile)
            ctx.fillStyle = skinTone;
            ctx.beginPath();
            ctx.arc(pixelX, pixelY - 9, 7, 0, Math.PI * 2);
            ctx.fill();

            // Fishing hat (side view)
            ctx.fillStyle = hatColor;
            // Hat brim (extends forward)
            ctx.beginPath();
            ctx.ellipse(pixelX + 3, pixelY - 14, 8, 3, 0, 0, Math.PI * 2);
            ctx.fill();
            // Hat crown (side profile)
            ctx.beginPath();
            ctx.arc(pixelX, pixelY - 16, 6, Math.PI * 0.85, Math.PI * 1.5);
            ctx.fill();
            ctx.fillRect(pixelX - 6, pixelY - 16, 6, 3);

            // Hair peeking out (back of head)
            ctx.fillStyle = hairColor;
            ctx.fillRect(pixelX - 7, pixelY - 13, 2, 4);

            // Eye (side view - one eye visible)
            ctx.fillStyle = '#5a4a3a';
            ctx.beginPath();
            ctx.arc(pixelX + 2, pixelY - 9, 2, 0, Math.PI * 2);
            ctx.fill();

            // Eye highlight
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(pixelX + 2.5, pixelY - 9.5, 0.8, 0, Math.PI * 2);
            ctx.fill();

            // Nose (side profile)
            ctx.fillStyle = '#d4a574';
            ctx.beginPath();
            ctx.moveTo(pixelX + 5, pixelY - 8);
            ctx.lineTo(pixelX + 7, pixelY - 7);
            ctx.lineTo(pixelX + 5, pixelY - 6);
            ctx.fill();

            // Mouth (side view smile)
            ctx.strokeStyle = '#3d2817';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(pixelX + 5, pixelY - 5);
            ctx.quadraticCurveTo(pixelX + 6, pixelY - 4, pixelX + 7, pixelY - 5);
            ctx.stroke();

            // Rosy cheek (side view)
            ctx.fillStyle = 'rgba(255, 140, 105, 0.3)';
            ctx.beginPath();
            ctx.ellipse(pixelX + 4, pixelY - 6, 2.5, 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Beard/stubble (side profile)
            ctx.fillStyle = 'rgba(139, 111, 71, 0.3)';
            ctx.beginPath();
            ctx.arc(pixelX + 4, pixelY - 4, 3, 0.3, Math.PI * 0.6);
            ctx.fill();

            // Front arm (reaching forward slightly)
            ctx.fillStyle = shirtColor;
            ctx.beginPath();
            ctx.ellipse(pixelX + 7, pixelY + 2, 2, 5, 0.4, 0, Math.PI * 2);
            ctx.fill();

            // Front hand/forearm
            ctx.fillStyle = skinTone;
            ctx.beginPath();
            ctx.ellipse(pixelX + 9, pixelY + 5, 2, 3, 0.4, 0, Math.PI * 2);
            ctx.fill();

            // Back arm (less visible)
            ctx.fillStyle = vestColor;
            ctx.fillRect(pixelX - 7, pixelY, 2, 6);

            // Fishing rod (held or leaning - behind character)
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(pixelX - 10, pixelY + 8);
            ctx.lineTo(pixelX - 12, pixelY - 12);
            ctx.stroke();

            // Fishing line
            ctx.strokeStyle = '#E0E0E0';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(pixelX - 12, pixelY - 12);
            ctx.lineTo(pixelX - 13, pixelY - 6);
            ctx.stroke();

            // Hook
            ctx.strokeStyle = '#C0C0C0';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(pixelX - 13, pixelY - 5, 1, Math.PI, Math.PI * 2);
            ctx.stroke();

            // Tackle box on belt (back side visible)
            ctx.fillStyle = '#6B8E23';
            ctx.fillRect(pixelX - 6, pixelY + 8, 4, 4);

            // Bag detail
            ctx.strokeStyle = '#556B2F';
            ctx.lineWidth = 0.8;
            ctx.strokeRect(pixelX - 6, pixelY + 8, 4, 4);

            ctx.restore();
        }

        function drawSparkles(x, y, time) {
            const sparkleCount = 8;
            for (let i = 0; i < sparkleCount; i++) {
                const angle = (i / sparkleCount) * Math.PI * 2 + time * 0.1;
                const distance = 10 + Math.sin(time * 0.05 + i) * 5;
                const sparkleX = x + Math.cos(angle) * distance;
                const sparkleY = y + Math.sin(angle) * distance;
                
                ctx.fillStyle = `rgba(255, ${150 + Math.sin(time * 0.1 + i) * 50}, 0, ${0.7 + Math.sin(time * 0.15 + i) * 0.3})`;
                ctx.beginPath();
                ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawWaterSparkles(x, y, time, gridX, gridY) {
            const seed = gridX * 1000 + gridY;
            const sparkleCount = 4;
            
            for (let i = 0; i < sparkleCount; i++) {
                const seedOffset = seed + i * 123;
                const pseudoRandom1 = (seedOffset % 1000) / 1000;
                const pseudoRandom2 = ((seedOffset + 456) % 1000) / 1000;
                
                const angle = pseudoRandom1 * Math.PI * 2 + time * 0.002;
                const distance = pseudoRandom2 * 15;
                const sparkleX = x + Math.cos(angle) * distance;
                const sparkleY = y + Math.sin(angle) * distance;
                
                const opacity = 0.3 + Math.sin(time * 0.003 + pseudoRandom1 * Math.PI * 2) * 0.2;
                ctx.fillStyle = `rgba(173, 216, 230, ${opacity})`;
                ctx.beginPath();
                ctx.arc(sparkleX, sparkleY, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawGame() {
            ctx.fillStyle = '#0f1f0c';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = '#1a2817';
            ctx.lineWidth = 1;
            for (let x = 0; x <= GRID_WIDTH; x++) {
                ctx.beginPath();
                ctx.moveTo(x * GRID_SIZE, 0);
                ctx.lineTo(x * GRID_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= GRID_HEIGHT; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * GRID_SIZE);
                ctx.lineTo(canvas.width, y * GRID_SIZE);
                ctx.stroke();
            }

            if (myZone === 1) {
                // Draw grass across the entire town zone with vertical symmetry
                const midY = Math.floor(GRID_HEIGHT / 2);

                for (let x = 0; x < GRID_WIDTH; x++) {
                    for (let y = 0; y < GRID_HEIGHT; y++) {
                        // Use mirrored Y coordinate for color/seed, but draw at actual position
                        const mirroredY = y > midY ? (GRID_HEIGHT - 1 - y) : y;

                        const pixel = gridToPixel(x, y);
                        const seed = x * 1000 + mirroredY;

                        const grassHue = 70 + (seed % 20);
                        ctx.fillStyle = `hsl(${grassHue}, 40%, ${25 + (seed % 10)}%)`;
                        ctx.fillRect(pixel.x - GRID_SIZE/2, pixel.y - GRID_SIZE/2, GRID_SIZE, GRID_SIZE);

                        // Draw grass blades
                        for (let i = 0; i < 5; i++) {
                            const pr1 = (seed + i * 123) % 1000 / 1000;
                            const pr2 = (seed + i * 456) % 1000 / 1000;

                            const bladeX = pixel.x + (pr1 - 0.5) * GRID_SIZE * 0.8;
                            const bladeY = pixel.y + (pr2 - 0.5) * GRID_SIZE * 0.8;
                            const bladeHeight = 3 + pr1 * 4;

                            ctx.strokeStyle = `rgba(${50 + pr1 * 30}, ${100 + pr2 * 40}, 50, 0.6)`;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(bladeX, bladeY);
                            ctx.quadraticCurveTo(
                                bladeX + (pr2 - 0.5) * 2,
                                bladeY - bladeHeight/2,
                                bladeX + (pr1 - 0.5) * 3,
                                bladeY - bladeHeight
                            );
                            ctx.stroke();
                        }
                    }
                }

            // Draw flower garden patches around butterflies (4 vertical lines)
                const flowerGardens = [];
                
                // Inner-left line: 6,8 to 6,12
                for (let y = 9; y <= 11; y++) {
                    flowerGardens.push({ x: 6, y: y });
                }
                
                // Inner-right line: 7,8 to 7,12
                for (let y = 9; y <= 11; y++) {
                    flowerGardens.push({ x: 7, y: y });
                }
                
                flowerGardens.forEach(garden => {
                    const pixel = gridToPixel(garden.x, garden.y);
                    const seed = garden.x * 1000 + garden.y;
                    
                    // Draw softer soil base
                    const soilHue = 35 + (seed % 10);
                    ctx.fillStyle = `hsl(${soilHue}, 25%, 35%)`;
                    
                    // Draw with rounded edges
                    ctx.beginPath();
                    ctx.roundRect(pixel.x - GRID_SIZE/2, pixel.y - GRID_SIZE/2, GRID_SIZE, GRID_SIZE, 6);
                    ctx.fill();
                    
                    // Draw larger, clearer flowers (2-3 per tile)
                    const flowerCount = 2 + (seed % 2);
                    for (let i = 0; i < flowerCount; i++) {
                        const pr1 = (seed + i * 789) % 1000 / 1000;
                        const pr2 = (seed + i * 321) % 1000 / 1000;
                        
                        const flowerX = pixel.x + (pr1 - 0.5) * GRID_SIZE * 0.6;
                        const flowerY = pixel.y + (pr2 - 0.5) * GRID_SIZE * 0.6;
                        
                        // Brighter flower colors
                        const flowerColors = ['#FF1493', '#FFD700', '#FF69B4', '#FF6347', '#00CED1'];
                        const flowerColor = flowerColors[(seed + i) % flowerColors.length];
                        
                        // Draw green stem
                        ctx.strokeStyle = '#4a7c2f';
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.moveTo(flowerX, flowerY + 4);
                        ctx.lineTo(flowerX, flowerY);
                        ctx.stroke();
                        
                        // Draw larger flower head with 6 petals
                        for (let p = 0; p < 6; p++) {
                            const angle = (p / 6) * Math.PI * 2;
                            const petalX = flowerX + Math.cos(angle) * 3.5;
                            const petalY = flowerY + Math.sin(angle) * 3.5;
                            
                            ctx.fillStyle = flowerColor;
                            ctx.beginPath();
                            ctx.arc(petalX, petalY, 2.5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // Draw bright yellow center
                        ctx.fillStyle = '#FFF700';
                        ctx.beginPath();
                        ctx.arc(flowerX, flowerY, 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add white highlight to center
                        ctx.fillStyle = '#FFFFFF';
                        ctx.beginPath();
                        ctx.arc(flowerX - 0.5, flowerY - 0.5, 0.8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });

                // Town Crier with shadow
                const npcPixel = gridToPixel(npc.x, npc.y);
                drawCharacterShadow(npcPixel.x, npcPixel.y, 12);
                drawTownCrier(npcPixel.x, npcPixel.y);

                // Sky NPC with shadow
                const skyNPCPixel = gridToPixel(skyNPC.x, skyNPC.y);
                drawCharacterShadow(skyNPCPixel.x, skyNPCPixel.y, 11);
                drawSky(skyNPCPixel.x, skyNPCPixel.y);

                // Only draw quest marker if quest not completed
                if (!skyQuestCompleted) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.beginPath();
                    ctx.arc(skyNPCPixel.x, skyNPCPixel.y - 35, 12, 0, Math.PI * 2);
                    ctx.fill();

                    // Red exclamation mark
                    ctx.fillStyle = '#FF0000';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('!', skyNPCPixel.x, skyNPCPixel.y - 26);
                }

                // NEW: Draw animated butterflies in Town Zone
                const currentTime = Date.now();
                townButterflies.forEach(butterfly => {
                    butterfly.time += 0.02;
                    butterfly.offsetX = Math.sin(butterfly.time) * 8;
                    butterfly.offsetY = Math.cos(butterfly.time * 0.7) * 5;
                    
                    const butterflyPixel = gridToPixel(butterfly.x, butterfly.y);
                    const finalX = butterflyPixel.x + butterfly.offsetX;
                    const finalY = butterflyPixel.y + butterfly.offsetY;
                    
                    drawButterfly(finalX, finalY, currentTime * 0.001);
                });
                
                // Draw merchant cat with shadow
                const merchantPixel = gridToPixel(merchant.x, merchant.y);
                drawCharacterShadow(merchantPixel.x, merchantPixel.y, 13);
                drawMerchantCat(merchantPixel.x, merchantPixel.y);
                
                // Trees
                trees.forEach(tree => {
                    if (!tree.chopped) {
                        const treePixel = gridToPixel(tree.x, tree.y);

                        // Calculate sway based on time and tree position (each tree sways slightly differently)
                        const sway = Math.sin(currentTime * 0.001 + tree.x * 0.5 + tree.y * 0.3) * 2;

                        // Draw trunk with slight bend at the top
                        ctx.fillStyle = '#8B4513';
                        ctx.save();

                        // Trunk bends less than leaves (more realistic)
                        const trunkBend = sway * 0.3; // 30% of leaf sway

                        // Draw trunk as slightly curved trapezoid
                        ctx.beginPath();
                        ctx.moveTo(treePixel.x - 6, treePixel.y + 15); // Bottom left (no bend)
                        ctx.lineTo(treePixel.x + 6, treePixel.y + 15); // Bottom right (no bend)
                        ctx.lineTo(treePixel.x + 6 + trunkBend, treePixel.y - 5); // Top right (with bend)
                        ctx.lineTo(treePixel.x - 6 + trunkBend, treePixel.y - 5); // Top left (with bend)
                        ctx.closePath();
                        ctx.fill();

                        ctx.restore();

                        // Save context and apply sway transformation to leaves
                        ctx.save();
                        ctx.translate(sway, 0); // Apply horizontal sway

                        // Draw leaves with sway
                        ctx.fillStyle = '#228B22';
                        ctx.beginPath();
                        ctx.arc(treePixel.x, treePixel.y - 15, 18, 0, Math.PI * 2);
                        ctx.fill();

                        // Draw inner leaves (lighter) with same sway
                        ctx.fillStyle = '#32CD32';
                        ctx.beginPath();
                        ctx.arc(treePixel.x - 4, treePixel.y - 18, 12, 0, Math.PI * 2);
                        ctx.fill();

                        // Restore context (removes sway transformation)
                        ctx.restore();
                    } else {
                        // Draw tree stump
                        const treePixel = gridToPixel(tree.x, tree.y);
                        ctx.fillStyle = '#654321';
                        ctx.fillRect(treePixel.x - 8, treePixel.y + 5, 16, 8);
                        
                        // Draw rings on stump
                        ctx.strokeStyle = '#8B4513';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(treePixel.x, treePixel.y + 9, 5, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(treePixel.x, treePixel.y + 9, 3, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                });
            }

            if (myZone === 3) {
                // Draw grass across the entire lake zone with vertical symmetry
                const midY = Math.floor(GRID_HEIGHT / 2);

                for (let x = 0; x < GRID_WIDTH; x++) {
                    for (let y = 0; y < GRID_HEIGHT; y++) {
                        // Skip water tiles
                        if (x >= LAKE_MIN_X && x <= LAKE_MAX_X &&
                            y >= LAKE_MIN_Y && y <= LAKE_MAX_Y) {
                            continue;
                        }

                        // Use mirrored Y coordinate for color/seed, but draw at actual position
                        const mirroredY = y > midY ? (GRID_HEIGHT - 1 - y) : y;

                        const pixel = gridToPixel(x, y);
                        const seed = x * 1000 + mirroredY;

                        // Check if this is part of Sam's darker grass patch
                        const isSamArea = (x >= 15 && x <= 17 && y >= 8 && y <= 10);

                        const grassHue = 70 + (seed % 20);
                        const grassLightness = isSamArea ? (20 + (seed % 8)) : (25 + (seed % 10)); // Darker around Sam
                        ctx.fillStyle = `hsl(${grassHue}, 40%, ${grassLightness}%)`;
                        ctx.fillRect(pixel.x - GRID_SIZE/2, pixel.y - GRID_SIZE/2, GRID_SIZE, GRID_SIZE);

                        // Draw grass blades
                        for (let i = 0; i < 5; i++) {
                            const pr1 = (seed + i * 123) % 1000 / 1000;
                            const pr2 = (seed + i * 456) % 1000 / 1000;

                            const bladeX = pixel.x + (pr1 - 0.5) * GRID_SIZE * 0.8;
                            const bladeY = pixel.y + (pr2 - 0.5) * GRID_SIZE * 0.8;
                            const bladeHeight = 3 + pr1 * 4;

                            ctx.strokeStyle = `rgba(${50 + pr1 * 30}, ${100 + pr2 * 40}, 50, 0.6)`;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(bladeX, bladeY);
                            ctx.quadraticCurveTo(
                                bladeX + (pr2 - 0.5) * 2,
                                bladeY - bladeHeight/2,
                                bladeX + (pr1 - 0.5) * 3,
                                bladeY - bladeHeight
                            );
                            ctx.stroke();
                        }
                    }
                }
                
            // Draw flower garden patches (natural flower beds)
                const flowerGardens = [
                    { x: 4, y: 6 }, { x: 4, y: 7 }, { x: 4, y: 8 },
                    { x: 2, y: 6 }, { x: 2, y: 7 }, { x: 2, y: 8 }
                ];
                
                flowerGardens.forEach(garden => {
                    const pixel = gridToPixel(garden.x, garden.y);
                    const seed = garden.x * 1000 + garden.y;
                    
                    // Draw softer soil base (less contrasting brown)
                    const soilHue = 35 + (seed % 10);
                    ctx.fillStyle = `hsl(${soilHue}, 25%, 35%)`; // Lighter, less saturated brown
                    
                    // Draw with rounded edges
                    ctx.beginPath();
                    ctx.roundRect(pixel.x - GRID_SIZE/2, pixel.y - GRID_SIZE/2, GRID_SIZE, GRID_SIZE, 6);
                    ctx.fill();
                    
                    // Draw larger, clearer flowers (2-3 per tile)
                    const flowerCount = 2 + (seed % 2);
                    for (let i = 0; i < flowerCount; i++) {
                        const pr1 = (seed + i * 789) % 1000 / 1000;
                        const pr2 = (seed + i * 321) % 1000 / 1000;
                        
                        const flowerX = pixel.x + (pr1 - 0.5) * GRID_SIZE * 0.6;
                        const flowerY = pixel.y + (pr2 - 0.5) * GRID_SIZE * 0.6;
                        
                        // Brighter flower colors
                        const flowerColors = ['#FF1493', '#FFD700', '#FF69B4', '#FF6347', '#00CED1'];
                        const flowerColor = flowerColors[(seed + i) % flowerColors.length];
                        
                        // Draw green stem
                        ctx.strokeStyle = '#4a7c2f';
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.moveTo(flowerX, flowerY + 4);
                        ctx.lineTo(flowerX, flowerY);
                        ctx.stroke();
                        
                        // Draw larger flower head with 6 petals
                        for (let p = 0; p < 6; p++) {
                            const angle = (p / 6) * Math.PI * 2;
                            const petalX = flowerX + Math.cos(angle) * 3.5;
                            const petalY = flowerY + Math.sin(angle) * 3.5;
                            
                            ctx.fillStyle = flowerColor;
                            ctx.beginPath();
                            ctx.arc(petalX, petalY, 2.5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // Draw bright yellow center
                        ctx.fillStyle = '#FFF700';
                        ctx.beginPath();
                        ctx.arc(flowerX, flowerY, 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add white highlight to center
                        ctx.fillStyle = '#FFFFFF';
                        ctx.beginPath();
                        ctx.arc(flowerX - 0.5, flowerY - 0.5, 0.8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });

                // Now draw the water with enhanced animations
                const currentTime = Date.now();
                for (let x = LAKE_MIN_X; x <= LAKE_MAX_X; x++) {
                    for (let y = LAKE_MIN_Y; y <= LAKE_MAX_Y; y++) {
                        drawWaterTile(x, y, currentTime);

                        const pixel = gridToPixel(x, y);
                        drawWaterSparkles(pixel.x, pixel.y, currentTime, x, y);
                    }
                }
                
                // Draw fireplace
                const fireplacePixel = gridToPixel(fireplace.x, fireplace.y);
                
                // Draw base stones
                ctx.fillStyle = '#666';
                ctx.fillRect(fireplacePixel.x - 15, fireplacePixel.y - 5, 30, 20);
                
                // Draw fire
                const fireFlicker = Math.sin(currentTime * 0.01) * 3;
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.moveTo(fireplacePixel.x - 10, fireplacePixel.y + 10);
                ctx.lineTo(fireplacePixel.x - 5, fireplacePixel.y - 10 + fireFlicker);
                ctx.lineTo(fireplacePixel.x, fireplacePixel.y - 15 + fireFlicker);
                ctx.lineTo(fireplacePixel.x + 5, fireplacePixel.y - 10 + fireFlicker);
                ctx.lineTo(fireplacePixel.x + 10, fireplacePixel.y + 10);
                ctx.fill();
                
                // Draw inner flame
                ctx.fillStyle = '#ffaa00';
                ctx.beginPath();
                ctx.moveTo(fireplacePixel.x - 7, fireplacePixel.y + 5);
                ctx.lineTo(fireplacePixel.x - 3, fireplacePixel.y - 5 + fireFlicker);
                ctx.lineTo(fireplacePixel.x, fireplacePixel.y - 8 + fireFlicker);
                ctx.lineTo(fireplacePixel.x + 3, fireplacePixel.y - 5 + fireFlicker);
                ctx.lineTo(fireplacePixel.x + 7, fireplacePixel.y + 5);
                ctx.fill();
                
                // Draw sparks
                for (let i = 0; i < 5; i++) {
                    const sparkX = fireplacePixel.x + (Math.sin(currentTime * 0.005 + i) * 8);
                    const sparkY = fireplacePixel.y - 20 + (Math.cos(currentTime * 0.007 + i) * 5);
                    ctx.fillStyle = `rgba(255, ${100 + i * 30}, 0, ${0.6 + Math.sin(currentTime * 0.01 + i) * 0.4})`;
                    ctx.beginPath();
                    ctx.arc(sparkX, sparkY, 1, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Add particle effects
                drawFireParticles(fireplacePixel.x, fireplacePixel.y - 15, currentTime);
                
                // Draw quest NPC (Sam) with shadow
                const questNPCPixel = gridToPixel(questNPC.x, questNPC.y);
                drawCharacterShadow(questNPCPixel.x, questNPCPixel.y, 10);
                drawSam(questNPCPixel.x, questNPCPixel.y);
                
                // Draw permanent cooking animation above quest NPC (Sam)
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.arc(questNPCPixel.x, questNPCPixel.y - 35, 12, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#ff6600';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üî•', questNPCPixel.x, questNPCPixel.y - 28);
            }

            // Draw player-created campfires in ALL zones
            playerCampfires.forEach(campfire => {
                if (campfire.zone === myZone) {
                    const campfirePixel = gridToPixel(campfire.x, campfire.y);
                    const currentTime = Date.now();
                    
                    // Draw base stones
                    ctx.fillStyle = '#666';
                    ctx.fillRect(campfirePixel.x - 12, campfirePixel.y - 3, 24, 16);
                    
                    // Draw fire with flicker animation
                    const fireFlicker = Math.sin(currentTime * 0.01 + campfire.x + campfire.y) * 3;
                    ctx.fillStyle = '#ff6600';
                    ctx.beginPath();
                    ctx.moveTo(campfirePixel.x - 8, campfirePixel.y + 8);
                    ctx.lineTo(campfirePixel.x - 4, campfirePixel.y - 8 + fireFlicker);
                    ctx.lineTo(campfirePixel.x, campfirePixel.y - 12 + fireFlicker);
                    ctx.lineTo(campfirePixel.x + 4, campfirePixel.y - 8 + fireFlicker);
                    ctx.lineTo(campfirePixel.x + 8, campfirePixel.y + 8);
                    ctx.fill();
                    
                    // Draw inner flame
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.moveTo(campfirePixel.x - 5, campfirePixel.y + 3);
                    ctx.lineTo(campfirePixel.x - 2, campfirePixel.y - 3 + fireFlicker);
                    ctx.lineTo(campfirePixel.x, campfirePixel.y - 6 + fireFlicker);
                    ctx.lineTo(campfirePixel.x + 2, campfirePixel.y - 3 + fireFlicker);
                    ctx.lineTo(campfirePixel.x + 5, campfirePixel.y + 3);
                    ctx.fill();
                    
                    // Draw sparks
                    for (let i = 0; i < 3; i++) {
                        const sparkX = campfirePixel.x + (Math.sin(currentTime * 0.005 + i + campfire.x) * 6);
                        const sparkY = campfirePixel.y - 15 + (Math.cos(currentTime * 0.007 + i + campfire.y) * 4);
                        ctx.fillStyle = `rgba(255, ${100 + i * 40}, 0, ${0.6 + Math.sin(currentTime * 0.01 + i) * 0.4})`;
                        ctx.beginPath();
                        ctx.arc(sparkX, sparkY, 1, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Add particle effects
                    drawFireParticles(campfirePixel.x, campfirePixel.y - 12, currentTime);
                }
            });
            
            function drawEnhancedGrass(x, y, gridSize) {
                const pixel = gridToPixel(x, y);
                const seed = x * 1000 + y;

                // Base grass tile with subtle color variation
                const grassHue = 70 + (seed % 20);
                ctx.fillStyle = `hsl(${grassHue}, 40%, ${25 + (seed % 10)}%)`;
                ctx.fillRect(pixel.x - gridSize/2, pixel.y - gridSize/2, gridSize, gridSize);

                // Individual grass blades (4-6 per tile)
                for (let i = 0; i < 5; i++) {
                    const pr1 = (seed + i * 123) % 1000 / 1000;
                    const pr2 = (seed + i * 456) % 1000 / 1000;

                    const bladeX = pixel.x + (pr1 - 0.5) * gridSize * 0.8;
                    const bladeY = pixel.y + (pr2 - 0.5) * gridSize * 0.8;
                    const bladeHeight = 3 + pr1 * 4;

                    // Draw grass blade as thin vertical line with slight curve
                    ctx.strokeStyle = `rgba(${50 + pr1 * 30}, ${100 + pr2 * 40}, 50, 0.6)`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(bladeX, bladeY);
                    ctx.quadraticCurveTo(
                        bladeX + (pr2 - 0.5) * 2,
                        bladeY - bladeHeight/2,
                        bladeX + (pr1 - 0.5) * 3,
                        bladeY - bladeHeight
                    );
                    ctx.stroke();
                }
            }

            if (myZone === 2) {
                // Draw grass with vertical symmetry to avoid dark bottom half
                const midY = Math.floor(GRID_HEIGHT / 2);
                
                for (let x = 0; x < GRID_WIDTH; x++) {
                    for (let y = 0; y < GRID_HEIGHT; y++) {
                        // Use mirrored Y coordinate for color/seed, but draw at actual position
                        const mirroredY = y > midY ? (GRID_HEIGHT - 1 - y) : y;

                        const pixel = gridToPixel(x, y);
                        const seed = x * 1000 + mirroredY;

                        // Check if this tile is inside the fence (hay area)
                        const fenceMinX = Math.floor(GRID_WIDTH * 0.3) - 1;
                        const fenceMaxX = Math.floor(GRID_WIDTH * 0.7) + 1;
                        const fenceMinY = Math.floor(GRID_HEIGHT * 0.3) - 1;
                        const fenceMaxY = Math.floor(GRID_HEIGHT * 0.7) + 1;

                        // Hay area: inside the fenced area
                        const isHayArea = (x > fenceMinX && x < fenceMaxX && y > fenceMinY && y < fenceMaxY);

                        let grassHue, saturation, lightness;
                        if (isHayArea) {
                            // Golden hay colors
                            grassHue = 45 + (seed % 15); // Yellow-gold range (45-60)
                            saturation = 60 + (seed % 20); // More saturated
                            lightness = 55 + (seed % 15); // Brighter
                        } else {
                            // Normal grass
                            grassHue = 70 + (seed % 20);
                            saturation = 40;
                            lightness = 25 + (seed % 10);
                        }

                        ctx.fillStyle = `hsl(${grassHue}, ${saturation}%, ${lightness}%)`;
                        ctx.fillRect(pixel.x - GRID_SIZE/2, pixel.y - GRID_SIZE/2, GRID_SIZE, GRID_SIZE);
                        
                        // Draw grass blades
                        for (let i = 0; i < 5; i++) {
                            const pr1 = (seed + i * 123) % 1000 / 1000;
                            const pr2 = (seed + i * 456) % 1000 / 1000;
                            
                            const bladeX = pixel.x + (pr1 - 0.5) * GRID_SIZE * 0.8;
                            const bladeY = pixel.y + (pr2 - 0.5) * GRID_SIZE * 0.8;
                            const bladeHeight = 3 + pr1 * 4;
                            
                            ctx.strokeStyle = `rgba(${50 + pr1 * 30}, ${100 + pr2 * 40}, 50, 0.6)`;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(bladeX, bladeY);
                            ctx.quadraticCurveTo(
                                bladeX + (pr2 - 0.5) * 2,
                                bladeY - bladeHeight/2,
                                bladeX + (pr1 - 0.5) * 3,
                                bladeY - bladeHeight
                            );
                            ctx.stroke();
                        }
                    }
                }
                
                // Then draw the fence on top
                const fenceMinX = Math.floor(GRID_WIDTH * 0.3) - 1;
                const fenceMaxX = Math.floor(GRID_WIDTH * 0.7) + 1;
                const fenceMinY = Math.floor(GRID_HEIGHT * 0.3) - 1;
                const fenceMaxY = Math.floor(GRID_HEIGHT * 0.7) + 1;
                
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 3;
                
                for (let x = fenceMinX; x <= fenceMaxX; x++) {
                    const topPixel = gridToPixel(x, fenceMinY);
                    ctx.beginPath();
                    ctx.moveTo(topPixel.x, topPixel.y - GRID_SIZE/2);
                    ctx.lineTo(topPixel.x, topPixel.y + GRID_SIZE/2);
                    ctx.stroke();
                    
                    const bottomPixel = gridToPixel(x, fenceMaxY);
                    ctx.beginPath();
                    ctx.moveTo(bottomPixel.x, bottomPixel.y - GRID_SIZE/2);
                    ctx.lineTo(bottomPixel.x, bottomPixel.y + GRID_SIZE/2);
                    ctx.stroke();
                }
                
                for (let y = fenceMinY; y <= fenceMaxY; y++) {
                    const leftPixel = gridToPixel(fenceMinX, y);
                    ctx.beginPath();
                    ctx.moveTo(leftPixel.x - GRID_SIZE/2, leftPixel.y);
                    ctx.lineTo(leftPixel.x + GRID_SIZE/2, leftPixel.y);
                    ctx.stroke();
                    
                    const rightPixel = gridToPixel(fenceMaxX, y);
                    ctx.beginPath();
                    ctx.moveTo(rightPixel.x - GRID_SIZE/2, rightPixel.y);
                    ctx.lineTo(rightPixel.x + GRID_SIZE/2, rightPixel.y);
                    ctx.stroke();
                }
            }

            if (myZone === 4) {
                // Draw darker grass across the entire forest zone with vertical symmetry
                const midY = Math.floor(GRID_HEIGHT / 2);

                for (let x = 0; x < GRID_WIDTH; x++) {
                    for (let y = 0; y < GRID_HEIGHT; y++) {
                        // Use mirrored Y coordinate for color/seed, but draw at actual position
                        const mirroredY = y > midY ? (GRID_HEIGHT - 1 - y) : y;

                        const pixel = gridToPixel(x, y);
                        const seed = x * 1000 + mirroredY;

                        // Darker forest grass
                        const grassHue = 65 + (seed % 15);
                        const grassLightness = 18 + (seed % 8);
                        ctx.fillStyle = `hsl(${grassHue}, 45%, ${grassLightness}%)`;
                        ctx.fillRect(pixel.x - GRID_SIZE/2, pixel.y - GRID_SIZE/2, GRID_SIZE, GRID_SIZE);

                        // Draw grass blades
                        for (let i = 0; i < 5; i++) {
                            const pr1 = (seed + i * 123) % 1000 / 1000;
                            const pr2 = (seed + i * 456) % 1000 / 1000;

                            const bladeX = pixel.x + (pr1 - 0.5) * GRID_SIZE * 0.8;
                            const bladeY = pixel.y + (pr2 - 0.5) * GRID_SIZE * 0.8;
                            const bladeHeight = 3 + pr1 * 4;

                            ctx.strokeStyle = `rgba(${35 + pr1 * 25}, ${70 + pr2 * 30}, 35, 0.6)`;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(bladeX, bladeY);
                            ctx.quadraticCurveTo(
                                bladeX + (pr2 - 0.5) * 2,
                                bladeY - bladeHeight/2,
                                bladeX + (pr1 - 0.5) * 3,
                                bladeY - bladeHeight
                            );
                            ctx.stroke();
                        }
                    }
                }

                // Draw mound/hill around cave entrance with flat bottom and rounded top
                const caveMoundPixel = gridToPixel(caveEntrance.x, caveEntrance.y);
                // Offset the mound center upward so the flat bottom sits at (x, 6) - below the entrance
                const moundCenterY = caveMoundPixel.y + GRID_SIZE * 0.5;

                // Draw soft semi-circular mound base (flat bottom, rounded top)
                for (let radius = 2.5; radius > 0; radius -= 0.3) {
                    const heightFactor = (2.5 - radius) / 2.5; // 0 at edge, 1 at center

                    // Earth color that gets slightly darker toward center
                    const lightness = 35 + (radius / 2.5) * 10;
                    ctx.fillStyle = `hsl(80, 20%, ${lightness}%)`;

                    ctx.beginPath();
                    // Draw arc only on top half (from PI to 2*PI = bottom-left to bottom-right)
                    ctx.arc(caveMoundPixel.x, moundCenterY, radius * GRID_SIZE * 0.45, Math.PI, 2 * Math.PI);
                    // Close the path with a straight line at the bottom
                    ctx.lineTo(caveMoundPixel.x + radius * GRID_SIZE * 0.45, moundCenterY);
                    ctx.lineTo(caveMoundPixel.x - radius * GRID_SIZE * 0.45, moundCenterY);
                    ctx.closePath();
                    ctx.fill();
                }

                // Add highlight on top of mound (lighting from above)
                const highlightGradient = ctx.createRadialGradient(
                    caveMoundPixel.x,
                    moundCenterY - GRID_SIZE * 0.3,
                    0,
                    caveMoundPixel.x,
                    moundCenterY,
                    GRID_SIZE * 1.2
                );
                highlightGradient.addColorStop(0, 'rgba(140, 160, 100, 0.3)');
                highlightGradient.addColorStop(0.5, 'rgba(140, 160, 100, 0.1)');
                highlightGradient.addColorStop(1, 'rgba(140, 160, 100, 0)');
                ctx.fillStyle = highlightGradient;
                ctx.beginPath();
                // Clip highlight to top half only
                ctx.arc(caveMoundPixel.x, moundCenterY, GRID_SIZE * 1.2, Math.PI, 2 * Math.PI);
                ctx.lineTo(caveMoundPixel.x + GRID_SIZE * 1.2, moundCenterY);
                ctx.lineTo(caveMoundPixel.x - GRID_SIZE * 1.2, moundCenterY);
                ctx.closePath();
                ctx.fill();

                // Add shadow on bottom of mound (depth effect) - only on the flat bottom edge
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(
                    caveMoundPixel.x - GRID_SIZE * 1.1,
                    moundCenterY - 2,
                    GRID_SIZE * 2.2,
                    4
                );

                // Add static grass details using seed-based positioning (won't sparkle/change)
                // Only place grass on the top half of the mound
                const staticGrassPositions = [
                    { x: -0.6, y: -0.4 }, { x: -0.3, y: -0.6 }, { x: 0.2, y: -0.5 },
                    { x: 0.5, y: -0.3 }, { x: -0.7, y: -0.1 }, { x: -0.4, y: -0.2 },
                    { x: 0.3, y: -0.3 }, { x: 0.6, y: -0.2 }, { x: -0.2, y: -0.7 },
                    { x: 0.1, y: -0.7 }, { x: -0.5, y: -0.5 }, { x: 0.4, y: -0.6 }
                ];

                staticGrassPositions.forEach((pos, index) => {
                    const grassX = caveMoundPixel.x + pos.x * GRID_SIZE;
                    const grassY = moundCenterY + pos.y * GRID_SIZE;
                    
                    // Use index for consistent but varied grass appearance
                    const bladeLength = 3 + (index % 3);
                    const bladeAngle = (index % 5) * 0.3 - 0.6;
                    
                    ctx.strokeStyle = `rgba(${70 + (index % 30)}, ${100 + (index % 40)}, 50, 0.5)`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(grassX, grassY);
                    ctx.quadraticCurveTo(
                        grassX + bladeAngle * 2,
                        grassY - bladeLength / 2,
                        grassX + bladeAngle * 3,
                        grassY - bladeLength
                    );
                    ctx.stroke();
                });

                // Add static small rocks on the mound (only on top half)
                const staticRockPositions = [
                    { x: -0.4, y: -0.3, size: 2 },
                    { x: 0.3, y: -0.4, size: 1.5 },
                    { x: -0.5, y: -0.2, size: 2.5 },
                    { x: 0.4, y: -0.3, size: 1.8 },
                    { x: 0.0, y: -0.6, size: 1.2 },
                    { x: -0.2, y: -0.5, size: 2.2 }
                ];

                staticRockPositions.forEach(rock => {
                    const rockX = caveMoundPixel.x + rock.x * GRID_SIZE;
                    const rockY = moundCenterY + rock.y * GRID_SIZE;
                    
                    ctx.fillStyle = '#6a6a5a';
                    ctx.beginPath();
                    ctx.arc(rockX, rockY, rock.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add tiny highlight on rocks
                    ctx.fillStyle = 'rgba(120, 120, 110, 0.4)';
                    ctx.beginPath();
                    ctx.arc(rockX - 0.5, rockY - 0.5, rock.size * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Draw cave entrance as rocky doorway
                const cavePixel = gridToPixel(caveEntrance.x, caveEntrance.y);

                // Draw rocky archway/doorframe
                ctx.fillStyle = '#5a5a5a'; // Medium grey rock
                ctx.beginPath();
                // Left pillar
                ctx.fillRect(cavePixel.x - GRID_SIZE * 0.6, cavePixel.y - GRID_SIZE * 0.3, GRID_SIZE * 0.3, GRID_SIZE * 0.8);
                // Right pillar
                ctx.fillRect(cavePixel.x + GRID_SIZE * 0.3, cavePixel.y - GRID_SIZE * 0.3, GRID_SIZE * 0.3, GRID_SIZE * 0.8);
                // Top arch stone
                ctx.fillRect(cavePixel.x - GRID_SIZE * 0.6, cavePixel.y - GRID_SIZE * 0.3, GRID_SIZE * 1.2, GRID_SIZE * 0.25);

                // Add darker rock shading for depth
                ctx.fillStyle = '#3a3a3a';
                // Left pillar shadow
                ctx.fillRect(cavePixel.x - GRID_SIZE * 0.35, cavePixel.y - GRID_SIZE * 0.3, GRID_SIZE * 0.05, GRID_SIZE * 0.8);
                // Right pillar shadow
                ctx.fillRect(cavePixel.x + GRID_SIZE * 0.3, cavePixel.y - GRID_SIZE * 0.3, GRID_SIZE * 0.05, GRID_SIZE * 0.8);

                // Add lighter rock highlights
                ctx.fillStyle = '#7a7a7a';
                // Left pillar highlight
                ctx.fillRect(cavePixel.x - GRID_SIZE * 0.6, cavePixel.y - GRID_SIZE * 0.3, GRID_SIZE * 0.05, GRID_SIZE * 0.8);
                // Right pillar highlight
                ctx.fillRect(cavePixel.x + GRID_SIZE * 0.55, cavePixel.y - GRID_SIZE * 0.3, GRID_SIZE * 0.05, GRID_SIZE * 0.8);

                // Draw very dark cave opening (the actual entrance)
                ctx.fillStyle = '#0a0a0a';
                ctx.fillRect(cavePixel.x - GRID_SIZE * 0.3, cavePixel.y - GRID_SIZE * 0.05, GRID_SIZE * 0.6, GRID_SIZE * 0.55);

                // Add subtle gradient effect at entrance (darkness fading in)
                const gradient = ctx.createLinearGradient(
                    cavePixel.x,
                    cavePixel.y - GRID_SIZE * 0.05,
                    cavePixel.x,
                    cavePixel.y + GRID_SIZE * 0.3
                );
                gradient.addColorStop(0, 'rgba(40, 40, 40, 0.6)');
                gradient.addColorStop(1, 'rgba(10, 10, 10, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(cavePixel.x - GRID_SIZE * 0.3, cavePixel.y - GRID_SIZE * 0.05, GRID_SIZE * 0.6, GRID_SIZE * 0.2);

                // Add some rocky texture details on the pillars
                for (let i = 0; i < 8; i++) {
                    const seed = caveEntrance.x * 1000 + caveEntrance.y + i;
                    const pr1 = (seed * 123) % 1000 / 1000;
                    const pr2 = (seed * 456) % 1000 / 1000;

                    // Left pillar rocks
                    ctx.fillStyle = `rgba(${60 + pr1 * 40}, ${60 + pr1 * 40}, ${60 + pr1 * 40}, 0.4)`;
                    ctx.beginPath();
                    ctx.arc(
                        cavePixel.x - GRID_SIZE * 0.45 + (pr1 - 0.5) * GRID_SIZE * 0.15,
                        cavePixel.y - GRID_SIZE * 0.2 + pr2 * GRID_SIZE * 0.6,
                        2 + pr1 * 2,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();

                    // Right pillar rocks
                    ctx.fillStyle = `rgba(${60 + pr2 * 40}, ${60 + pr2 * 40}, ${60 + pr2 * 40}, 0.4)`;
                    ctx.beginPath();
                    ctx.arc(
                        cavePixel.x + GRID_SIZE * 0.45 + (pr2 - 0.5) * GRID_SIZE * 0.15,
                        cavePixel.y - GRID_SIZE * 0.2 + pr1 * GRID_SIZE * 0.6,
                        2 + pr2 * 2,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                }

                // Draw subtle outline to define the entrance
                ctx.strokeStyle = '#2a2a2a';
                ctx.lineWidth = 2;
                ctx.strokeRect(cavePixel.x - GRID_SIZE * 0.3, cavePixel.y - GRID_SIZE * 0.05, GRID_SIZE * 0.6, GRID_SIZE * 0.55);
            }

            // NEW: Cave Zone rendering
            if (myZone === 5) {
                // Draw dark rocky cave floor
                const midY = Math.floor(GRID_HEIGHT / 2);
                for (let x = 0; x < GRID_WIDTH; x++) {
                    for (let y = 0; y < GRID_HEIGHT; y++) {
                        const mirroredY = y > midY ? (GRID_HEIGHT - 1 - y) : y;
                        const pixel = gridToPixel(x, y);
                        const seed = x * 1000 + mirroredY;
                        // Very dark rocky ground
                        const rockHue = 30 + (seed % 10); // Brown-grey tones
                        const rockLightness = 10 + (seed % 8); // Very dark
                        ctx.fillStyle = `hsl(${rockHue}, 15%, ${rockLightness}%)`;
                        ctx.fillRect(pixel.x - GRID_SIZE/2, pixel.y - GRID_SIZE/2, GRID_SIZE, GRID_SIZE);
                        // Add some rock texture details
                        for (let i = 0; i < 3; i++) {
                            const pr1 = (seed + i * 234) % 1000 / 1000;
                            const pr2 = (seed + i * 567) % 1000 / 1000;
                            const rockX = pixel.x + (pr1 - 0.5) * GRID_SIZE * 0.6;
                            const rockY = pixel.y + (pr2 - 0.5) * GRID_SIZE * 0.6;
                            const rockSize = 1 + pr1 * 2;
                            ctx.fillStyle = `rgba(${80 + pr1 * 30}, ${70 + pr2 * 20}, ${60 + pr1 * 15}, 0.3)`;
                            ctx.beginPath();
                            ctx.arc(rockX, rockY, rockSize, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                } // ‚Üê Floor rendering ends here
                
            // NEW: Entrance with main path and side exits at specific coordinates
            const entranceX = Math.floor(GRID_WIDTH / 2); // x=10
            const entranceY = GRID_HEIGHT - 1; // y=14

            // Draw light beam at main exit (10, 14)
            const exitPixel = gridToPixel(entranceX, entranceY);

            // Light beam gradient
            const lightGradient = ctx.createRadialGradient(
                exitPixel.x, exitPixel.y, 0,
                exitPixel.x, exitPixel.y, GRID_SIZE * 2.5
            );
            lightGradient.addColorStop(0, 'rgba(255, 255, 200, 0.6)');
            lightGradient.addColorStop(0.5, 'rgba(255, 255, 200, 0.3)');
            lightGradient.addColorStop(1, 'rgba(255, 255, 200, 0)');

            ctx.fillStyle = lightGradient;
            ctx.beginPath();
            ctx.arc(exitPixel.x, exitPixel.y, GRID_SIZE * 2.5, 0, Math.PI * 2);
            ctx.fill();

            // Main pathway left wall (x=9, at y=14, y=13, and y=11 ONLY - skip y=12 for exit)
            const leftWallYs = [entranceY, entranceY - 1, entranceY - 3]; // y=14, 13, 11 - SKIP y=12
            leftWallYs.forEach(y => {
                const fencePixel = gridToPixel(entranceX - 1, y);

                // Fence post
                ctx.fillStyle = '#5a3a1a';
                ctx.fillRect(fencePixel.x - 8, fencePixel.y - 15, 16, 30);

                // Fence bars
                ctx.fillStyle = '#4a2a0a';
                ctx.fillRect(fencePixel.x - 10, fencePixel.y - 8, 20, 3);
                ctx.fillRect(fencePixel.x - 10, fencePixel.y + 0, 20, 3);
                ctx.fillRect(fencePixel.x - 10, fencePixel.y + 8, 20, 3);
            });

            // Main pathway right wall (x=11, at y=14, y=13, and y=11 ONLY - skip y=12 for exit)
            const rightWallYs = [entranceY, entranceY - 1, entranceY - 3]; // y=14, 13, 11 - SKIP y=12
            rightWallYs.forEach(y => {
                const fencePixel = gridToPixel(entranceX + 1, y);

                // Fence post
                ctx.fillStyle = '#5a3a1a';
                ctx.fillRect(fencePixel.x - 8, fencePixel.y - 15, 16, 30);

                // Fence bars
                ctx.fillStyle = '#4a2a0a';
                ctx.fillRect(fencePixel.x - 10, fencePixel.y - 8, 20, 3);
                ctx.fillRect(fencePixel.x - 10, fencePixel.y + 0, 20, 3);
                ctx.fillRect(fencePixel.x - 10, fencePixel.y + 8, 20, 3);
            });

            // LEFT EXIT - Arrow at (8,12) - NO FENCE HERE
            const leftExitPixel = gridToPixel(8, 12);
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('‚Üê', leftExitPixel.x, leftExitPixel.y + 7);

            // RIGHT EXIT - Arrow at (12,12) - NO FENCE HERE
            const rightExitPixel = gridToPixel(12, 12);
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('‚Üí', rightExitPixel.x, rightExitPixel.y + 7);

            // Draw rope at main exit
            ctx.strokeStyle = '#8B7355';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(exitPixel.x, exitPixel.y - GRID_SIZE);
            ctx.lineTo(exitPixel.x, exitPixel.y + GRID_SIZE/2);
            ctx.stroke();

            // Rope knots
            ctx.fillStyle = '#6B5345';
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(exitPixel.x, exitPixel.y - GRID_SIZE + (i * 15), 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }
            // Draw zone transition arrows
            if (myZone === 1) {
                const rightArrowX = (GRID_WIDTH - 1) * GRID_SIZE + GRID_SIZE / 2;
                const rightArrowY = (GRID_HEIGHT / 2) * GRID_SIZE;

                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('>', rightArrowX, rightArrowY);

                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.font = '12px Arial';
                ctx.fillText('Farm', rightArrowX, rightArrowY + 20);

                const leftArrowX = GRID_SIZE / 2;
                const leftArrowY = (GRID_HEIGHT / 2) * GRID_SIZE;

                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('<', leftArrowX, leftArrowY);

                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.font = '12px Arial';
                ctx.fillText('Lake', leftArrowX, leftArrowY + 20);

                // Draw north arrow to Forest
                const northArrowX = (GRID_WIDTH / 2) * GRID_SIZE;
                const northArrowY = GRID_SIZE / 2;

                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('^', northArrowX, northArrowY);

                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.font = '12px Arial';
                ctx.fillText('Forest', northArrowX, northArrowY + 20);

            } else if (myZone === 2) {
                const arrowX = GRID_SIZE / 2;
                const arrowY = (GRID_HEIGHT / 2) * GRID_SIZE;

                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('<', arrowX, arrowY);

                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.font = '12px Arial';
                ctx.fillText('Town', arrowX, arrowY + 20);

            } else if (myZone === 3) {
                const arrowX = (GRID_WIDTH - 1) * GRID_SIZE + GRID_SIZE / 2;
                const arrowY = (GRID_HEIGHT / 2) * GRID_SIZE;

                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('>', arrowX, arrowY);

                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.font = '12px Arial';
                ctx.fillText('Town', arrowX, arrowY + 20);
            } else if (myZone === 4) {
                // Forest Zone - draw south arrow back to Town
                const southArrowX = (GRID_WIDTH / 2) * GRID_SIZE;
                const southArrowY = (GRID_HEIGHT - 1) * GRID_SIZE + GRID_SIZE / 2;

                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('v', southArrowX, southArrowY);

                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.font = '12px Arial';
                ctx.fillText('Town', southArrowX, southArrowY + 20);

                // NEW: Draw arrow to Cave entrance (at position 10, 7)
                const caveArrowPixel = gridToPixel(10, 7);

                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('^', caveArrowPixel.x, caveArrowPixel.y);

                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.font = '12px Arial';
                ctx.fillText('Cave', caveArrowPixel.x, caveArrowPixel.y + 20);
            } else if (myZone === 5) {
                // NEW: Cave Zone - draw south arrow back to Forest
                const southArrowX = (GRID_WIDTH / 2) * GRID_SIZE;
                const southArrowY = (GRID_HEIGHT - 1) * GRID_SIZE + GRID_SIZE / 2;

                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('v', southArrowX, southArrowY);

                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.font = '12px Arial';
                ctx.fillText('Forest', southArrowX, southArrowY + 20);
            }
            
            if (myZone === 2 || myZone === 4 || myZone === 5) {
                // Draw mobs for Wilderness (zone 2), Forest (zone 4), and Cave (zone 5)
                Object.entries(mobs).forEach(([mobId, mob]) => {
                    if (mob && mob.health > 0) {
                        // Only draw mobs that belong to current zone
                        let mobZone;
                        if (mob.type === 'warlord') {
                            mobZone = 5; // Warlord is in Cave
                        } else if (mob.type === 'goblin') {
                            mobZone = 4; // Normal goblins in Forest
                        } else {
                            mobZone = 2; // Farm mobs
                        }

                        if (mobZone !== myZone) return;

                        const mobPixel = gridToPixel(mob.x, mob.y);

                        // Draw shadow first, then mob on top
                        if (mob.type === 'chicken') {
                            drawCharacterShadow(mobPixel.x, mobPixel.y, 8);
                            drawChicken(mobPixel.x, mobPixel.y);
                        } else if (mob.type === 'mouse') {
                            drawCharacterShadow(mobPixel.x, mobPixel.y, 6);
                            drawMouse(mobPixel.x, mobPixel.y);
                        } else if (mob.type === 'goblin') {
                            drawCharacterShadow(mobPixel.x, mobPixel.y, 14);
                            drawGoblin(mobPixel.x, mobPixel.y);
                        } else if (mob.type === 'warlord') {
                            // Boss gets much larger shadow
                            drawCharacterShadow(mobPixel.x, mobPixel.y, 85);
                            drawGoblinWarlord(mobPixel.x, mobPixel.y);
                            
                            // NEW: Boss name tag (always visible)
                            const nameTagY = mobPixel.y - 140;
                            
                            // Name tag background
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                            ctx.fillRect(mobPixel.x - 70, nameTagY - 5, 140, 20);
                            
                            // Name tag border
                            ctx.strokeStyle = '#FFD700';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(mobPixel.x - 70, nameTagY - 5, 140, 20);
                            
                            // Boss icon/skull
                            ctx.fillStyle = '#FF0000';
                            ctx.font = '14px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('üíÄ', mobPixel.x - 50, nameTagY + 9);
                            
                            // Boss name
                            ctx.fillStyle = '#FFD700';
                            ctx.font = 'bold 11px Courier New';
                            ctx.strokeStyle = '#000000';
                            ctx.lineWidth = 3;
                            ctx.strokeText('GOBLIN WARLORD', mobPixel.x + 5, nameTagY + 9);
                            ctx.fillText('GOBLIN WARLORD', mobPixel.x + 5, nameTagY + 9);
                            
                            // Boss level indicator
                            ctx.fillStyle = '#FF6666';
                            ctx.font = 'bold 10px Courier New';
                            ctx.fillText('[BOSS]', mobPixel.x + 5, nameTagY - 10);
                        }

                        // Draw health bar if damaged (or always for boss)
                        if (mob.health < mob.maxHealth || mob.type === 'warlord') {
                            let barWidth, barHeight, barX, barY;

                            if (mob.type === 'warlord') {
                                // BOSS: Much larger health bar
                                barWidth = 120;
                                barHeight = 12;
                                barX = mobPixel.x - barWidth / 2;
                                barY = mobPixel.y - 120; // Higher above boss head

                                // Draw boss health bar background (dark)
                                ctx.fillStyle = '#1a1a1a';
                                ctx.fillRect(barX - 2, barY - 2, barWidth + 4, barHeight + 4);

                                // Draw boss health bar border (gold)
                                ctx.strokeStyle = '#FFD700';
                                ctx.lineWidth = 2;
                                ctx.strokeRect(barX - 2, barY - 2, barWidth + 4, barHeight + 4);

                                // Draw empty bar (red background)
                                ctx.fillStyle = '#4a0000';
                                ctx.fillRect(barX, barY, barWidth, barHeight);

                                // Draw filled bar (gradient red to yellow based on health)
                                const healthPercent = mob.health / mob.maxHealth;
                                const currentBarWidth = healthPercent * barWidth;

                                // Color changes based on health: green -> yellow -> red
                                let barColor;
                                if (healthPercent > 0.6) {
                                    barColor = '#44ff44'; // Green (high health)
                                } else if (healthPercent > 0.3) {
                                    barColor = '#ffaa00'; // Yellow (medium health)
                                } else {
                                    barColor = '#ff4444'; // Red (low health)
                                }

                                ctx.fillStyle = barColor;
                                ctx.fillRect(barX, barY, currentBarWidth, barHeight);

                                // Draw health text on bar (50/50 format)
                                ctx.fillStyle = '#ffffff';
                                ctx.font = 'bold 10px Courier New';
                                ctx.textAlign = 'center';
                                ctx.strokeStyle = '#000000';
                                ctx.lineWidth = 3;
                                ctx.strokeText(`${mob.health}/${mob.maxHealth}`, mobPixel.x, barY + 10);
                                ctx.fillText(`${mob.health}/${mob.maxHealth}`, mobPixel.x, barY + 10);

                                // Draw boss title above health bar
                                ctx.fillStyle = '#FFD700';
                                ctx.font = 'bold 12px Courier New';
                                ctx.textAlign = 'center';
                                ctx.strokeStyle = '#000000';
                                ctx.lineWidth = 3;
                                ctx.strokeText('GOBLIN WARLORD', mobPixel.x, barY - 8);
                                ctx.fillText('GOBLIN WARLORD', mobPixel.x, barY - 8);

                            } else {
                                // Regular mobs: Small health bar
                                barWidth = 30;
                                barHeight = 4;
                                barX = mobPixel.x - barWidth / 2;
                                barY = mobPixel.y - 25;
                                
                                ctx.fillStyle = '#333';
                                ctx.fillRect(barX, barY, barWidth, barHeight);
                                
                                ctx.fillStyle = '#ff4444';
                                ctx.fillRect(barX, barY, (mob.health / mob.maxHealth) * barWidth, barHeight);
                            }
                        }
                        
                        // Draw aggro indicator for goblins
                        if (mob.type === 'goblin' && mob.isAggro) {
                            ctx.fillStyle = '#FF0000';
                            ctx.font = '12px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('!', mobPixel.x, mobPixel.y - 25);
                        }
                    }
                });
            }

            Object.entries(drops).forEach(([dropId, drop]) => {
                if (drop && drop.zone === myZone) {
                    const dropPixel = gridToPixel(drop.x, drop.y);
                    
                    if (drop.type === 'heart') {
                        ctx.fillStyle = '#ff69b4';
                        ctx.font = '16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('‚ù§Ô∏è', dropPixel.x, dropPixel.y + 5);
                    } else if (drop.type === 'gold') {
                        ctx.fillStyle = '#ffd700';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(`${drop.value}üí∞`, dropPixel.x, dropPixel.y + 5);
                    } else if (drop.type === 'exp') {
                        ctx.fillStyle = '#00ffff';
                        ctx.beginPath();
                        ctx.arc(dropPixel.x, dropPixel.y, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        const shimmer = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
                        ctx.fillStyle = `rgba(255, 255, 255, ${shimmer})`;
                        ctx.beginPath();
                        ctx.arc(dropPixel.x, dropPixel.y, 5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(`${drop.value}`, dropPixel.x, dropPixel.y + 15);
                    } else if (drop.type === 'feather') {
                        // NEW: Draw feather drops
                        ctx.fillStyle = '#e8e8e8';
                        ctx.font = '16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('ü™∂', dropPixel.x, dropPixel.y + 5);
                    }
                }
            });

            const currentTime = Date.now();
            Object.entries(fireballs).forEach(([fireballId, fireball]) => {
                if (fireball && fireball.zone === myZone) {
                    const firePixel = gridToPixel(fireball.x, fireball.y);
                    
                    ctx.fillStyle = '#ff4500';
                    ctx.beginPath();
                    ctx.arc(firePixel.x, firePixel.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    drawSparkles(firePixel.x, firePixel.y, currentTime);
                    
                    Object.entries(players).forEach(([targetPlayerId, targetPlayer]) => {
                        if (targetPlayer && 
                            targetPlayerId !== fireball.ownerId && 
                            targetPlayer.gridX === fireball.x && 
                            targetPlayer.gridY === fireball.y && 
                            targetPlayer.zone === fireball.zone &&
                            !targetPlayer.isRespawning &&
                            targetPlayer.health > 0) {
                            
                            if (targetPlayerId === playerId) {
                                takeDamage();
                            }
                            
                            const fireballRef = ref(database, `fireballs/${fireballId}`);
                            set(fireballRef, null);
                        }
                    });
                }
            });

            Object.entries(players).forEach(([id, player]) => {
                if (player && player.zone === myZone && typeof player.gridX === 'number' && typeof player.gridY === 'number') {
                    const playerPixel = gridToPixel(player.gridX, player.gridY);
                    
                    if (player.isRespawning && Math.floor(Date.now() / 200) % 2) {
                        return;
                    }
                    
                    // Draw shadow first (so it appears behind sprite)
                    if (id === playerId) {
                        // Local player gets a slightly different shadow (white tint + outline)
                        drawCharacterShadow(playerPixel.x, playerPixel.y, 12);

                        // Add white highlight for local player
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                        ctx.beginPath();
                        ctx.ellipse(playerPixel.x, playerPixel.y + 18, 12, 4, 0, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.ellipse(playerPixel.x, playerPixel.y + 18, 12, 4, 0, 0, Math.PI * 2);
                        ctx.stroke();
                    } else {
                        // Other players get standard shadow
                        drawCharacterShadow(playerPixel.x, playerPixel.y, 12);
                    }

                    // Draw player sprite on top of shadow
                    drawPlayerSprite(playerPixel.x, playerPixel.y, player.direction || 'down', player.color || '#4ecdc4');

                    // NEW: Draw shield if player is blocking
                    if (player.isBlocking && (id === playerId || player.zone === myZone)) {
                        const direction = player.direction || 'down';

                        // Shield dimensions
                        const shieldWidth = 20;
                        const shieldHeight = 28;
                        const shieldThickness = 4;

                        // Colors
                        const woodColor = '#8B4513';
                        const metalRim = '#C0C0C0';
                        const metalBoss = '#FFD700'; // Gold boss in center

                        ctx.save();

                        if (direction === 'left' || direction === 'right') {
                            // LEFT/RIGHT: Shield appears as thin vertical wall
                            const offsetX = direction === 'left' ? -18 : 18;
                            const shieldX = playerPixel.x + offsetX;
                            const shieldY = playerPixel.y;

                            // Draw shield as thin vertical rectangle
                            ctx.fillStyle = woodColor;
                            ctx.fillRect(shieldX - shieldThickness/2, shieldY - shieldHeight/2, shieldThickness, shieldHeight);

                            // Metal rim on edges
                            ctx.strokeStyle = metalRim;
                            ctx.lineWidth = 2;
                            ctx.strokeRect(shieldX - shieldThickness/2, shieldY - shieldHeight/2, shieldThickness, shieldHeight);

                            // Horizontal metal bands
                            ctx.strokeStyle = metalRim;
                            ctx.lineWidth = 1.5;
                            ctx.beginPath();
                            ctx.moveTo(shieldX - shieldThickness/2, shieldY - 8);
                            ctx.lineTo(shieldX + shieldThickness/2, shieldY - 8);
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.moveTo(shieldX - shieldThickness/2, shieldY + 8);
                            ctx.lineTo(shieldX + shieldThickness/2, shieldY + 8);
                            ctx.stroke();

                        } else if (direction === 'up') {
                            // UP: Shield outline around player's body (subtle, on same tile)
                            const shieldX = playerPixel.x;
                            const shieldY = playerPixel.y;

                            // Draw subtle shield outline around player (left side)
                            ctx.strokeStyle = metalRim;
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(shieldX - 12, shieldY - 8); // Top left
                            ctx.lineTo(shieldX - 12, shieldY + 12); // Bottom left
                            ctx.stroke();

                            // Draw subtle shield outline (right side)
                            ctx.beginPath();
                            ctx.moveTo(shieldX + 12, shieldY - 8); // Top right
                            ctx.lineTo(shieldX + 12, shieldY + 12); // Bottom right
                            ctx.stroke();

                            // Draw subtle top arc of shield peeking above player
                            ctx.strokeStyle = metalRim;
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(shieldX, shieldY - 8, 12, Math.PI * 0.8, Math.PI * 0.2);
                            ctx.stroke();

                            // Add small wooden texture hints on sides
                            ctx.fillStyle = woodColor;
                            ctx.fillRect(shieldX - 13, shieldY - 2, 3, 10);
                            ctx.fillRect(shieldX + 10, shieldY - 2, 3, 10);

                            // Metal rim on wooden parts
                            ctx.strokeStyle = metalRim;
                            ctx.lineWidth = 1;
                            ctx.strokeRect(shieldX - 13, shieldY - 2, 3, 10);
                            ctx.strokeRect(shieldX + 10, shieldY - 2, 3, 10);

                        } else if (direction === 'down') {
                            // DOWN: Shield held low, protecting lower body
                            const shieldX = playerPixel.x;
                            const shieldY = playerPixel.y + 18; // Lower position

                            // Draw wooden shield face (rounded rectangle)
                            ctx.fillStyle = woodColor;
                            ctx.beginPath();
                            ctx.roundRect(shieldX - shieldWidth/2, shieldY - shieldHeight/2, shieldWidth, shieldHeight, 4);
                            ctx.fill();

                            // Metal rim
                            ctx.strokeStyle = metalRim;
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.roundRect(shieldX - shieldWidth/2, shieldY - shieldHeight/2, shieldWidth, shieldHeight, 4);
                            ctx.stroke();

                            // Horizontal metal bands
                            ctx.strokeStyle = metalRim;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(shieldX - shieldWidth/2 + 2, shieldY - 8);
                            ctx.lineTo(shieldX + shieldWidth/2 - 2, shieldY - 8);
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.moveTo(shieldX - shieldWidth/2 + 2, shieldY + 8);
                            ctx.lineTo(shieldX + shieldWidth/2 - 2, shieldY + 8);
                            ctx.stroke();

                            // Center boss (metal stud)
                            ctx.fillStyle = metalBoss;
                            ctx.beginPath();
                            ctx.arc(shieldX, shieldY, 4, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.strokeStyle = metalRim;
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }

                        // Draw hit count indicator on the shield
                        if (id === playerId) {
                            const hitsRemaining = MAX_SHIELD_HITS - (player.shieldHitCount || 0);

                            // Position text based on direction
                            let textX = playerPixel.x;
                            let textY = playerPixel.y;

                            if (direction === 'left') {
                                textX = playerPixel.x - 18;
                                textY = playerPixel.y + 4;
                            } else if (direction === 'right') {
                                textX = playerPixel.x + 18;
                                textY = playerPixel.y + 4;
                            } else if (direction === 'up') {
                                textX = playerPixel.x;
                                textY = playerPixel.y - 25;
                            } else if (direction === 'down') {
                                textX = playerPixel.x;
                                textY = playerPixel.y + 22;
                            }

                            // Draw background circle for number
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                            ctx.beginPath();
                            ctx.arc(textX, textY - 3, 8, 0, Math.PI * 2);
                            ctx.fill();

                            // Draw hit count
                            ctx.fillStyle = '#FFD700';
                            ctx.font = 'bold 12px Courier New';
                            ctx.textAlign = 'center';
                            ctx.fillText(`${hitsRemaining}`, textX, textY);
                        }

                        ctx.restore();
                    }

                    // Draw direction arrow for local player only
                    if (id === playerId) {
                        // Calculate arrow position one tile ahead
                        const arrowOffsets = {
                            'up': { x: 0, y: -GRID_SIZE },
                            'down': { x: 0, y: GRID_SIZE },
                            'left': { x: -GRID_SIZE, y: 0 },
                            'right': { x: GRID_SIZE, y: 0 }
                        };

                        const offset = arrowOffsets[myDirection] || arrowOffsets['right'];
                        const arrowX = playerPixel.x + offset.x;
                        const arrowY = playerPixel.y + offset.y;

                        // Draw subtle arrow with slight glow
                        const shimmer = 0.7 + Math.sin(Date.now() * 0.003) * 0.3;

                        // Glow effect
                        ctx.shadowBlur = 8;
                        ctx.shadowColor = `rgba(255, 255, 255, ${shimmer * 0.5})`;

                        // Arrow shape
                        ctx.fillStyle = `rgba(255, 255, 255, ${shimmer})`;
                        ctx.beginPath();

                        const arrowSize = 8;
                        if (myDirection === 'up') {
                            ctx.moveTo(arrowX, arrowY - arrowSize);
                            ctx.lineTo(arrowX - arrowSize/2, arrowY);
                            ctx.lineTo(arrowX + arrowSize/2, arrowY);
                        } else if (myDirection === 'down') {
                            ctx.moveTo(arrowX, arrowY + arrowSize);
                            ctx.lineTo(arrowX - arrowSize/2, arrowY);
                            ctx.lineTo(arrowX + arrowSize/2, arrowY);
                        } else if (myDirection === 'left') {
                            ctx.moveTo(arrowX - arrowSize, arrowY);
                            ctx.lineTo(arrowX, arrowY - arrowSize/2);
                            ctx.lineTo(arrowX, arrowY + arrowSize/2);
                        } else if (myDirection === 'right') {
                            ctx.moveTo(arrowX + arrowSize, arrowY);
                            ctx.lineTo(arrowX, arrowY - arrowSize/2);
                            ctx.lineTo(arrowX, arrowY + arrowSize/2);
                        }

                        ctx.closePath();
                        ctx.fill();

                        // Reset shadow
                        ctx.shadowBlur = 0;
                    }

                    if (player.isFishing) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.beginPath();
                        ctx.arc(playerPixel.x, playerPixel.y - 35, 12, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#4169E1';
                        ctx.font = '16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('üé£', playerPixel.x, playerPixel.y - 28);
                    }

                    if (player.isCooking) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.beginPath();
                        ctx.arc(playerPixel.x, playerPixel.y - 35, 12, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#ff6600';
                        ctx.font = '16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('üî•', playerPixel.x, playerPixel.y - 28);
                    }

                    if (player.isWoodcutting) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.beginPath();
                        ctx.arc(playerPixel.x, playerPixel.y - 35, 12, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#228B22';
                        ctx.font = '16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('üå≥', playerPixel.x, playerPixel.y - 28);
                    }

                    if (player.isFiremaking) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.beginPath();
                        ctx.arc(playerPixel.x, playerPixel.y - 35, 12, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#ff8c00';
                        ctx.font = '16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('üïØÔ∏è', playerPixel.x, playerPixel.y - 28);
                    }

                    // Draw sword attack animation
                    if (player.isAttacking) {
                        const direction = player.direction || 'right';
                        const attackElapsed = Date.now() - (attackStartTime || Date.now());
                        const attackProgress = Math.min(attackElapsed / attackDuration, 1);

                        const totalSwordLength = 40;
                        const hiltLength = 10;
                        const bladeLength = totalSwordLength - hiltLength;
                        const hiltThickness = 6;

                        // Determine if this is a swing or stab based on direction and combo
                        const isVertical = (direction === 'up' || direction === 'down');
                        const isThirdAttack = (id === playerId && attackComboCount === 2);
                        const useSwingAnimation = !isVertical && !isThirdAttack;

                        // Draw special effect for knockback attack (third attack)
                        if (id === playerId && attackComboCount === 2 && attackProgress > 0.3 && attackProgress < 0.7) {
                            // Draw impact lines/effect during the peak of the stab
                            ctx.strokeStyle = 'rgba(255, 255, 0, 0.6)';
                            ctx.lineWidth = 2;

                            const impactDistance = 45; // Distance of impact lines

                            if (direction === 'left') {
                                for (let i = 0; i < 3; i++) {
                                    ctx.beginPath();
                                    ctx.moveTo(playerPixel.x - 40, playerPixel.y - 10 + (i * 10));
                                    ctx.lineTo(playerPixel.x - impactDistance, playerPixel.y - 10 + (i * 10));
                                    ctx.stroke();
                                }
                            } else if (direction === 'right') {
                                for (let i = 0; i < 3; i++) {
                                    ctx.beginPath();
                                    ctx.moveTo(playerPixel.x + 40, playerPixel.y - 10 + (i * 10));
                                    ctx.lineTo(playerPixel.x + impactDistance, playerPixel.y - 10 + (i * 10));
                                    ctx.stroke();
                                }
                            } else if (direction === 'up') {
                                for (let i = 0; i < 3; i++) {
                                    ctx.beginPath();
                                    ctx.moveTo(playerPixel.x - 10 + (i * 10), playerPixel.y - 40);
                                    ctx.lineTo(playerPixel.x - 10 + (i * 10), playerPixel.y - impactDistance);
                                    ctx.stroke();
                                }
                            } else if (direction === 'down') {
                                for (let i = 0; i < 3; i++) {
                                    ctx.beginPath();
                                    ctx.moveTo(playerPixel.x - 10 + (i * 10), playerPixel.y + 40);
                                    ctx.lineTo(playerPixel.x - 10 + (i * 10), playerPixel.y + impactDistance);
                                    ctx.stroke();
                                }
                            }
                        }

                        if (useSwingAnimation) {
                            // SWING ANIMATION (for left/right first two attacks)
                            const verticalOffset = -20 + (20 * attackProgress);

                            if (direction === 'left') {
                                const baseX = playerPixel.x - 10;
                                const baseY = playerPixel.y;

                                const endX = baseX - totalSwordLength;
                                const endY = baseY + verticalOffset;

                                const angle = Math.atan2(endY - baseY, endX - baseX);

                                const hiltEndX = baseX + Math.cos(angle) * hiltLength;
                                const hiltEndY = baseY + Math.sin(angle) * hiltLength;

                                const bladeEndX = hiltEndX + Math.cos(angle) * bladeLength;
                                const bladeEndY = hiltEndY + Math.sin(angle) * bladeLength;

                                // Draw hilt
                                ctx.strokeStyle = '#8B4513';
                                ctx.lineWidth = hiltThickness;
                                ctx.lineCap = 'round';
                                ctx.beginPath();
                                ctx.moveTo(baseX, baseY);
                                ctx.lineTo(hiltEndX, hiltEndY);
                                ctx.stroke();

                                // Draw blade
                                ctx.strokeStyle = '#C0C0C0';
                                ctx.lineWidth = 3;
                                ctx.lineCap = 'round';
                                ctx.beginPath();
                                ctx.moveTo(hiltEndX, hiltEndY);
                                ctx.lineTo(bladeEndX, bladeEndY);
                                ctx.stroke();

                            } else if (direction === 'right') {
                                const baseX = playerPixel.x + 10;
                                const baseY = playerPixel.y;

                                const endX = baseX + totalSwordLength;
                                const endY = baseY + verticalOffset;

                                const angle = Math.atan2(endY - baseY, endX - baseX);

                                const hiltEndX = baseX + Math.cos(angle) * hiltLength;
                                const hiltEndY = baseY + Math.sin(angle) * hiltLength;

                                const bladeEndX = hiltEndX + Math.cos(angle) * bladeLength;
                                const bladeEndY = hiltEndY + Math.sin(angle) * bladeLength;

                                // Draw hilt
                                ctx.strokeStyle = '#8B4513';
                                ctx.lineWidth = hiltThickness;
                                ctx.lineCap = 'round';
                                ctx.beginPath();
                                ctx.moveTo(baseX, baseY);
                                ctx.lineTo(hiltEndX, hiltEndY);
                                ctx.stroke();

                                // Draw blade
                                ctx.strokeStyle = '#C0C0C0';
                                ctx.lineWidth = 3;
                                ctx.lineCap = 'round';
                                ctx.beginPath();
                                ctx.moveTo(hiltEndX, hiltEndY);
                                ctx.lineTo(bladeEndX, bladeEndY);
                                ctx.stroke();
                            }
                        } else {
                            // STAB ANIMATION (for up/down always, and left/right third attack)
                            const stabDistance = Math.sin(attackProgress * Math.PI) * 25;

                            if (direction === 'left') {
                                const baseX = playerPixel.x - stabDistance;
                                const baseY = playerPixel.y;

                                const hiltEndX = baseX - hiltLength;
                                const hiltEndY = baseY;

                                const bladeEndX = hiltEndX - bladeLength;
                                const bladeEndY = baseY;

                                // Draw hilt
                                ctx.strokeStyle = '#8B4513';
                                ctx.lineWidth = hiltThickness;
                                ctx.lineCap = 'round';
                                ctx.beginPath();
                                ctx.moveTo(baseX, baseY);
                                ctx.lineTo(hiltEndX, hiltEndY);
                                ctx.stroke();

                                // Draw blade
                                ctx.strokeStyle = '#C0C0C0';
                                ctx.lineWidth = 3;
                                ctx.lineCap = 'round';
                                ctx.beginPath();
                                ctx.moveTo(hiltEndX, hiltEndY);
                                ctx.lineTo(bladeEndX, bladeEndY);
                                ctx.stroke();

                            } else if (direction === 'right') {
                                const baseX = playerPixel.x + stabDistance;
                                const baseY = playerPixel.y;

                                const hiltEndX = baseX + hiltLength;
                                const hiltEndY = baseY;

                                const bladeEndX = hiltEndX + bladeLength;
                                const bladeEndY = baseY;

                                // Draw hilt
                                ctx.strokeStyle = '#8B4513';
                                ctx.lineWidth = hiltThickness;
                                ctx.lineCap = 'round';
                                ctx.beginPath();
                                ctx.moveTo(baseX, baseY);
                                ctx.lineTo(hiltEndX, hiltEndY);
                                ctx.stroke();

                                // Draw blade
                                ctx.strokeStyle = '#C0C0C0';
                                ctx.lineWidth = 3;
                                ctx.lineCap = 'round';
                                ctx.beginPath();
                                ctx.moveTo(hiltEndX, hiltEndY);
                                ctx.lineTo(bladeEndX, bladeEndY);
                                ctx.stroke();

                            } else if (direction === 'up') {
                                const baseX = playerPixel.x;
                                const baseY = playerPixel.y - stabDistance;

                                const hiltEndX = baseX;
                                const hiltEndY = baseY - hiltLength;

                                const bladeEndX = baseX;
                                const bladeEndY = hiltEndY - bladeLength;

                                // Draw hilt
                                ctx.strokeStyle = '#8B4513';
                                ctx.lineWidth = hiltThickness;
                                ctx.lineCap = 'round';
                                ctx.beginPath();
                                ctx.moveTo(baseX, baseY);
                                ctx.lineTo(hiltEndX, hiltEndY);
                                ctx.stroke();

                                // Draw blade
                                ctx.strokeStyle = '#C0C0C0';
                                ctx.lineWidth = 3;
                                ctx.lineCap = 'round';
                                ctx.beginPath();
                                ctx.moveTo(hiltEndX, hiltEndY);
                                ctx.lineTo(bladeEndX, bladeEndY);
                                ctx.stroke();

                            } else if (direction === 'down') {
                                const baseX = playerPixel.x;
                                const baseY = playerPixel.y + stabDistance;

                                const hiltEndX = baseX;
                                const hiltEndY = baseY + hiltLength;

                                const bladeEndX = baseX;
                                const bladeEndY = hiltEndY + bladeLength;

                                // Draw hilt
                                ctx.strokeStyle = '#8B4513';
                                ctx.lineWidth = hiltThickness;
                                ctx.lineCap = 'round';
                                ctx.beginPath();
                                ctx.moveTo(baseX, baseY);
                                ctx.lineTo(hiltEndX, hiltEndY);
                                ctx.stroke();

                                // Draw blade
                                ctx.strokeStyle = '#C0C0C0';
                                ctx.lineWidth = 3;
                                ctx.lineCap = 'round';
                                ctx.beginPath();
                                ctx.moveTo(hiltEndX, hiltEndY);
                                ctx.lineTo(bladeEndX, bladeEndY);
                                ctx.stroke();
                            }
                        }
                    }

                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 12px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText(`P${player.playerNumber || '?'}`, playerPixel.x, playerPixel.y + 35);
                    
                    // Draw chat message if exists
                    const playerMessage = playerMessages[id];
                    if (playerMessage && playerMessage.zone === myZone) {
                        // Handle both server timestamp objects and regular timestamps
                        let messageTimestamp;
                        if (typeof playerMessage.timestamp === 'object' && playerMessage.timestamp !== null) {
                            // This is a server timestamp object, use current time as fallback
                            messageTimestamp = Date.now() - 100; // Show immediately
                        } else {
                            messageTimestamp = playerMessage.timestamp || Date.now();
                        }
                        
                        const messageAge = Date.now() - messageTimestamp;
                        console.log('Drawing message for player', id, 'age:', messageAge, 'message:', playerMessage.message);
                        
                        if (messageAge < 3000 && messageAge >= 0) { // Show for 3 seconds
                            // Message background
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                            ctx.font = '12px Courier New';
                            const messageWidth = Math.max(ctx.measureText(playerMessage.message).width + 16, 60);
                            const messageHeight = 20;
                            const messageX = playerPixel.x - messageWidth / 2;
                            const messageY = playerPixel.y - 65;
                            
                            ctx.fillRect(messageX, messageY, messageWidth, messageHeight);
                            ctx.strokeStyle = '#9fd89f';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(messageX, messageY, messageWidth, messageHeight);
                            
                            // Message text
                            ctx.fillStyle = '#e8f5e8';
                            ctx.textAlign = 'center';
                            ctx.fillText(playerMessage.message, playerPixel.x, playerPixel.y - 50);
                        }
                    }
                    
                    if (player.health < 4) {
                        const barWidth = 30;
                        const barHeight = 4;
                        const barX = playerPixel.x - barWidth / 2;
                        const barY = playerPixel.y - 28;
                        
                        ctx.fillStyle = '#333';
                        ctx.fillRect(barX, barY, barWidth, barHeight);
                        
                        ctx.fillStyle = '#ff4444';
                        ctx.fillRect(barX, barY, (player.health / 4) * barWidth, barHeight);
                    }
                    
                    // Check for melee attack damage (only for local player)
                    if (id === playerId) {
                        Object.entries(players).forEach(([attackerId, attacker]) => {
                            if (attacker && 
                                attackerId !== playerId && 
                                attacker.isAttacking && 
                                attacker.zone === myZone &&
                                !attacker.isRespawning &&
                                attacker.health > 0) {
                                
                                // Calculate attacker's attack position
                                const directions = {
                                    'up': { x: 0, y: -1 },
                                    'down': { x: 0, y: 1 },
                                    'left': { x: -1, y: 0 },
                                    'right': { x: 1, y: 0 }
                                };
                                
                                const dir = directions[attacker.direction || 'right'];
                                const attackX = attacker.gridX + dir.x;
                                const attackY = attacker.gridY + dir.y;
                                
                                // Check if we're in the attack position
                                if (myGridPos.x === attackX && myGridPos.y === attackY && !isRespawning && myHealth > 0) {
                                    takeDamage();
                                    console.log('Took melee damage from player', attackerId);
                                }
                            }
                        });
                    }
                }
            });

            if (showDialog) {
                const dialogBoxX = 50;
                const dialogBoxY = canvas.height - 150;
                const dialogBoxWidth = canvas.width - 100;
                const dialogBoxHeight = 100;
                const textStartX = dialogBoxX + 20;
                const textStartY = dialogBoxY + 30;
                const maxTextWidth = dialogBoxWidth - 40;

                // Update typewriter effect
                updateTypewriter(Date.now());

                // Draw NPC name tab
                if (currentDialogNPC) {
                    drawNPCNameTab(currentDialogNPC, dialogBoxX, dialogBoxY, dialogBoxWidth);
                }

                // Subtle border glow/pulse effect
                const pulseIntensity = 0.3 + Math.sin(Date.now() * 0.003) * 0.15;
                ctx.shadowBlur = 15;
                ctx.shadowColor = `rgba(159, 216, 159, ${pulseIntensity})`;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(dialogBoxX, dialogBoxY, dialogBoxWidth, dialogBoxHeight);

                ctx.strokeStyle = '#4a6b47';
                ctx.lineWidth = 2;
                ctx.strokeRect(dialogBoxX, dialogBoxY, dialogBoxWidth, dialogBoxHeight);

                // Reset shadow
                ctx.shadowBlur = 0;

                // Use displayedText instead of dialogText for typewriter effect
                const wrappedLines = wrapText(displayedText, maxTextWidth, '16px Courier New');
                ctx.fillStyle = '#e8f5e8';
                ctx.font = '16px Courier New';
                ctx.textAlign = 'left';
                
                wrappedLines.forEach((line, index) => {
                    ctx.fillText(line, textStartX, textStartY + (index * 20));
                });
                
                ctx.font = '12px Courier New';
                ctx.fillStyle = '#a8c5a8';
                // Show different instruction if typewriter is still active
                if (isTypewriterActive && charIndex < dialogText.length) {
                    ctx.fillText('ENTER: Skip | ESC/WASD: Close', textStartX, dialogBoxY + dialogBoxHeight - 15);
                } else {
                    ctx.fillText('Press ESC or any movement key to close', textStartX, dialogBoxY + dialogBoxHeight - 15);
                }
            }

            if (showCookingDialog) {
                const dialogBoxX = 50;
                const dialogBoxY = canvas.height - 150;
                const dialogBoxWidth = canvas.width - 100;
                const dialogBoxHeight = 100;
                const textStartX = dialogBoxX + 20;
                const textStartY = dialogBoxY + 30;
                const maxTextWidth = dialogBoxWidth - 40;

                // Update typewriter effect
                updateTypewriter(Date.now());

                // Subtle border glow/pulse effect
                const pulseIntensity = 0.3 + Math.sin(Date.now() * 0.003) * 0.15;
                ctx.shadowBlur = 15;
                ctx.shadowColor = `rgba(159, 216, 159, ${pulseIntensity})`;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(dialogBoxX, dialogBoxY, dialogBoxWidth, dialogBoxHeight);

                ctx.strokeStyle = '#4a6b47';
                ctx.lineWidth = 2;
                ctx.strokeRect(dialogBoxX, dialogBoxY, dialogBoxWidth, dialogBoxHeight);

                // Reset shadow
                ctx.shadowBlur = 0;

                // Main instruction text with typewriter and word wrapping
                const wrappedMainLines = wrapText(displayedText, maxTextWidth, '16px Courier New');
                
                ctx.fillStyle = '#e8f5e8';
                ctx.font = '16px Courier New';
                ctx.textAlign = 'left';
                
                wrappedMainLines.forEach((line, index) => {
                    ctx.fillText(line, textStartX, textStartY + (index * 18));
                });
                
                if (cookingOptions.length > 0) {
                    const option = cookingOptions[selectedCookingOption];
                    const iconStartY = textStartY + (wrappedMainLines.length * 18) + 8;
                    
                    // Draw food icon
                    ctx.font = '24px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(option.icon, textStartX, iconStartY);
                    
                    // Draw food description with word wrapping
                    const descText = `${option.name}: ${option.description}`;
                    const wrappedDescLines = wrapText(descText, maxTextWidth - 35, '14px Courier New');
                    
                    ctx.font = '14px Courier New';
                    wrappedDescLines.forEach((line, index) => {
                        ctx.fillText(line, textStartX + 35, iconStartY - 8 + (index * 16));
                    });
                }
                
                ctx.font = '12px Courier New';
                ctx.fillStyle = '#a8c5a8';
                if (isTypewriterActive && charIndex < dialogText.length) {
                    ctx.fillText('ENTER: Skip | TAB: Cycle | ESC: Cancel', textStartX, dialogBoxY + dialogBoxHeight - 15);
                } else {
                    ctx.fillText('TAB: Cycle | ENTER: Cook | ESC/WASD: Cancel', textStartX, dialogBoxY + dialogBoxHeight - 15);
                }
            }

            if (showLevelUpPopup && levelUpPopupTimer > 0) {
                const popupX = canvas.width - 200;
                const popupY = 50;
                const popupWidth = 150;
                const popupHeight = 60;
                
                const pulseAlpha = 0.8 + Math.sin(Date.now() * 0.01) * 0.2;
                ctx.fillStyle = `rgba(255, 215, 0, ${pulseAlpha})`;
                ctx.fillRect(popupX, popupY, popupWidth, popupHeight);
                
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 3;
                ctx.strokeRect(popupX, popupY, popupWidth, popupHeight);
                
                ctx.fillStyle = '#000';
                ctx.font = 'bold 20px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('LEVEL UP!', popupX + popupWidth/2, popupY + 25);
                
                ctx.fillStyle = '#8B4513';
                ctx.font = 'bold 16px Courier New';
                ctx.fillText(`Level ${newLevel}`, popupX + popupWidth/2, popupY + 45);
            }

            if (showFishCatchPopup && fishCatchPopupTimer > 0) {
                const popupX = canvas.width - 280;
                const popupY = 120;
                const popupWidth = 230;
                const popupHeight = 50;
                
                ctx.fillStyle = 'rgba(45, 74, 42, 0.95)';
                ctx.fillRect(popupX, popupY, popupWidth, popupHeight);
                
                ctx.strokeStyle = '#9fd89f';
                ctx.lineWidth = 2;
                ctx.strokeRect(popupX, popupY, popupWidth, popupHeight);
                
                ctx.fillStyle = '#e8f5e8';
                ctx.font = '14px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('üé£ You caught a Fresh Fish!', popupX + popupWidth/2, popupY + 30);
            }

            if (showCookingPopup && cookingPopupTimer > 0) {
                const popupX = canvas.width - 280;
                const popupY = 180;
                const popupWidth = 230;
                const popupHeight = 50;
                
                ctx.fillStyle = 'rgba(74, 45, 42, 0.95)';
                ctx.fillRect(popupX, popupY, popupWidth, popupHeight);
                
                ctx.strokeStyle = '#ff9f9f';
                ctx.lineWidth = 2;
                ctx.strokeRect(popupX, popupY, popupWidth, popupHeight);
                
                ctx.fillStyle = '#e8f5e8';
                ctx.font = '14px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(`üî• You cooked a ${cookedItemName}!`, popupX + popupWidth/2, popupY + 30);
            }

            if (showWoodcuttingPopup && woodcuttingPopupTimer > 0) {
                const popupX = canvas.width - 280;
                const popupY = 240;
                const popupWidth = 230;
                const popupHeight = 50;
                
                ctx.fillStyle = 'rgba(45, 74, 45, 0.95)';
                ctx.fillRect(popupX, popupY, popupWidth, popupHeight);
                
                ctx.strokeStyle = '#9fff9f';
                ctx.lineWidth = 2;
                ctx.strokeRect(popupX, popupY, popupWidth, popupHeight);
                
                ctx.fillStyle = '#e8f5e8';
                ctx.font = '14px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('ü™ì You chopped down a tree!', popupX + popupWidth/2, popupY + 30);
            }

            if (showWoodcuttingDialog) {
                const dialogBoxX = 50;
                const dialogBoxY = canvas.height - 150;
                const dialogBoxWidth = canvas.width - 100;
                const dialogBoxHeight = 100;
                const textStartX = dialogBoxX + 20;
                const textStartY = dialogBoxY + 30;
                const maxTextWidth = dialogBoxWidth - 40;

                // Update typewriter effect
                updateTypewriter(Date.now());

                // Subtle border glow/pulse effect
                const pulseIntensity = 0.3 + Math.sin(Date.now() * 0.003) * 0.15;
                ctx.shadowBlur = 15;
                ctx.shadowColor = `rgba(159, 216, 159, ${pulseIntensity})`;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(dialogBoxX, dialogBoxY, dialogBoxWidth, dialogBoxHeight);

                ctx.strokeStyle = '#4a6b47';
                ctx.lineWidth = 2;
                ctx.strokeRect(dialogBoxX, dialogBoxY, dialogBoxWidth, dialogBoxHeight);

                // Reset shadow
                ctx.shadowBlur = 0;

                // Use displayedText with word wrapping
                const wrappedLines = wrapText(displayedText, maxTextWidth, '16px Courier New');
                ctx.fillStyle = '#e8f5e8';
                ctx.font = '16px Courier New';
                ctx.textAlign = 'left';

                wrappedLines.forEach((line, index) => {
                    ctx.fillText(line, textStartX, textStartY + (index * 20));
                });
                
                // Draw options side by side
                const yesText = selectedWoodcuttingOption === 0 ? '> Yes' : '  Yes';
                const noText = selectedWoodcuttingOption === 1 ? '> No' : '  No';
                
                ctx.font = '14px Courier New';
                ctx.fillText(yesText, textStartX + 50, textStartY + 30);
                ctx.fillText(noText, textStartX + 150, textStartY + 30);
                
                ctx.font = '12px Courier New';
                ctx.fillStyle = '#a8c5a8';
                if (isTypewriterActive && charIndex < dialogText.length) {
                    ctx.fillText('ENTER: Skip | TAB: Cycle | ESC: Cancel', textStartX, dialogBoxY + dialogBoxHeight - 15);
                } else {
                    ctx.fillText('TAB: Cycle | ENTER: Select | ESC/WASD: Cancel', textStartX, dialogBoxY + dialogBoxHeight - 15);
                }
            }

            if (showMerchantDialog) {
                const dialogBoxX = 50;
                const dialogBoxY = canvas.height - 150;
                const dialogBoxWidth = canvas.width - 100;
                const dialogBoxHeight = 100;
                const textStartX = dialogBoxX + 20;
                const textStartY = dialogBoxY + 30;
                const maxTextWidth = dialogBoxWidth - 40;

                // Update typewriter effect
                updateTypewriter(Date.now());

                // Draw NPC name tab
                drawNPCNameTab('Merchant', dialogBoxX, dialogBoxY, dialogBoxWidth);

                // Subtle border glow/pulse effect
                const pulseIntensity = 0.3 + Math.sin(Date.now() * 0.003) * 0.15;
                ctx.shadowBlur = 15;
                ctx.shadowColor = `rgba(159, 216, 159, ${pulseIntensity})`;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(dialogBoxX, dialogBoxY, dialogBoxWidth, dialogBoxHeight);

                ctx.strokeStyle = '#4a6b47';
                ctx.lineWidth = 2;
                ctx.strokeRect(dialogBoxX, dialogBoxY, dialogBoxWidth, dialogBoxHeight);

                // Reset shadow
                ctx.shadowBlur = 0;

                // Use displayedText with word wrapping
                const wrappedLines = wrapText(displayedText, maxTextWidth, '16px Courier New');
                ctx.fillStyle = '#e8f5e8';
                ctx.font = '16px Courier New';
                ctx.textAlign = 'left';

                wrappedLines.forEach((line, index) => {
                    ctx.fillText(line, textStartX, textStartY + (index * 20));
                });
                
                // Draw options side by side
                const buyText = selectedTradeOption === 0 ? '> Buy' : '  Buy';
                const sellText = selectedTradeOption === 1 ? '> Sell' : '  Sell';
                
                ctx.font = '14px Courier New';
                ctx.fillText(buyText, textStartX + 50, textStartY + 30);
                ctx.fillText(sellText, textStartX + 150, textStartY + 30);
                
                ctx.font = '12px Courier New';
                ctx.fillStyle = '#a8c5a8';
                // Show different instruction if typewriter is still active
                if (isTypewriterActive && charIndex < dialogText.length) {
                    ctx.fillText('ENTER: Skip | TAB: Cycle | ESC: Cancel', textStartX, dialogBoxY + dialogBoxHeight - 15);
                } else {
                    ctx.fillText('TAB: Cycle | ENTER: Select | ESC/WASD: Cancel', textStartX, dialogBoxY + dialogBoxHeight - 15);
                }
            }

            // FIXED: Draw quest dialog with Sky NPC providing the Goblin Slayer quest
            if (showQuestDialog) {
                const dialogBoxX = 50;
                const dialogBoxY = canvas.height - 150;
                const dialogBoxWidth = canvas.width - 100;
                const dialogBoxHeight = 100;
                const textStartX = dialogBoxX + 20;
                const textStartY = dialogBoxY + 30;
                const maxTextWidth = dialogBoxWidth - 40;

                // Update typewriter effect
                updateTypewriter(Date.now());

                // Draw NPC name tab
                const npcName = currentDialogNPC === 'Sky' ? 'Sky' : 'Sam';
                drawNPCNameTab(npcName, dialogBoxX, dialogBoxY, dialogBoxWidth);

                // Subtle border glow/pulse effect
                const pulseIntensity = 0.3 + Math.sin(Date.now() * 0.003) * 0.15;
                ctx.shadowBlur = 15;
                ctx.shadowColor = `rgba(159, 216, 159, ${pulseIntensity})`;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(dialogBoxX, dialogBoxY, dialogBoxWidth, dialogBoxHeight);

                ctx.strokeStyle = '#4a6b47';
                ctx.lineWidth = 2;
                ctx.strokeRect(dialogBoxX, dialogBoxY, dialogBoxWidth, dialogBoxHeight);

                // Reset shadow
                ctx.shadowBlur = 0;

                // Use displayedText with word wrapping
                const wrappedLines = wrapText(displayedText, maxTextWidth, '16px Courier New');
                ctx.fillStyle = '#e8f5e8';
                ctx.font = '16px Courier New';
                ctx.textAlign = 'left';

                wrappedLines.forEach((line, index) => {
                    ctx.fillText(line, textStartX, textStartY + (index * 20));
                });

                // Draw quest dialog options (Yes/No)
                const yesText = selectedQuestOption === 0 ? '> Yes' : '  Yes';
                const noText = selectedQuestOption === 1 ? '> No' : '  No';

                // Position options below the wrapped text
                const optionsY = textStartY + (wrappedLines.length * 20) + 20;

                ctx.font = '14px Courier New';

                if (questDialogType === 'initial') {
                    ctx.fillText(yesText, textStartX + 50, optionsY);
                    ctx.fillText(noText, textStartX + 150, optionsY);
                } else if (questDialogType === 'completion') {
                    // Show gold amount in options
                    const goldAmount = currentDialogNPC === 'Sky' ? '40 gold' : '30 gold';
                    const yesTextWithGold = selectedQuestOption === 0 ? `> Yes (${goldAmount})` : `  Yes (${goldAmount})`;
                    ctx.fillText(yesTextWithGold, textStartX + 50, optionsY);
                    ctx.fillText(noText, textStartX + 250, optionsY);
                }

                ctx.font = '12px Courier New';
                ctx.fillStyle = '#a8c5a8';
                if (isTypewriterActive && charIndex < dialogText.length) {
                    if (questDialogType === 'initial') {
                        ctx.fillText('ENTER: Skip | TAB: Cycle | ESC: Close', textStartX, dialogBoxY + dialogBoxHeight - 15);
                    } else {
                        ctx.fillText('ENTER: Skip | TAB: Cycle | ESC/WASD: Cancel', textStartX, dialogBoxY + dialogBoxHeight - 15);
                    }
                } else {
                    if (questDialogType === 'initial') {
                        ctx.fillText('TAB: Cycle | ENTER: Select | ESC: Close', textStartX, dialogBoxY + dialogBoxHeight - 15);
                    } else {
                        ctx.fillText('TAB: Cycle | ENTER: Select | ESC/WASD: Cancel', textStartX, dialogBoxY + dialogBoxHeight - 15);
                    }
                }
            }

            if (showTradeScreen) {
                // Draw trade screen overlay
                const overlayX = 50;
                const overlayY = 50;
                const overlayWidth = canvas.width - 100;
                const overlayHeight = canvas.height - 100;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                ctx.fillRect(overlayX, overlayY, overlayWidth, overlayHeight);
                
                ctx.strokeStyle = '#4a6b47';
                ctx.lineWidth = 3;
                ctx.strokeRect(overlayX, overlayY, overlayWidth, overlayHeight);
                
                // Draw header
                const headerText = tradeMode === 'buy' ? 'Buy from Merchant' : 'Sell to Merchant';
                ctx.fillStyle = '#9fd89f';
                ctx.font = 'bold 20px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(headerText, overlayX + overlayWidth / 2, overlayY + 40);
                
                // Draw gold display
                ctx.fillStyle = '#ffd700';
                ctx.font = '16px Courier New';
                ctx.fillText(`Your Gold: ${myGold} üí∞`, overlayX + overlayWidth / 2, overlayY + 65);
                
                // Get items to display
                const items = tradeMode === 'buy' ? getMerchantStock() : getPlayerSellableItems();
                
                if (items.length === 0) {
                    ctx.fillStyle = '#e8f5e8';
                    ctx.font = '16px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText('Nothing to ' + tradeMode, overlayX + overlayWidth / 2, overlayY + 150);
                } else {
                    // Draw items list
                    const startY = overlayY + 100;
                    const itemHeight = 40;
                    
                    items.forEach((item, index) => {
                        const itemY = startY + (index * itemHeight);
                        const isSelected = index === selectedTradeSlot;
                        
                        // Draw selection background
                        if (isSelected) {
                            ctx.fillStyle = 'rgba(159, 216, 159, 0.3)';
                            ctx.fillRect(overlayX + 20, itemY - 15, overlayWidth - 40, 35);
                        }
                        
                        // Draw item icon
                        ctx.font = '24px Arial';
                        ctx.fillStyle = '#e8f5e8';
                        ctx.textAlign = 'left';
                        ctx.fillText(item.icon, overlayX + 40, itemY + 5);
                        
                        // Draw item name
                        ctx.font = '16px Courier New';
                        ctx.fillStyle = isSelected ? '#9fd89f' : '#e8f5e8';
                        let displayName = item.name;
                        if (item.stackable && item.stack) {
                            displayName += ` (${item.stack})`;
                        }
                        ctx.fillText(displayName, overlayX + 80, itemY);
                        
                        // Draw price
                        const price = tradeMode === 'buy' ? item.price : item.sellPrice;
                        ctx.fillStyle = '#ffd700';
                        ctx.textAlign = 'right';
                        ctx.fillText(`${price} üí∞`, overlayX + overlayWidth - 60, itemY);
                        
                        // Draw affordability indicator for buy mode
                        if (tradeMode === 'buy' && myGold < item.price) {
                            ctx.fillStyle = '#ff4444';
                            ctx.font = '12px Courier New';
                            ctx.fillText('(Can\'t afford)', overlayX + overlayWidth - 180, itemY);
                        }
                    });
                    
                    // Draw selected item description
                    if (items[selectedTradeSlot]) {
                        const selectedItem = items[selectedTradeSlot];
                        const descY = overlayY + overlayHeight - 80;
                        
                        ctx.fillStyle = 'rgba(45, 74, 42, 0.8)';
                        ctx.fillRect(overlayX + 20, descY - 30, overlayWidth - 40, 60);
                        
                        ctx.strokeStyle = '#4a6b47';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(overlayX + 20, descY - 30, overlayWidth - 40, 60);
                        
                        ctx.fillStyle = '#e8f5e8';
                        ctx.font = '14px Courier New';
                        ctx.textAlign = 'left';
                        ctx.fillText(selectedItem.description, overlayX + 30, descY - 10);
                    }
                }
                
                // Draw instructions
                ctx.fillStyle = '#a8c5a8';
                ctx.font = '12px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('W/S: Navigate | ENTER: ' + (tradeMode === 'buy' ? 'Buy' : 'Sell') + ' | ESC: Close', overlayX + overlayWidth / 2, overlayY + overlayHeight - 15);
            }
        }

        // Draw quest tracking panel
        drawQuestPanel();

        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;

            if (e.key.toLowerCase() === 'm') {
                document.getElementById('musicToggle')?.click(); // Trigger the button click
                return;
            }
            
            if (e.key.toLowerCase() === 'i') {
                if (!showQuickChat && !showCookingDialog && !showQuestDialog) {
                    toggleInventory();
                }
                return;
            }
            
            if (e.key.toLowerCase() === 'q') {
                if (showInventory || showCookingDialog || showQuestDialog) return; // Don't allow quick chat while inventory or dialogs are open
                if (!showQuickChat) {
                    toggleQuickChat();
                } else {
                    cycleChatMessage();
                }
                return;
            }
            
            if (e.key === 'Tab') {
                e.preventDefault(); // Prevent default tab behavior
                if (showInventory && isSelectingFiremaking) {
                    // Handle firemaking TAB cycling
                    if (firemakingStep === 0 && firemakingOptions.length > 0) {
                        selectedFiremakingOption = (selectedFiremakingOption + 1) % firemakingOptions.length;
                        updateItemDescription();
                    } else if (firemakingStep === 1) {
                        selectedQuantity = (selectedQuantity + 1) % 2;
                        updateItemDescription();
                    }
                } else if (showCookingDialog) {
                    cycleCookingOption();
                } else if (showWoodcuttingDialog) {
                    cycleWoodcuttingOption();
                } else if (showMerchantDialog) {
                    cycleMerchantOption();
                } else if (showQuestDialog && (questDialogType === 'completion' || questDialogType === 'initial')) {
                    selectedQuestOption = (selectedQuestOption + 1) % 2; // 0 = Yes, 1 = No
                }
                return;
            }
            
            if (e.key === 'Enter') {
                // CRITICAL: Check if typewriter is ACTIVELY running (not just finished)
                if (isTypewriterActive && charIndex < dialogText.length &&
                    (showDialog || showMerchantDialog || showQuestDialog || showCookingDialog || showWoodcuttingDialog)) {
                    skipTypewriter();
                    e.preventDefault();
                    return; // Stop here, don't process dialog actions yet
                }

                // NEW: If we just skipped typewriter, don't process other actions yet
                if (typewriterJustSkipped) {
                    e.preventDefault();
                    return;
                }
                
                if (showInventory && isSelectingFiremaking) {
                    // Handle firemaking ENTER selection
                    if (firemakingStep === 0 && firemakingOptions.length > 0) {
                        // Selected logs, move to quantity selection
                        selectedLogsSlot = firemakingOptions[selectedFiremakingOption].slotIndex;
                        firemakingStep = 1;
                        selectedQuantity = 0;
                        updateItemDescription();
                    } else if (firemakingStep === 1) {
                        // Selected quantity, start firemaking
                        const logsItem = inventory[selectedLogsSlot];
                        if (logsItem) {
                            targetFireCount = selectedQuantity === 0 ? 1 : logsItem.stack;
                            firemakingCount = 0;
                            
                            // Determine direction to place fires (opposite of current facing direction)
                            const oppositeDirections = {
                                'up': 'down',
                                'down': 'up', 
                                'left': 'right',
                                'right': 'left'
                            };
                            firemakingDirection = oppositeDirections[myDirection] || 'down';
                            
                            isSelectingFiremaking = false;
                            firemakingStep = 0;
                            toggleInventory(); // Close inventory
                            isFiremaking = true;
                            nextFireTime = Date.now() + 1000;
                            updatePlayerData();
                            
                            console.log(`Starting firemaking: ${targetFireCount} fires in ${firemakingDirection} direction`);
                        }
                    }
                    return;
                } else if (showQuickChat) {
                    sendChatMessage();
                    return;
                } else if (showCookingDialog) {
                    selectCookingOption();
                    return;
                } else if (showWoodcuttingDialog) {
                    selectWoodcuttingOption();
                    return;
                } else if (showMerchantDialog) {
                    selectMerchantOption();
                    return;
                } else if (showTradeScreen) {
                    executeTrade();
                    return;
                } else if (showQuestDialog) {
                    if (questDialogType === 'initial') {
                        if (selectedQuestOption === 0) { // Accept quest
                            if (currentDialogNPC === 'Sky') {
                                // FIXED: Sky's goblin quest
                                const goblinQuest = {
                                    id: 'goblin_quest',
                                    title: 'Goblin Slayer',
                                    description: 'Clear out the goblin den in the Forest Zone for Sky'
                                };
                                addQuest(goblinQuest);
                                skyQuestActive = true;
                                showDialog = true;
                                currentDialogNPC = 'Sky';
                                startTypewriter("Perfect! Head north to the forest and clear out those goblins. I'll be waiting!");
                            } else {
                                // Sam's fish quest
                                const fishQuest = {
                                    id: 'fish_quest',
                                    title: 'Gone Fishing!',
                                    description: 'Bring 5 fish to Sam in the Lake Zone'
                                };
                                addQuest(fishQuest);
                                questNPCActive = true;
                                showDialog = true;
                                currentDialogNPC = 'Sam';
                                startTypewriter("Wonderful! I'll be waiting here for those 5 fish.");
                            }
                        } else {
                            // Declined quest
                            showDialog = true;
                            startTypewriter("If you change your mind I'll be right here!");
                        }
                        showQuestDialog = false;
                    } else if (questDialogType === 'completion' && selectedQuestOption === 0) {
                        if (currentDialogNPC === 'Sky') {
                            // Complete Sky's goblin quest - give 40 gold + 50 XP
                            myGold += 40;
                            givePlayerEXP(50); // Quest XP reward
                            skyQuestCompleted = true;
                            skyQuestActive = false;
                            goblinKillCount = 0; // Reset counter
                            removeQuest('goblin_quest');
                            updateGoldDisplay();

                            showDialog = true;
                            currentDialogNPC = 'Sky';
                            startTypewriter("Excellent! Here's your reward. Thank you for clearing out those goblins!");
                        } else {
                            // Complete Sam's fish quest - remove 5 fish and give 30 gold + 20 XP
                            let fishRemoved = 0;
                            for (let i = 0; i < inventory.length && fishRemoved < 5; i++) {
                                if (inventory[i] && inventory[i].id === 'fish') {
                                    const removeAmount = Math.min(5 - fishRemoved, inventory[i].stack);
                                    inventory[i].stack -= removeAmount;
                                    fishRemoved += removeAmount;

                                    if (inventory[i].stack <= 0) {
                                        inventory[i] = null;
                                    }
                                }
                            }

                            myGold += 30;
                            givePlayerEXP(20); // Quest XP reward
                            questNPCCompleted = true;
                            questNPCActive = false;
                            removeQuest('fish_quest');
                            updateGoldDisplay();

                            showDialog = true;
                            currentDialogNPC = 'Sam';
                            startTypewriter("Excellent! Here's your reward. Thanks for helping me catch those fish, this stew is going to be delicious!");
                        }
                        showQuestDialog = false;
                    } else {
                        showQuestDialog = false;
                    }
                    return;
                }
            }
            
            // Skip typewriter with ENTER (only when no other dialogs are active)
            if (e.key === 'Enter' && isTypewriterActive &&
                (showDialog || showMerchantDialog || showQuestDialog || showCookingDialog || showWoodcuttingDialog)) {
                skipTypewriter();
                e.preventDefault(); // Prevent ENTER from triggering other actions
                return;
            }

            if (e.key === 'Escape') {
                if (showInventory) {
                    if (isSelectingFiremaking) {
                        // Cancel firemaking selection
                        isSelectingFiremaking = false;
                        firemakingStep = 0;
                        updateItemDescription();
                    } else {
                        toggleInventory();
                    }
                } else if (showQuickChat) {
                    toggleQuickChat();
                } else if (showCookingDialog) {
                    showCookingDialog = false;
                } else if (showWoodcuttingDialog) {
                    showWoodcuttingDialog = false;
                    currentTree = null;
                } else if (showMerchantDialog) {
                    showMerchantDialog = false;
                } else if (showTradeScreen) {
                    closeTradeScreen();
                } else if (showQuestDialog) {
                    showQuestDialog = false;
                } else if (showDialog) {
                    showDialog = false;
                    isTypewriterActive = false; // Reset typewriter
                }
                return;
            }
            
            if (e.key.toLowerCase() === 'e') {
                if (!showInventory && !showDialog && !showQuickChat && !showCookingDialog && !showWoodcuttingDialog && !showMerchantDialog && !showTradeScreen && !showQuestDialog) {
                    if (isAdjacentToWater(myGridPos.x, myGridPos.y) && equippedTool && equippedTool.id === 'fishing_rod') {
                        startFishing();
                    } else {
                        // Try cooking interaction (handles both lake fireplace and player campfires)
                        startCooking();
                        
                        // If no cooking happened, check other interactions
                        if (!showCookingDialog && !showDialog) {
                            if (findAdjacentTree(myGridPos.x, myGridPos.y)) {
                                checkTreeInteraction();
                            } else if (myZone === 1) {
                                // Check for merchant manually with E key
                                const merchantDistance = Math.abs(myGridPos.x - merchant.x) + Math.abs(myGridPos.y - merchant.y);
                                if (merchantDistance <= 1) {
                                    showMerchantDialog = true;
                                    selectedTradeOption = 0;
                                }
                            }
                        }
                    }
                }
                return;
            }
            
            if (e.key.toLowerCase() === 'f') {
                if (!showInventory && !showDialog && !showQuickChat && !showCookingDialog && !showWoodcuttingDialog && !showMerchantDialog && !showTradeScreen && !showQuestDialog) {
                    performMeleeAttack();
                }
                return;
            }

            // NEW: R key for shield blocking
            if (e.key.toLowerCase() === 'r') {
                if (!showInventory && !showDialog && !showQuickChat && !showCookingDialog && !showWoodcuttingDialog && !showMerchantDialog && !showTradeScreen && !showQuestDialog) {
                    startBlocking();
                }
                return;
            }
            
            // Cancel dialogs if movement keys are pressed
            if ((showQuickChat || showCookingDialog || showWoodcuttingDialog || showMerchantDialog || showQuestDialog) && ['w', 'a', 's', 'd'].includes(e.key.toLowerCase())) {
                if (showQuickChat) {
                    toggleQuickChat();
                }
                if (showCookingDialog) {
                    showCookingDialog = false;
                }
                if (showWoodcuttingDialog) {
                    showWoodcuttingDialog = false;
                    currentTree = null;
                }
                if (showMerchantDialog) {
                    showMerchantDialog = false;
                }
                if (showQuestDialog) {
                    showQuestDialog = false;
                }
                return;
            }
            
            if ((showDialog || showCookingDialog || showWoodcuttingDialog || showMerchantDialog || showQuestDialog) && ['w', 'a', 's', 'd'].includes(e.key.toLowerCase())) {
                showDialog = false;
                showCookingDialog = false;
                showWoodcuttingDialog = false;
                showMerchantDialog = false;
                showQuestDialog = false;
                currentTree = null;
                isTypewriterActive = false; // Reset typewriter
                stopFishing();
                stopCooking();
                stopWoodcutting();
                if (!showInventory && !showQuickChat && !showTradeScreen) {
                    return;
                }
            }
            
            if (showInventory) {
                if (e.key.toLowerCase() === 'w') {
                    navigateInventory('up');
                } else if (e.key.toLowerCase() === 's') {
                    navigateInventory('down');
                } else if (e.key.toLowerCase() === 'a') {
                    navigateInventory('left');
                } else if (e.key.toLowerCase() === 'd') {
                    navigateInventory('right');
                } else if (e.key === ' ' || e.key === 'Enter') {
                    equipItem(selectedInventorySlot);
                }
                return;
            }
            
            if (showTradeScreen) {
                if (e.key.toLowerCase() === 'w') {
                    navigateTrade('up');
                } else if (e.key.toLowerCase() === 's') {
                    navigateTrade('down');
                }
                return;
            }
        });

        // AFTER - Add shield release logic
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;

            // NEW: Handle R key release for shield
            if (e.key.toLowerCase() === 'r') {
                if (isBlocking) {
                    stopBlocking();
                }
                resetShield(); // Always reset shield when R is released
            }
        });

        let lastMoveTime = 0;
        let lastHeartbeat = 0;
        let lastManaRegen = 0; // For 5-second mana regeneration
        function gameLoop() {
            const currentTime = Date.now();
            
            if (currentTime - lastHeartbeat > 10000) {
                updatePlayerData();
                lastHeartbeat = currentTime;
            }

            // Mana regeneration every 5 seconds
            if (currentTime - lastManaRegen > 2000) {
                if (myMana < myMaxMana) {
                    myMana = Math.min(myMaxMana, myMana + 1);
                    updateManaDisplay();
                    updatePlayerData();
                }
                lastManaRegen = currentTime;
            }
            processFishing();
            processCooking();
            processWoodcutting();
            processFiremaking();
            
            // Update quest progress
            activeQuests.forEach(quest => {
                if (quest.id === 'fish_quest') {
                    checkQuestCompletion('fish_quest');
                } else if (quest.id === 'goblin_quest') {
                    checkQuestCompletion('goblin_quest');
                }
            });
            
            // FIXED: Enhanced drop cleanup with better logging and different timing
            if (drops && typeof drops === 'object') {
                Object.entries(drops).forEach(([dropId, drop]) => {
                    try {
                        if (drop && drop.createdAt) {
                            const dropAge = now - drop.createdAt;
                            const maxAge = 30000; // Reduced to 30 seconds for testing
                            
                            if (dropAge > maxAge) {
                                console.log(`üßπ Cleaning up old ${drop.type || 'unknown'} drop (${Math.floor(dropAge/1000)}s old) at ${drop.x},${drop.y}`);
                                const dropRef = ref(database, `drops/${dropId}`);
                                set(dropRef, null).then(() => {
                                    console.log(`‚úÖ Successfully removed drop ${dropId}`);
                                }).catch((error) => {
                                    console.error(`‚ùå Failed to remove drop ${dropId}:`, error);
                                });
                            } else {
                                // Log young drops for debugging
                                if (Math.random() < 0.01) { // Only log 1% of the time to avoid spam
                                    console.log(`üì¶ Drop ${dropId} is ${Math.floor(dropAge/1000)}s old (${drop.type} at ${drop.x},${drop.y})`);
                                }
                            }
                        } else {
                            // Log drops without timestamps
                            console.log(`‚ö†Ô∏è Drop ${dropId} missing createdAt timestamp:`, drop);
                        }
                    } catch (error) {
                        console.error('Error processing drop:', dropId, error);
                    }
                });
            }
            const now = Date.now();
            playerCampfires = playerCampfires.filter(campfire => {
                const age = now - campfire.createdAt;
                return age < campfire.duration;
            });
            
            // Respawn chopped trees every 10 seconds
            trees.forEach(tree => {
                if (tree.chopped && (!tree.choppedTime || (now - tree.choppedTime) > 10000)) {
                    tree.chopped = false;
                    tree.choppedTime = null;
                    console.log(`Tree at ${tree.x}, ${tree.y} has regrown!`);
                }
            });
            
            // FIXED: Handle all mob respawning with proper position reset
            Object.entries(mobs).forEach(([mobId, mob]) => {
                if (mob && mob.health === 0 && mob.respawnTime && now >= mob.respawnTime) {
                    console.log(`Respawning ${mob.type} ${mobId}`);

                    if (mob.type === 'warlord') {
                        // Boss respawn in Cave center (deep inside, away from entrance)
                        const mobRef = ref(database, `caveMobs/${mobId}`);

                        set(mobRef, {
                            x: Math.floor(GRID_WIDTH / 2),
                            y: 7, // Spawn at top-center of cave (away from entrance)
                            health: 50,
                            maxHealth: 50,
                            type: 'warlord',
                            lastMove: Date.now(),
                            moveCounter: 0,
                            aggroTarget: null,
                            aggroRange: 5,
                            isAggro: false,
                            isBoss: true,
                            noKnockback: true,
                            respawnTime: null
                        });
                    } else if (mob.type === 'goblin') {
                        // Goblin respawn in Forest at original positions
                        const mobRef = ref(database, `forestMobs/${mobId}`);
                        const originalPositions = {
                            'goblin_1': { x: 5, y: 4 },
                            'goblin_2': { x: 15, y: 4 },
                            'goblin_3': { x: 5, y: 11 },
                            'goblin_4': { x: 15, y: 11 }
                        };
                        
                        const respawnPos = originalPositions[mobId] || { x: mob.x, y: mob.y };
                        
                        set(mobRef, {
                            x: respawnPos.x,
                            y: respawnPos.y,
                            health: 5,
                            maxHealth: 5,
                            type: 'goblin',
                            lastMove: Date.now(),
                            moveCounter: 0,
                            aggroTarget: null,
                            aggroRange: 3,
                            isAggro: false,
                            respawnTime: null
                        });
                    } else {
                        // Farm mob respawn (chickens and mice) - respawn in fence area
                        const mobRef = ref(database, `mobs/${mobId}`);
                        
                        // Generate new random position within the fence
                        const fenceMinX = Math.floor(GRID_WIDTH * 0.3) - 1;
                        const fenceMaxX = Math.floor(GRID_WIDTH * 0.7) + 1;
                        const fenceMinY = Math.floor(GRID_HEIGHT * 0.3) - 1;
                        const fenceMaxY = Math.floor(GRID_HEIGHT * 0.7) + 1;
                        
                        const newX = Math.floor(Math.random() * (fenceMaxX - fenceMinX)) + fenceMinX;
                        const newY = Math.floor(Math.random() * (fenceMaxY - fenceMinY)) + fenceMinY;
                        
                        set(mobRef, {
                            ...mob,
                            x: newX,
                            y: newY,
                            health: 2, // Restore full health for farm mobs
                            respawnTime: null, // Clear respawn timer
                        });
                    }
                } else if (mob && mob.health === 0 && !mob.respawnTime) {
                    // Dead mob without respawn timer - fix it
                    console.log(`Found dead ${mob.type} ${mobId} without respawn timer, fixing...`);
                    const mobRef = mob.type === 'goblin' ? 
                        ref(database, `forestMobs/${mobId}`) : 
                        ref(database, `mobs/${mobId}`);
                    
                    set(mobRef, {
                        ...mob,
                        respawnTime: now + 15000 // Set respawn for 15 seconds from now
                    });
                }
            });
            
            // FIXED: Goblin maintenance - ensure we always have 4 goblins in forest
            if (myZone === 4) {
                const forestGoblins = Object.entries(mobs).filter(([id, mob]) => 
                    mob && mob.type === 'goblin'
                );
                
                // If we have fewer than 4 goblin entries, create missing ones
                if (forestGoblins.length < 4) {
                    console.log(`Only ${forestGoblins.length} goblins found, creating missing ones...`);
                    const existingIds = forestGoblins.map(([id]) => id);
                    const expectedIds = ['goblin_1', 'goblin_2', 'goblin_3', 'goblin_4'];
                    
                    expectedIds.forEach(expectedId => {
                        if (!existingIds.includes(expectedId)) {
                            console.log(`Creating missing goblin ${expectedId}`);
                            const positions = {
                                'goblin_1': { x: 5, y: 4 },
                                'goblin_2': { x: 15, y: 4 },
                                'goblin_3': { x: 5, y: 11 },
                                'goblin_4': { x: 15, y: 11 }
                            };
                            
                            const pos = positions[expectedId];
                            const mobRef = ref(database, `forestMobs/${expectedId}`);
                            set(mobRef, {
                                x: pos.x,
                                y: pos.y,
                                health: 5,
                                maxHealth: 5,
                                type: 'goblin',
                                lastMove: Date.now(),
                                moveCounter: 0,
                                aggroTarget: null,
                                aggroRange: 3,
                                isAggro: false
                            });
                        }
                    });
                }
            }
            
            if (showLevelUpPopup && levelUpPopupTimer > 0) {
                levelUpPopupTimer -= 16;
                if (levelUpPopupTimer <= 0) {
                    showLevelUpPopup = false;
                }
            }
            
            if (showFishCatchPopup && fishCatchPopupTimer > 0) {
                fishCatchPopupTimer -= 16;
                if (fishCatchPopupTimer <= 0) {
                    showFishCatchPopup = false;
                }
            }
            
            if (showCookingPopup && cookingPopupTimer > 0) {
                cookingPopupTimer -= 16;
                if (cookingPopupTimer <= 0) {
                    showCookingPopup = false;
                }
            }
            
            if (showWoodcuttingPopup && woodcuttingPopupTimer > 0) {
                woodcuttingPopupTimer -= 16;
                if (woodcuttingPopupTimer <= 0) {
                    showWoodcuttingPopup = false;
                }
            }
            
            if (myHealth > 0 && !isRespawning && !isBlocking && !showDialog && !showCookingDialog && !showWoodcuttingDialog && !showMerchantDialog && !showTradeScreen && !showInventory && !showQuickChat && !showQuestDialog && !isFishing && !isCooking && !isWoodcutting && !isFiremaking && currentTime - lastMoveTime > 200) {
                let moved = false;
                let newPos = { ...myGridPos };

                if (keys['w']) {
                    newPos.y = Math.max(0, newPos.y - 1);
                    myDirection = 'up';
                    moved = true;
                }
                if (keys['s']) {
                    newPos.y = Math.min(GRID_HEIGHT - 1, newPos.y + 1);
                    myDirection = 'down';
                    moved = true;
                }
                if (keys['a']) {
                    newPos.x = Math.max(0, newPos.x - 1);
                    myDirection = 'left';
                    moved = true;
                }
                if (keys['d']) {
                    newPos.x = Math.min(GRID_WIDTH - 1, newPos.x + 1);
                    myDirection = 'right';
                    moved = true;
                }

                if (moved && !isPositionOccupied(newPos.x, newPos.y)) {
                    myGridPos = newPos;
                    document.getElementById('gridPos').textContent = `${myGridPos.x}, ${myGridPos.y}`;
                    checkZoneTransition();
                    updatePlayerData();
                    checkNPCInteraction();
                    checkDropPickup();
                    lastMoveTime = currentTime;
                }
            }
            
            if ((isFishing || isCooking || isWoodcutting) && (keys['w'] || keys['s'] || keys['a'] || keys['d'])) {
                stopFishing();
                stopCooking();
                stopWoodcutting();
            }

            if (keys[' '] && !showInventory && !isFishing) {
                castFireball();
                keys[' '] = false;
            }

            Object.entries(fireballs).forEach(([id, fireball]) => {
                if (fireball && fireball.ownerId === playerId) {
                    const timeSinceLastMove = currentTime - (fireball.lastMove || 0);
                    
                    if (timeSinceLastMove >= 500) {
                        const newX = fireball.x + fireball.dirX;
                        const newY = fireball.y + fireball.dirY;
                        
                        if (newX < 0 || newX >= GRID_WIDTH || newY < 0 || newY >= GRID_HEIGHT) {
                            const fireballRef = ref(database, `fireballs/${id}`);
                            set(fireballRef, null);
                        } else {
                            const fireballRef = ref(database, `fireballs/${id}`);
                            set(fireballRef, {
                                ...fireball,
                                x: newX,
                                y: newY,
                                lastMove: currentTime
                            });
                        }
                    }
                }
            });

            if ((myZone === 2 || myZone === 4 || myZone === 5)) {
                Object.entries(fireballs).forEach(([fireballId, fireball]) => {
                    if (fireball && fireball.zone === myZone) {
                        Object.entries(mobs).forEach(([mobId, mob]) => {
                            if (mob && mob.health > 0) {
                                // For boss (4x4), check if fireball hits any of its tiles
                                let isHit = false;

                                if (mob.type === 'warlord') {
                                    // Boss occupies 4x4 area centered on position
                                    const bossMinX = mob.x - 1;
                                    const bossMaxX = mob.x + 2;
                                    const bossMinY = mob.y - 1;
                                    const bossMaxY = mob.y + 2;

                                    isHit = (fireball.x >= bossMinX && fireball.x <= bossMaxX &&
                                            fireball.y >= bossMinY && fireball.y <= bossMaxY);
                                } else {
                                    // Normal mobs use single tile
                                    isHit = (mob.x === fireball.x && mob.y === fireball.y);
                                }

                                if (!isHit) return;

                                // Only hit mobs in current zone
                                let mobZone;
                                if (mob.type === 'warlord') {
                                    mobZone = 5;
                                } else if (mob.type === 'goblin') {
                                    mobZone = 4;
                                } else {
                                    mobZone = 2;
                                }

                                if (mobZone !== myZone) return;
    
                                console.log(`Fireball hit ${mob.type} at ${mob.x}, ${mob.y}`);
                                
                                // Calculate damage based on Magic skill level
                                const magicDamage = playerMagic >= MAGIC_DAMAGE_THRESHOLD ? ENHANCED_DAMAGE : BASE_DAMAGE;
                                const newHealth = Math.max(0, mob.health - magicDamage);
                                let mobRef;
                                if (myZone === 5) {
                                    mobRef = ref(database, `caveMobs/${mobId}`);
                                } else if (myZone === 4) {
                                    mobRef = ref(database, `forestMobs/${mobId}`);
                                } else {
                                    mobRef = ref(database, `mobs/${mobId}`);
                                }
                                
                                if (newHealth <= 0) {
                                    console.log(`${mob.type} killed - creating drops`);

                                    // Give magic skill XP for fireball kills
                                    if (playerMagic < 20) {
                                        playerMagic += 1;
                                        console.log(`Magic skill increased to ${playerMagic}!`);
                                    }

                                    // Calculate EXP based on mob type (BOSS GIVES MASSIVE XP)
                                    let expValue;
                                    if (mob.type === 'warlord') {
                                        expValue = 800; // MASSIVE XP BOOST
                                    } else if (mob.type === 'goblin') {
                                        expValue = 12;
                                    } else if (mob.type === 'chicken') {
                                        expValue = 8;
                                    } else {
                                        expValue = 6;
                                    }
                                    const expDropRef = ref(database, `drops/exp_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`);
                                    set(expDropRef, {
                                        x: mob.x,
                                        y: mob.y,
                                        zone: myZone,
                                        type: 'exp',
                                        value: expValue,
                                        createdAt: Date.now()
                                    });
                                    
                                    // Gold drops - BOSS drops guaranteed 150 gold
                                    if (mob.type === 'warlord' || Math.random() < 0.8) {
                                        let goldValue;
                                        if (mob.type === 'warlord') {
                                            goldValue = 150; // MASSIVE GOLD REWARD
                                        } else if (mob.type === 'goblin') {
                                            goldValue = Math.floor(Math.random() * 2) + 4; // 4-5 gold
                                        } else {
                                            goldValue = Math.floor(Math.random() * 3) + 2; // 2-4 gold
                                        }
                                        const goldDropRef = ref(database, `drops/gold_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`);
                                        set(goldDropRef, {
                                            x: mob.x,
                                            y: mob.y,
                                            zone: myZone,
                                            type: 'gold',
                                            value: goldValue,
                                            createdAt: Date.now()
                                        });
                                    }
                                    
                                    // Chicken feather drops from fireballs too
                                    if (mob.type === 'chicken' && Math.random() < 0.8) {
                                        const featherDropRef = ref(database, `drops/feather_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`);
                                        set(featherDropRef, {
                                            x: mob.x,
                                            y: mob.y,
                                            zone: myZone,
                                            type: 'feather',
                                            value: 1,
                                            createdAt: Date.now()
                                        });
                                    }
                                    
                                    // Track goblin kills for Sky's quest
                                    if (mob.type === 'goblin' && skyQuestActive) {
                                        goblinKillCount++;
                                        console.log(`Goblin killed by fireball! Progress: ${goblinKillCount}/4`);
                                    }
                                    
                                    // FIXED: Set respawn timer - 15 seconds for all mobs including boss
                                    set(mobRef, { ...mob, health: 0, respawnTime: Date.now() + 15000 });
                                } else {
                                    set(mobRef, { ...mob, health: newHealth });
                                }
                                
                                const fireballRef = ref(database, `fireballs/${fireballId}`);
                                set(fireballRef, null);
                            }
                        });
                    }
                });
            }

            if ((myZone === 2 || myZone === 4 || myZone === 5) && currentTime % 500 < 50) {
                Object.entries(mobs).forEach(([mobId, mob]) => {
                    if (mob && mob.health > 0) {
                        const mobZone = mob.zone || (mob.type === 'goblin' ? 4 : 2);
                        if (mobZone !== myZone) return; // Only process mobs in current zone
                        
                        const timeSinceLastMove = currentTime - (mob.lastMove || 0);
                        const moveCounter = mob.moveCounter || 0;
                        
                        if (mob.type === 'goblin') {
                            // Goblin AI - aggro behavior
                            const playerDistance = Math.abs(mob.x - myGridPos.x) + Math.abs(mob.y - myGridPos.y);
                            
                            if (playerDistance <= (mob.aggroRange || 3)) {
                                // Player in aggro range - set aggro and move towards player
                                const wasAggro = mob.isAggro;
                                mob.isAggro = true;
                                
                                if (timeSinceLastMove >= 800) { // Goblins move every 800ms when aggro
                                    let newX = mob.x;
                                    let newY = mob.y;
                                    
                                    // Move towards player
                                    if (mob.x < myGridPos.x) newX++;
                                    else if (mob.x > myGridPos.x) newX--;
                                    
                                    if (mob.y < myGridPos.y) newY++;
                                    else if (mob.y > myGridPos.y) newY--;
                                    
                                    // Ensure goblin stays within bounds
                                    newX = Math.max(1, Math.min(GRID_WIDTH - 2, newX));
                                    newY = Math.max(1, Math.min(GRID_HEIGHT - 2, newY));
                                    
                                    // Check if target position is occupied by terrain
                                    const isBlocked = isPositionOccupied(newX, newY);
                                    const isPlayerPosition = (newX === myGridPos.x && newY === myGridPos.y);

                                    if (!isBlocked && !isPlayerPosition) {
                                        // Safe to move - no terrain or player blocking
                                        const mobRef = ref(database, `forestMobs/${mobId}`);
                                        set(mobRef, {
                                            ...mob,
                                            x: newX,
                                            y: newY,
                                            lastMove: currentTime,
                                            moveCounter: moveCounter + 1,
                                            isAggro: true
                                        });
                                    } else if (isPlayerPosition) {
                                        // Goblin is trying to move onto player - attack instead!
                                        takeDamage();
                                        console.log('Goblin attacked player at close range!');

                                        // Update lastMove to prevent attack spam
                                        const mobRef = ref(database, `forestMobs/${mobId}`);
                                        set(mobRef, {
                                            ...mob,
                                            lastMove: currentTime,
                                            isAggro: true
                                        });
                                    }
                                }
                            } else if (mob.isAggro) {
                                // Player left aggro range - stop being aggressive after a delay
                                if (timeSinceLastMove >= 2000) {
                                    const mobRef = ref(database, `forestMobs/${mobId}`);
                                    set(mobRef, {
                                        ...mob,
                                        isAggro: false,
                                        lastMove: currentTime
                                    });
                                }
                            } else {
                                // Normal goblin movement when not aggro
                                const stayDuration = 4000 + (moveCounter % 3) * 1000; // Goblins move slower when not aggro
                                
                                if (timeSinceLastMove >= stayDuration) {
                                    const directions = [
                                        { x: 0, y: -1 }, { x: 0, y: 1 }, 
                                        { x: -1, y: 0 }, { x: 1, y: 0 },
                                        { x: 0, y: 0 }, { x: 0, y: 0 } // Stay in place sometimes
                                    ];
                                    
                                    const dir = directions[Math.floor(Math.random() * directions.length)];
                                    let newX = Math.max(1, Math.min(GRID_WIDTH - 2, mob.x + dir.x));
                                    let newY = Math.max(1, Math.min(GRID_HEIGHT - 2, mob.y + dir.y));
                                    
                                    const mobRef = ref(database, `forestMobs/${mobId}`);
                                    set(mobRef, {
                                        ...mob,
                                        x: newX,
                                        y: newY,
                                        lastMove: currentTime,
                                        moveCounter: moveCounter + 1
                                    });
                                }
                            }
                        } else if (mob.type === 'warlord') {
                            // BOSS AI - Similar to goblin but slower and more powerful
                            const playerDistance = Math.abs(mob.x - myGridPos.x) + Math.abs(mob.y - myGridPos.y);

                            if (playerDistance <= (mob.aggroRange || 5)) {
                                // Player in aggro range - boss becomes aggressive
                                mob.isAggro = true;

                                if (timeSinceLastMove >= 1200) { // Boss moves slower (1.2 seconds)
                                    // Check if adjacent to player (within 4 tiles due to boss size)
                                    const isAdjacentToPlayer = (
                                        Math.abs(mob.x - myGridPos.x) <= 2 &&
                                        Math.abs(mob.y - myGridPos.y) <= 2
                                    );

                                    if (isAdjacentToPlayer) {
                                        // FIXED: Don't attack if player is already dead or respawning
                                        if (isRespawning || myHealth <= 0) {
                                            // Update lastMove anyway to prevent spam checking
                                            const mobRef = ref(database, `caveMobs/${mobId}`);
                                            set(mobRef, {
                                                ...mob,
                                                lastMove: currentTime,
                                                isAggro: true
                                            });
                                            return; // Skip attack
                                        }

                                        // Boss is close enough - ATTACK PLAYER!
                                        // Deal exactly 3 damage
                                        myHealth = Math.max(0, myHealth - 3);
                                        updateHeartDisplay();
                                        updatePlayerData();
                                        console.log('üí• BOSS HIT PLAYER for 3 damage!');

                                        // Check if player died
                                        if (myHealth <= 0) {
                                            startRespawn();
                                        }

                                        // Update lastMove to prevent spam attacking
                                        const mobRef = ref(database, `caveMobs/${mobId}`);
                                        set(mobRef, {
                                            ...mob,
                                            lastMove: currentTime,
                                            isAggro: true
                                        });
                                    } else {
                                        // Move towards player
                                        let newX = mob.x;
                                        let newY = mob.y;

                                        if (mob.x < myGridPos.x) newX++;
                                        else if (mob.x > myGridPos.x) newX--;

                                        if (mob.y < myGridPos.y) newY++;
                                        else if (mob.y > myGridPos.y) newY--;

                                        // Check if target position is valid (not out of bounds)
                                        newX = Math.max(2, Math.min(GRID_WIDTH - 3, newX)); // Boss needs more space
                                        newY = Math.max(2, Math.min(GRID_HEIGHT - 8, newY)); // Keep boss away from entrance area

                                        // Don't let boss get too close to entrance area
                                        const safeZoneY = GRID_HEIGHT - 7;
                                        if (newY > safeZoneY) {
                                            newY = safeZoneY; // Stop before corridors
                                        }

                                        // Boss doesn't check for terrain collision - it's too powerful!
                                        const mobRef = ref(database, `caveMobs/${mobId}`);
                                        set(mobRef, {
                                            ...mob,
                                            x: newX,
                                            y: newY,
                                            lastMove: currentTime,
                                            moveCounter: moveCounter + 1,
                                            isAggro: true
                                        });
                                    }
                                }
                            } else if (mob.isAggro) {
                                // Player left aggro range - calm down after delay
                                if (timeSinceLastMove >= 3000) {
                                    const mobRef = ref(database, `caveMobs/${mobId}`);
                                    set(mobRef, {
                                        ...mob,
                                        isAggro: false,
                                        lastMove: currentTime
                                    });
                                }
                            } else {
                                // Idle movement - boss stays mostly still
                                const stayDuration = 5000; // Boss rarely moves when not aggro

                                if (timeSinceLastMove >= stayDuration) {
                                    // Occasionally take a small step
                                    if (Math.random() < 0.3) { // 30% chance to move
                                        const directions = [
                                            { x: 0, y: -1 }, { x: 0, y: 1 },
                                            { x: -1, y: 0 }, { x: 1, y: 0 },
                                            { x: 0, y: 0 } // Stay in place (most common)
                                        ];

                                        const dir = directions[Math.floor(Math.random() * directions.length)];
                                        let newX = Math.max(2, Math.min(GRID_WIDTH - 3, mob.x + dir.x));
                                        let newY = Math.max(2, Math.min(GRID_HEIGHT - 3, mob.y + dir.y));

                                        const mobRef = ref(database, `caveMobs/${mobId}`);
                                        set(mobRef, {
                                            ...mob,
                                            x: newX,
                                            y: newY,
                                            lastMove: currentTime,
                                            moveCounter: moveCounter + 1
                                        });
                                    }
                                }
                            }
                        } else {
                            // Regular mob movement (chickens and mice in wilderness)
                            const stayDuration = 3000 + (moveCounter % 3) * 1000;
                            
                            if (timeSinceLastMove >= stayDuration) {
                                const fenceMinX = Math.floor(GRID_WIDTH * 0.3) - 1 + 1;
                                const fenceMaxX = Math.floor(GRID_WIDTH * 0.7) + 1 - 1;
                                const fenceMinY = Math.floor(GRID_HEIGHT * 0.3) - 1 + 1;
                                const fenceMaxY = Math.floor(GRID_HEIGHT * 0.7) + 1 - 1;
                                
                                const directions = [
                                    { x: 0, y: -1 }, { x: 0, y: 1 }, 
                                    { x: -1, y: 0 }, { x: 1, y: 0 },
                                    { x: 0, y: 0 }, { x: 0, y: 0 }
                                ];
                                
                                const dir = directions[Math.floor(Math.random() * directions.length)];
                                let newX = mob.x + dir.x;
                                let newY = mob.y + dir.y;
                                
                                newX = Math.max(fenceMinX, Math.min(fenceMaxX, newX));
                                newY = Math.max(fenceMinY, Math.min(fenceMaxY, newY));
                                
                                const mobRef = ref(database, `mobs/${mobId}`);
                                set(mobRef, {
                                    ...mob,
                                    x: newX,
                                    y: newY,
                                    lastMove: currentTime,
                                    moveCounter: moveCounter + 1
                                });
                            }
                        }
                    }
                });
            }

            drawGame();
            requestAnimationFrame(gameLoop);
        }

        // DEBUG: Manual goblin spawning function (can be called from browser console)
        window.forceSpawnGoblins = function() {
            console.log('üêâ FORCE SPAWNING GOBLINS...');
            const goblinPositions = [
                { x: 5, y: 4 },   // Top-left area
                { x: 15, y: 4 },  // Top-right area  
                { x: 5, y: 11 },  // Bottom-left area
                { x: 15, y: 11 }  // Bottom-right area
            ];
            
            goblinPositions.forEach((pos, index) => {
                const mobId = `goblin_${index + 1}_${Date.now()}`;
                const mobRef = ref(database, `forestMobs/${mobId}`);
                
                console.log(`üêâ Creating goblin ${index + 1} at position ${pos.x}, ${pos.y}`);
                set(mobRef, {
                    x: pos.x,
                    y: pos.y,
                    health: 5,
                    maxHealth: 5,
                    type: 'goblin',
                    lastMove: Date.now(),
                    moveCounter: 0,
                    aggroTarget: null,
                    aggroRange: 3,
                    isAggro: false
                });
            });
        };
        initializeGame();
        listenToGameData();
        gameLoop();
        updateHeartDisplay();
        updateGoldDisplay();

        // Music toggle button handler
        document.getElementById('musicToggle')?.addEventListener('click', () => {
            isMusicEnabled = !isMusicEnabled;
            const toggleBtn = document.getElementById('musicToggle');
            
            if (isMusicEnabled) {
                toggleBtn.textContent = 'üîä ON';
                toggleBtn.style.color = '#e8f5e8';
                playZoneMusic(myZone); // Resume music for current zone
            } else {
                toggleBtn.textContent = 'üîá OFF';
                toggleBtn.style.color = '#ff6b6b';
                stopZoneMusic(); // Stop music
            }
        });

        // Emergency fallback if Firebase doesn't respond within 5 seconds
        setTimeout(() => {
            if (!isPlayerCreated) {
                console.log('Firebase timeout - creating player manually with fallback');
                createPlayerWithFirebaseData({});
                // IMPORTANT: Set the flag to true so updatePlayerData() will work
                isPlayerCreated = true;
            }
        }, 5000);

        console.log('üå≤ Game loaded successfully!');
    </script>
</body>
</html>
